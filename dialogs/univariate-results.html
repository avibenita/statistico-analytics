<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Univariate Analysis Results</title>
  
  <!-- Office.js -->
  <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
  
  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" rel="stylesheet" />
  
  <!-- Highcharts for Charts -->
  <script src="https://code.highcharts.com/highcharts.js"></script>
  <script src="https://code.highcharts.com/highcharts-more.js"></script>
  <script src="https://code.highcharts.com/modules/histogram-bellcurve.js"></script>
  <script src="https://code.highcharts.com/modules/solid-gauge.js"></script>
  
  <!-- jStat for Statistical Calculations -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.9.4/jstat.min.js"></script>
  
  <!-- Shared Results Dialog CSS -->
  <link rel="stylesheet" href="shared/css/results-dialog.css">
  
  <style>
    /* Dialog-specific styles loaded from shared/css/results-dialog.css */
    /* Add any dialog-specific overrides here if needed */
  </style>


    .header-center {
      text-align: center;
    }

    .header-view-name {
      font-size: 18px;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 4px;
    }

    .header-variable {
      font-size: 14px;
      font-style: italic;
      color: var(--text-secondary);
    }

    /* Part 3: Right - Dropdown */
    .header-right {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 12px;
    }

    .dropdown-btn {
      padding: 8px 16px;
      background: var(--surface-0);
      border: 1.5px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s;
    }

    .dropdown-btn:hover {
      border-color: var(--accent-1);
      box-shadow: 0 2px 4px rgba(249, 115, 22, 0.1);
    }

    .dropdown-content {
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      background: var(--surface-0);
      border: 1.5px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      min-width: 250px;
      display: none;
      z-index: 1000;
    }

    .dropdown-content.show { display: block; }

    .analysis-option {
      padding: 12px 16px;
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .analysis-option:hover {
      background: var(--surface-1);
    }

    .analysis-option.active {
      background: var(--surface-1);
      color: var(--accent-1);
      font-weight: 600;
    }

    .close-btn {
      padding: 8px 16px;
      background: var(--surface-0);
      border: 1.5px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
    }

    .close-btn:hover {
      border-color: #dc2626;
      color: #dc2626;
    }

    /* Content - Flexible and scrollable */
    .content {
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      width: 100%;
    }

    /* Statistics Panel */
    .stats-panel {
      background: var(--surface-0);
      border: 1.5px solid var(--border);
      border-radius: 8px;
      margin-bottom: 20px;
      overflow: hidden;
    }

    .panel-heading {
      background: var(--surface-1);
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 600;
      font-size: 15px;
    }

    .stats-table {
      width: 100%;
      border-collapse: collapse;
    }

    .stats-table th {
      background: var(--surface-1);
      padding: 10px;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
      border-bottom: 1px solid var(--border);
    }

    .stats-table th.highlight {
      background: rgba(249, 115, 22, 0.1);
      color: var(--accent-1);
      font-weight: 700;
    }

    .stats-table td {
      padding: 12px;
      text-align: center;
      font-size: 13px;
      border-bottom: 1px solid var(--border);
    }

    .stats-table td.highlight {
      background: rgba(249, 115, 22, 0.05);
      color: var(--accent-1);
      font-weight: 700;
      font-size: 15px;
    }

    .stats-table tr:last-child td {
      border-bottom: none;
    }

    /* Histogram Panel */
    .histogram-panel {
      background: var(--surface-0);
      border: 1.5px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
    }

    .histogram-controls {
      padding: 12px 16px;
      background: var(--surface-1);
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      align-items: center;
      font-size: 12px;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .control-group label {
      font-weight: 600;
      color: var(--text-secondary);
    }

    .control-group select {
      padding: 6px 10px;
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 12px;
      background: var(--surface-0);
    }

    .control-group input[type="range"] {
      width: 100px;
    }

    .control-group input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: var(--accent-1);
    }

    .value-display {
      min-width: 40px;
      text-align: center;
      font-weight: 600;
      color: var(--text-primary);
      font-size: 12px;
    }

    /* Range Controls for Data Cropping */
    .range-controls {
      padding: 16px;
      background: var(--surface-1);
      border-top: 1px solid var(--border);
    }

    .range-slider-row {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
      color: var(--text-secondary);
      font-weight: 600;
    }

    .slider-container {
      position: relative;
      flex: 1;
      height: 30px;
      display: flex;
      align-items: center;
    }

    .slider-track {
      position: absolute;
      width: 100%;
      height: 6px;
      background: var(--surface-2);
      border-radius: 3px;
      pointer-events: none;
    }

    .active-range {
      position: absolute;
      height: 6px;
      background: var(--accent-1);
      border-radius: 3px;
      pointer-events: none;
      left: 0%;
      width: 100%;
      z-index: 0;
    }

    .slider-container input[type="range"] {
      position: absolute;
      width: 100%;
      background: transparent;
      pointer-events: all;
      -webkit-appearance: none;
      appearance: none;
      margin: 0;
    }

    .slider-container input[type="range"]::-webkit-slider-runnable-track {
      height: 6px;
      background: transparent;
      border-radius: 3px;
    }

    .slider-container input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent-2);
      cursor: pointer;
      border: 3px solid white;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      margin-top: -6px;
    }

    .slider-container input[type="range"]::-moz-range-track {
      height: 6px;
      background: transparent;
      border-radius: 3px;
    }

    .slider-container input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent-2);
      cursor: pointer;
      border: 3px solid white;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }

    /* Remove z-index from CSS - will be set inline in HTML */

    .reset-button {
      background: var(--surface-0);
      color: var(--text-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 4px 12px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .reset-button:hover {
      border-color: var(--accent-1);
      color: var(--accent-1);
      background: var(--surface-2);
    }

    .range-display {
      margin-top: 8px;
      text-align: center;
    }

    #histogram-chart {
      padding: 16px;
      width: 100%;
      height: clamp(400px, 55vh, 700px); /* Taller for better visibility */
    }

    /* Loading */
    .loading {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-muted);
    }

    /* Box Plot Panels */
    .boxplot-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .boxplot-panel {
      background: var(--surface-0);
      border: 1.5px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
    }

    #boxWithOutliers,
    #boxWithoutOutliers {
      width: 100%;
      height: clamp(250px, 30vh, 350px);
      padding: 16px;
    }

    /* QQ/PP Plot Styles */
    .qqpp-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    .qqpp-panel {
      background: var(--surface-0);
      border: 1.5px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
    }

    #plot1,
    #plot2,
    #qqPlot,
    #ppPlot {
      width: 100%;
      height: clamp(280px, 35vh, 400px);
      padding: 12px;
    }

    /* Radio button styling */
    input[type="radio"] {
      accent-color: var(--accent-1);
      cursor: pointer;
    }

    input[type="radio"]:checked + span {
      color: var(--accent-1);
      font-weight: 600;
    }

    /* Normality Tests Styles */
    .normality-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .normality-summary {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
    }

    .normality-gauge {
      flex: 1;
      min-width: 200px;
      background: var(--surface-0);
      border: 1.5px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      text-align: center;
    }

    #normalityGauge {
      height: 180px;
    }

    .normality-stats {
      flex: 2;
      background: var(--surface-0);
      border: 1.5px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 12px;
    }

    .stat-box {
      text-align: center;
      padding: 12px;
      background: var(--surface-1);
      border-radius: 6px;
    }

    .stat-box-value {
      font-size: 20px;
      font-weight: 700;
      color: var(--accent-1);
      margin-bottom: 4px;
    }

    .stat-box-label {
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .tests-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 12px;
    }

    .test-card {
      background: var(--surface-0);
      border: 1.5px solid var(--border);
      border-radius: 8px;
      padding: 14px;
    }

    .test-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .test-name {
      font-weight: 600;
      font-size: 14px;
      color: var(--text-primary);
    }

    .test-badge {
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .test-badge.pass {
      background: rgba(46, 204, 113, 0.15);
      color: #2ecc71;
    }

    .test-badge.fail {
      background: rgba(231, 76, 60, 0.15);
      color: #e74c3c;
    }

    .test-details {
      font-size: 12px;
    }

    .test-detail-row {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
      border-bottom: 1px solid var(--border);
    }

    .test-detail-row:last-child {
      border-bottom: none;
    }

    .test-detail-label {
      color: var(--text-muted);
    }

    .test-detail-value {
      color: var(--text-primary);
      font-weight: 600;
      font-family: 'Courier New', monospace;
    }

    /* Kernel Density Styles */
    .kernel-container {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .kernel-controls {
      background: var(--surface-0);
      border: 1.5px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
    }

    .kernel-control-group {
      flex: 1;
      min-width: 200px;
    }

    .kernel-control-label {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 8px;
      display: block;
    }

    .kernel-slider {
      width: 100%;
    }

    .kernel-value-display {
      font-size: 13px;
      color: var(--accent-1);
      font-weight: 700;
      margin-top: 4px;
    }

    #kernelChart {
      width: 100%;
      height: clamp(450px, 60vh, 750px); /* Much taller to fill available space */
      padding: 16px;
      background: var(--surface-0);
      border: 1.5px solid var(--border);
      border-radius: 8px;
    }

    .spinner {
      border: 3px solid var(--border);
      border-top: 3px solid var(--accent-1);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 0.8s linear infinite;
      margin: 0 auto 16px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Floating Close Button */
    .close-btn-floating {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 54px;
      height: 54px;
      background: #dc2626;
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 22px;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .close-btn-floating:hover {
      background: #b91c1c;
      box-shadow: 0 6px 16px rgba(220, 38, 38, 0.4);
      transform: scale(1.08);
    }

    .close-btn-floating:active {
      transform: scale(0.95);
    }

    /* ===== DARK THEME ===== */
    body.theme-dark {
      --surface-0: #0c1624;
      --surface-1: #1a1f2e;
      --surface-2: #242938;
      --border: #2d3748;
      --accent-1: rgb(255,165,120);
      --accent-2: rgb(120,200,255);
      --text-primary: #ffffff;
      --text-secondary: rgba(255,255,255,0.8);
      --text-muted: rgba(255,255,255,0.6);
      background-color: #0c1624;
    }

    body.theme-dark .header {
      background: #1a1f2e;
      border-bottom: 1px solid #2d3748;
    }

    body.theme-dark .header-logo {
      background: linear-gradient(135deg, rgb(255,165,120), rgb(120,200,255));
    }

    body.theme-dark .header-view-name,
    body.theme-dark .header-module-name {
      color: #ffffff;
    }

    body.theme-dark .header-brand,
    body.theme-dark .header-variable {
      color: rgba(255,255,255,0.7);
    }

    body.theme-dark .dropdown-btn {
      background: #242938;
      border-color: #2d3748;
      color: #ffffff;
    }

    body.theme-dark .dropdown-btn:hover {
      border-color: rgb(255,165,120);
      background: #2d3748;
    }

    body.theme-dark .dropdown-content {
      background: #1a1f2e;
      border-color: #2d3748;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    }

    body.theme-dark .analysis-option {
      color: rgba(255,255,255,0.9);
    }

    body.theme-dark .analysis-option:hover {
      background: #242938;
      color: rgb(255,165,120);
    }

    body.theme-dark .analysis-option.active {
      background: #242938;
      color: rgb(255,165,120);
    }

    body.theme-dark .stats-panel {
      background: #1a1f2e;
      border-color: #2d3748;
    }

    body.theme-dark .boxplot-panel {
      background: #1a1f2e;
      border-color: #2d3748;
    }

    body.theme-dark .qqpp-panel,
    body.theme-dark .normality-gauge,
    body.theme-dark .normality-stats,
    body.theme-dark .test-card,
    body.theme-dark .kernel-controls,
    body.theme-dark #kernelChart {
      background: #1a1f2e;
      border-color: #2d3748;
    }

    body.theme-dark .stat-box {
      background: #242938;
    }

    body.theme-dark .test-badge.pass {
      background: rgba(46, 204, 113, 0.2);
      color: #2ecc71;
    }

    body.theme-dark .test-badge.fail {
      background: rgba(231, 76, 60, 0.2);
      color: #e74c3c;
    }

    body.theme-dark .panel-heading {
      background: #242938;
      border-bottom-color: #2d3748;
      color: #ffffff;
    }

    body.theme-dark .stats-table th {
      background: #242938;
      color: rgba(255,255,255,0.9);
      border-bottom-color: #2d3748;
    }

    body.theme-dark .stats-table th.highlight {
      background: rgba(255, 165, 120, 0.2);
      color: rgb(255,165,120);
    }

    body.theme-dark .stats-table td {
      color: rgba(255,255,255,0.8);
      border-bottom-color: #2d3748;
    }

    body.theme-dark .stats-table td.highlight {
      background: rgba(255, 165, 120, 0.1);
      color: rgb(255,165,120);
    }

    body.theme-dark .histogram-panel {
      background: #1a1f2e;
      border-color: #2d3748;
    }

    body.theme-dark .histogram-controls {
      background: #242938;
      border-bottom-color: #2d3748;
    }

    body.theme-dark .control-group label {
      color: rgba(255,255,255,0.8);
    }

    body.theme-dark .control-group select {
      background: #1a1f2e;
      color: #ffffff;
      border-color: #2d3748;
    }

    body.theme-dark .range-controls {
      background: #242938;
      border-top-color: #2d3748;
    }

    body.theme-dark .slider-track {
      background: #1a1f2e;
    }

    body.theme-dark .active-range {
      background: rgb(255,165,120);
    }

    body.theme-dark .range-slider-row {
      color: rgba(255,255,255,0.8);
    }

    body.theme-dark .value-display {
      color: #ffffff;
    }

    body.theme-dark .reset-button {
      background: #1a1f2e;
      color: rgba(255,255,255,0.8);
      border-color: #2d3748;
    }

    body.theme-dark .reset-button:hover {
      border-color: rgb(255,165,120);
      color: rgb(255,165,120);
    }

    body.theme-dark .close-btn-floating {
      background: #dc2626;
      box-shadow: 0 4px 12px rgba(220, 38, 38, 0.5);
    }

    /* Highcharts dark theme overrides */
    body.theme-dark .highcharts-background {
      fill: #1a1f2e !important;
    }

    body.theme-dark .highcharts-title,
    body.theme-dark .highcharts-axis-title,
    body.theme-dark .highcharts-axis-labels,
    body.theme-dark .highcharts-legend-item text {
      fill: #ffffff !important;
    }

    body.theme-dark .highcharts-grid-line {
      stroke: #2d3748 !important;
    }

    body.theme-dark .highcharts-tooltip-box {
      fill: #242938 !important;
      stroke: #2d3748 !important;
    }

    body.theme-dark .highcharts-tooltip text {
      fill: #ffffff !important;
    }

    /* ===== RESPONSIVE DESIGN FOR RESULTS DIALOG ===== */

    /* Adjust header for smaller screens */
    @media (max-width: 768px) {
      .header {
        padding: 12px 16px;
        grid-template-columns: 1fr;
        gap: 12px;
        text-align: center;
      }

      .header-left,
      .header-center,
      .header-right {
        justify-content: center;
      }

      .header-view-name {
        font-size: 16px;
      }

      .header-variable {
        font-size: 12px;
      }

      .content {
        padding: 12px;
      }
    }

    /* Compact tables on small screens */
    @media (max-width: 640px) {
      .stats-table {
        font-size: 11px;
      }

      .stats-table th,
      .stats-table td {
        padding: 8px 6px;
      }

      .panel-heading {
        padding: 10px 12px;
        font-size: 14px;
      }

      .histogram-controls {
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
      }

      .control-group {
        justify-content: space-between;
      }

      #histogram-chart {
        height: clamp(350px, 45vh, 550px);
      }

      #kernelChart {
        height: clamp(350px, 50vh, 600px);
      }

      #boxWithOutliers,
      #boxWithoutOutliers {
        height: clamp(200px, 28vh, 300px);
      }

      .qqpp-container {
        grid-template-columns: 1fr;
      }

      #plot1,
      #plot2,
      #qqPlot,
      #ppPlot {
        height: clamp(250px, 30vh, 320px);
      }

      .tests-grid {
        grid-template-columns: 1fr;
      }

      #normalityGauge {
        height: 150px;
      }
    }

    /* Very small screens - Stack statistics */
    @media (max-width: 480px) {
      .stats-table {
        display: block;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }

      .header-logo {
        width: 30px;
        height: 30px;
        font-size: 16px;
      }

      .header-module-name {
        font-size: 13px;
      }

      .header-brand {
        font-size: 10px;
      }

      .dropdown-btn {
        font-size: 11px;
        padding: 6px 12px;
      }

      .content {
        padding: 10px;
      }

      .stats-panel {
        margin-bottom: 12px;
      }

      #histogram-chart {
        padding: 10px;
        height: clamp(300px, 40vh, 450px);
      }

      #boxWithOutliers,
      #boxWithoutOutliers {
        height: clamp(180px, 25vh, 280px);
        padding: 10px;
      }

      .boxplot-container {
        gap: 12px;
      }

      .normality-summary {
        flex-direction: column;
      }

      .normality-stats {
        grid-template-columns: repeat(2, 1fr);
      }

      #kernelChart {
        height: clamp(300px, 45vh, 500px);
      }

      .kernel-controls {
        flex-direction: column;
        gap: 12px;
      }

      .range-slider-row {
        font-size: 11px;
        gap: 6px;
      }

      .value-display {
        min-width: 40px;
        font-size: 11px;
      }

      .reset-button {
        padding: 4px 8px;
        font-size: 10px;
      }

      .close-btn-floating {
        width: 44px;
        height: 44px;
        bottom: 16px;
        right: 16px;
        font-size: 18px;
      }
    }

    /* Landscape mode - maximize vertical space */
    @media (orientation: landscape) and (max-height: 600px) {
      .header {
        padding: 10px 16px;
      }

      .header-view-name {
        font-size: 16px;
        margin-bottom: 2px;
      }

      .header-variable {
        font-size: 12px;
      }

      .content {
        padding: 12px;
      }

      .stats-panel {
        margin-bottom: 12px;
      }

      .panel-heading {
        padding: 8px 12px;
      }

      .stats-table th,
      .stats-table td {
        padding: 6px 8px;
      }

      #histogram-chart {
        height: clamp(250px, 50vh, 400px);
        padding: 10px;
      }

      #kernelChart {
        height: clamp(250px, 55vh, 450px);
      }

      #boxWithOutliers,
      #boxWithoutOutliers {
        height: clamp(180px, 35vh, 260px);
        padding: 10px;
      }

      .histogram-controls {
        padding: 8px 12px;
      }

      .range-controls {
        padding: 10px 12px;
      }
    }

    /* Ensure content fits within viewport */
    @media (max-height: 700px) {
      .content {
        padding: 12px;
      }

      .stats-panel {
        margin-bottom: 10px;
      }

      #histogram-chart {
        height: clamp(300px, 45vh, 500px);
      }

      #kernelChart {
        height: clamp(300px, 50vh, 550px);
      }

      #boxWithOutliers,
      #boxWithoutOutliers {
        height: clamp(200px, 30vh, 320px);
      }
    }

    @media (max-height: 500px) {
      .stats-panel {
        margin-bottom: 8px;
      }

      .panel-heading {
        padding: 6px 10px;
        font-size: 13px;
      }

      .stats-table {
        font-size: 11px;
      }

      .stats-table th,
      .stats-table td {
        padding: 4px 6px;
      }

      #histogram-chart {
        height: clamp(200px, 40vh, 300px);
        padding: 8px;
      }

      #kernelChart {
        height: clamp(200px, 45vh, 350px);
      }

      #boxWithOutliers,
      #boxWithoutOutliers {
        height: clamp(140px, 25vh, 220px);
        padding: 8px;
      }

      .boxplot-container {
        gap: 8px;
      }

      .histogram-controls {
        padding: 6px 10px;
      }

      .range-controls {
        padding: 8px 10px;
      }
    }

    /* Touch devices - bigger touch targets */
    @media (pointer: coarse) {
      .dropdown-btn,
      .reset-button,
      .analysis-option {
        min-height: 44px;
      }

      .control-group input[type="range"] {
        height: 44px;
      }
    }
  </style>
</head>
<body>
  <!-- Header - 3 Parts -->
  <div class="header">
    <!-- Part 1: Logo + Module Name -->
    <div class="header-left">
      <div class="header-logo">
        <i class="fa-solid fa-chart-line"></i>
      </div>
      <div class="header-module">
        <div class="header-brand">Statistico Analytics</div>
        <div class="header-module-name">Univariate Analysis</div>
      </div>
    </div>

    <!-- Part 2: Center - View Name + Variable -->
    <div class="header-center">
      <div class="header-view-name" id="viewName">Interactive Histogram</div>
      <div class="header-variable">
        <span id="variableName">Variable</span> <span id="sampleSize">(n=--)</span>
      </div>
    </div>

    <!-- Part 3: Right - Dropdown -->
    <div class="header-right">
      <div style="position: relative;">
        <button class="dropdown-btn" onclick="toggleDropdown()">
          <i class="fa-solid fa-bars"></i>
          Advanced Results
          <i class="fa-solid fa-chevron-down"></i>
        </button>
        <div class="dropdown-content" id="dropdownMenu">
          <div class="analysis-option active" onclick="showView('histogram')">
            <i class="fa-solid fa-chart-column"></i>
            Histogram & Stats
          </div>
          <div class="analysis-option" onclick="showView('boxplot')">
            <i class="fa-solid fa-box"></i>
            Box Plot
          </div>
          <div class="analysis-option" onclick="showView('qqplot')">
            <i class="fa-solid fa-chart-scatter"></i>
            Q-Q Plot
          </div>
          <div class="analysis-option" onclick="showView('normality')">
            <i class="fa-solid fa-vial"></i>
            Normality Tests
          </div>
          <div class="analysis-option" onclick="showView('kernel')">
            <i class="fa-solid fa-wave-square"></i>
            Kernel Density
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Content -->
  <div class="content" id="resultsContent">
    <div class="loading">
      <div class="spinner"></div>
      <div>Loading results...</div>
    </div>
  </div>

  <script>
    let resultsData = null;
    let histogramChart = null;
    let currentData = [];
    let currentDecimals = 2;

    // Apply theme from localStorage
    function applyTheme() {
      const theme = localStorage.getItem('resultsTheme') || 'light';
      document.body.classList.remove('theme-light', 'theme-dark');
      document.body.classList.add(`theme-${theme}`);
    }

    // Load results when page is ready
    if (typeof Office !== 'undefined') {
      Office.onReady(() => {
        applyTheme();
        loadResults();
      });
    } else {
      // Fallback if Office.js not available
      window.addEventListener('DOMContentLoaded', () => {
        applyTheme();
        loadResults();
      });
    }

    function loadResults() {
      const dataJSON = localStorage.getItem('univariateResults');
      if (dataJSON) {
        resultsData = JSON.parse(dataJSON);
        displayHistogramView();
      } else {
        document.getElementById('resultsContent').innerHTML = `
          <div class="loading">
            <i class="fa-solid fa-exclamation-triangle" style="font-size: 40px; color: #dc2626; margin-bottom: 16px;"></i>
            <div style="color: #dc2626;">No results data found</div>
          </div>
        `;
      }
    }

    function displayHistogramView() {
      const { descriptive, n, column, dataSource } = resultsData;
      
      // Format all statistics with current decimal places
      const d = currentDecimals;
      const stats = {
        mean: parseFloat(descriptive.mean).toFixed(d),
        stdDev: parseFloat(descriptive.stdDev).toFixed(d),
        variance: parseFloat(descriptive.variance).toFixed(d),
        kurtosis: parseFloat(descriptive.kurtosis).toFixed(d),
        skewness: parseFloat(descriptive.skewness).toFixed(d),
        range: parseFloat(descriptive.range).toFixed(d),
        min: parseFloat(descriptive.min).toFixed(d),
        q1: parseFloat(descriptive.q1).toFixed(d),
        median: parseFloat(descriptive.median).toFixed(d),
        q3: parseFloat(descriptive.q3).toFixed(d),
        max: parseFloat(descriptive.max).toFixed(d)
      };
      
      // Update header with variable info
      document.getElementById('variableName').textContent = column || 'Variable';
      document.getElementById('sampleSize').textContent = `(n=${n})`;
      
      document.getElementById('resultsContent').innerHTML = `
        <!-- Statistics Panel -->
        <div class="stats-panel">
          <div class="panel-heading">
            <span>Descriptive Statistics</span>
            <div style="display: flex; align-items: center; gap: 12px;">
              <label for="decimalsSelect" style="font-size: 12px; color: var(--text-muted); margin: 0;">Decimals:</label>
              <select id="decimalsSelect" onchange="updateDecimals()" style="padding: 4px 8px; font-size: 12px; border: 1px solid var(--border); border-radius: 4px; background: var(--surface-0); color: var(--text-primary);">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2" selected>2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
              <span style="font-size: 12px; color: var(--text-muted);">n = ${n}</span>
            </div>
          </div>
          <div style="padding: 12px;">
            <!-- Table 1: Central Tendency -->
            <table class="stats-table" style="margin-bottom: 12px;">
              <thead>
                <tr>
                  <th class="highlight">Count</th>
                  <th class="highlight">Mean</th>
                  <th class="highlight">Std Dev</th>
                  <th>Variance</th>
                  <th>Kurtosis</th>
                  <th>Skewness</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td class="highlight">${n}</td>
                  <td class="highlight">${stats.mean}</td>
                  <td class="highlight">${stats.stdDev}</td>
                  <td>${stats.variance}</td>
                  <td>${stats.kurtosis}</td>
                  <td>${stats.skewness}</td>
                </tr>
              </tbody>
            </table>

            <!-- Table 2: Range & Quartiles -->
            <table class="stats-table">
              <thead>
                <tr>
                  <th>Range</th>
                  <th>Minimum</th>
                  <th>Q25</th>
                  <th class="highlight">Median</th>
                  <th>Q75</th>
                  <th>Maximum</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>${stats.range}</td>
                  <td>${stats.min}</td>
                  <td>${stats.q1}</td>
                  <td class="highlight">${stats.median}</td>
                  <td>${stats.q3}</td>
                  <td>${stats.max}</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <!-- Histogram Panel -->
        <div class="histogram-panel">
          <div class="panel-heading">
            Interactive Histogram
          </div>
          <!-- Histogram Controls -->
          <div class="histogram-controls">
            <!-- Binning Method -->
            <div class="control-group">
              <label for="binningMethod">Method:</label>
              <select id="binningMethod" onchange="updateBinningMethod()">
                <option value="manual">Manual (User-defined)</option>
                <option value="sturges">Sturges (log₂)</option>
                <option value="scott">Scott (Normal optimal)</option>
                <option value="fd">Freedman-Diaconis (Robust)</option>
                <option value="sqrt">Square Root (√n)</option>
                <option value="rice">Rice (2n^(1/3))</option>
              </select>
              <i class="fa-solid fa-info-circle" style="color: var(--accent-2); cursor: help;" title="Binning Methods&#10;• Manual: Choose bins yourself&#10;• Sturges: Good for normal distributions&#10;• Scott: Optimal for minimizing error&#10;• Freedman-Diaconis: Robust to outliers"></i>
            </div>

            <!-- Bins Slider (Manual mode) -->
            <div class="control-group" id="manualBinsControl">
              <label for="numBins">Bins:</label>
              <span id="binsValue">5</span>
              <input type="range" id="numBins" min="1" max="30" value="5" step="1" oninput="updateHistogram()">
            </div>

            <!-- Normal Curve Toggle -->
            <div class="control-group">
              <label for="showNormalCurve">Normal:</label>
              <input type="checkbox" id="showNormalCurve" checked onchange="updateHistogram()">
            </div>
          </div>

          <!-- Histogram Chart -->
          <div id="histogram-chart"></div>

          <!-- Range Sliders for Cropping Data -->
          <div class="range-controls">
            <div class="range-slider-row">
              <span>Min</span>
              <span id="leftRangeValue" class="value-display">0</span>
              
              <!-- Dual Sliders -->
              <div class="slider-container">
                <div class="slider-track"></div>
                <div id="activeRangeIndicator" class="active-range"></div>
                <input type="range" id="leftTruncation" min="0" max="100" value="0" step="1" style="position: absolute; width: 100%; background: transparent; z-index: 2;">
                <input type="range" id="rightTruncation" min="0" max="100" value="100" step="1" style="position: absolute; width: 100%; background: transparent; z-index: 1;">
              </div>
              
              <span id="rightRangeValue" class="value-display">100</span>
              <span>Max</span>
              <button id="resetRanges" class="reset-button" onclick="resetRangeSliders()">Reset</button>
              <span style="margin-left: 10px; color: var(--text-muted); font-size: 12px;">n: <span id="remainingN">--</span></span>
            </div>
            
            <!-- Data Range Display -->
            <div class="range-display" style="display: flex; justify-content: center; gap: 20px; margin-top: 8px; font-size: 11px; color: var(--text-muted);">
              <span id="data-min-value">Min: --</span>
              <span id="data-max-value">Max: --</span>
            </div>
          </div>
        </div>
      `;

      // Wait for DOM to be ready before initializing
      setTimeout(() => {
        initializeRangeSliders();
        updateDecimals(); // Apply initial decimal formatting
        createHistogram(true); // Animate on initial load
      }, 100);
    }

    function createHistogram(animate = false) {
      if (!resultsData || !resultsData.rawData) {
        console.error('No data available for histogram');
        return;
      }

      // Check if elements exist
      const numBinsEl = document.getElementById('numBins');
      const showNormalCurveEl = document.getElementById('showNormalCurve');
      const chartContainer = document.getElementById('histogram-chart');
      
      if (!numBinsEl || !showNormalCurveEl || !chartContainer) {
        console.error('Histogram elements not found in DOM');
        return;
      }

      // Use filtered data from range sliders
      const data = getFilteredData();
      if (data.length === 0) {
        console.error('No data after filtering');
        return;
      }

      const numBins = parseInt(numBinsEl.value);
      const showNormalCurve = showNormalCurveEl.checked;
      const totalCount = data.length;
      
      // Update remaining N display
      const remainingNEl = document.getElementById('remainingN');
      if (remainingNEl) remainingNEl.textContent = totalCount;
      
      // Calculate statistics for normal curve
      const mean = data.reduce((a, b) => a + b, 0) / data.length;
      const variance = data.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / (data.length - 1);
      const stdDev = Math.sqrt(variance);
      const min = Math.min(...data);
      const max = Math.max(...data);
      
      // Create bins with ranges as categories
      const binWidth = (max - min) / numBins;
      
      // Handle edge case where all data points are the same
      if (binWidth === 0 || !isFinite(binWidth)) {
        console.warn('Data range is zero or invalid');
        return;
      }
      
      const counts = [];
      const categories = [];
      const binCenters = [];
      
      for (let i = 0; i < numBins; i++) {
        const binStart = min + i * binWidth;
        const binEnd = min + (i + 1) * binWidth;
        const binCenter = (binStart + binEnd) / 2;
        
        // Format bin range for x-axis (remove extra decimals)
        const startStr = binStart.toFixed(1);
        const endStr = binEnd.toFixed(1);
        categories.push(`${startStr}-\n${endStr}`);
        binCenters.push(binCenter);
        counts.push(0);
      }
      
      // Count data points in each bin
      data.forEach(value => {
        let binIndex = Math.floor((value - min) / binWidth);
        // Handle edge case for maximum value
        if (binIndex >= numBins) binIndex = numBins - 1;
        if (binIndex < 0) binIndex = 0;
        counts[binIndex]++;
      });
      
      // Create series array with dataLabels showing percentages
      const series = [{
        name: 'Frequency',
        type: 'column',
        data: counts,
        color: '#74b9ff',
        borderColor: '#0984e3',
        borderWidth: 1,
        dataLabels: {
          enabled: true,
          formatter: function() {
            const percentage = ((this.y / totalCount) * 100).toFixed(1);
            return `${percentage}%`;
          },
          style: {
            color: '#3b82f6',
            fontSize: '11px',
            fontWeight: '700',
            textOutline: 'none'
          },
          y: -5
        }
      }];
      
      // Add normal curve if checked (yellow dashed line)
      if (showNormalCurve && stdDev > 0) {
        const normalCurveData = [];
        const totalArea = totalCount * binWidth; // Total area of histogram
        
        for (let i = 0; i < categories.length; i++) {
          const x = binCenters[i];
          // Normal distribution PDF
          const z = (x - mean) / stdDev;
          const pdf = (1 / (stdDev * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * z * z);
          const y = pdf * totalArea; // Scale to match histogram
          normalCurveData.push(y);
        }
        
        series.push({
          name: 'Normal Curve',
          type: 'line',
          data: normalCurveData,
          color: '#f1c40f',
          lineWidth: 3,
          dashStyle: 'Dash',
          marker: { enabled: false },
          enableMouseTracking: true
        });
      }
      
      // Create chart
      histogramChart = Highcharts.chart('histogram-chart', {
        chart: {
          backgroundColor: 'transparent',
          height: null, // Auto-size to container
          animation: animate,  // Only animate on load and binning method change
          reflow: true // Responsive resizing
        },
        title: { text: null },
        xAxis: {
          categories: categories,
          title: { 
            text: resultsData.column || 'Value',
            style: { color: '#475569', fontWeight: '600' }
          },
          labels: {
            style: {
              color: '#475569',
              fontSize: '10px'
            },
            rotation: -45,
            align: 'right'
          },
          gridLineWidth: 1,
          gridLineColor: '#e9ecef',
          lineColor: '#999'
        },
        yAxis: {
          title: { 
            text: 'Frequency',
            style: { color: '#475569', fontWeight: '600' }
          },
          gridLineColor: '#e9ecef',
          gridLineWidth: 1
        },
        legend: {
          enabled: false
        },
        tooltip: {
          enabled: false
        },
        plotOptions: {
          column: {
            pointPadding: 0,
            groupPadding: 0.1,
            borderWidth: 1,
            animation: animate  // Control animation for columns
          },
          line: {
            animation: animate  // Control animation for normal curve
          }
        },
        series: series,
        credits: { enabled: false }
      });
    }

    function updateHistogram() {
      const bins = document.getElementById('numBins').value;
      document.getElementById('binsValue').textContent = bins;
      createHistogram(false); // No animation for slider updates
    }

    function updateDecimals() {
      const select = document.getElementById('decimalsSelect');
      currentDecimals = parseInt(select.value);
      
      // Re-display the statistics with new decimal places
      if (resultsData && resultsData.descriptive) {
        const desc = resultsData.descriptive;
        const d = currentDecimals;
        
        // Update all statistics values in the tables
        const statsElements = {
          'mean': parseFloat(desc.mean).toFixed(d),
          'stdDev': parseFloat(desc.stdDev).toFixed(d),
          'variance': parseFloat(desc.variance).toFixed(d),
          'kurtosis': parseFloat(desc.kurtosis).toFixed(d),
          'skewness': parseFloat(desc.skewness).toFixed(d),
          'range': parseFloat(desc.range).toFixed(d),
          'min': parseFloat(desc.min).toFixed(d),
          'q1': parseFloat(desc.q1).toFixed(d),
          'median': parseFloat(desc.median).toFixed(d),
          'q3': parseFloat(desc.q3).toFixed(d),
          'max': parseFloat(desc.max).toFixed(d)
        };
        
        // Find and update each cell by matching the original value
        document.querySelectorAll('.stats-table td').forEach(cell => {
          const text = cell.textContent;
          // Try to match against our original values
          Object.keys(statsElements).forEach(key => {
            if (parseFloat(text) === parseFloat(desc[key])) {
              cell.textContent = statsElements[key];
            }
          });
        });
        
        // Update range slider labels
        if (originalDataMin !== undefined) {
          document.getElementById('leftRangeValue').textContent = parseFloat(document.getElementById('leftRangeValue').textContent).toFixed(d);
          document.getElementById('rightRangeValue').textContent = parseFloat(document.getElementById('rightRangeValue').textContent).toFixed(d);
          document.getElementById('data-min-value').textContent = `Min: ${originalDataMin.toFixed(d)}`;
          document.getElementById('data-max-value').textContent = `Max: ${originalDataMax.toFixed(d)}`;
        }
      }
    }

    // Binning method calculations
    function calculateBinsSturges(n) {
      return Math.max(1, Math.ceil(Math.log2(n) + 1));
    }

    function calculateBinsScott(data) {
      const n = data.length;
      if (n < 2) return 5;
      const mean = data.reduce((a, b) => a + b, 0) / n;
      const variance = data.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / (n - 1);
      const stdDev = Math.sqrt(variance);
      if (stdDev === 0) return 5;
      const h = 3.5 * stdDev / Math.pow(n, 1/3);
      const range = Math.max(...data) - Math.min(...data);
      return Math.max(1, Math.ceil(range / h));
    }

    function calculateBinsFD(data) {
      const n = data.length;
      if (n < 2) return 5;
      const sorted = [...data].sort((a, b) => a - b);
      const q1Index = Math.floor(n * 0.25);
      const q3Index = Math.floor(n * 0.75);
      const q1 = sorted[q1Index];
      const q3 = sorted[q3Index];
      const iqr = q3 - q1;
      if (iqr === 0) return calculateBinsSturges(n);
      const h = 2 * iqr / Math.pow(n, 1/3);
      const range = sorted[n - 1] - sorted[0];
      return Math.max(1, Math.ceil(range / h));
    }

    function calculateBinsSqrt(n) {
      return Math.max(1, Math.ceil(Math.sqrt(n)));
    }

    function calculateBinsRice(n) {
      return Math.max(1, Math.ceil(2 * Math.pow(n, 1/3)));
    }

    function updateBinningMethod() {
      const method = document.getElementById('binningMethod').value;
      const numBinsInput = document.getElementById('numBins');
      const binsValue = document.getElementById('binsValue');
      
      if (method === 'manual') {
        numBinsInput.disabled = false;
        createHistogram(true); // Animate when changing method
      } else {
        const data = getFilteredData();
        let calculatedBins = 5;
        
        switch(method) {
          case 'sturges':
            calculatedBins = calculateBinsSturges(data.length);
            break;
          case 'scott':
            calculatedBins = calculateBinsScott(data);
            break;
          case 'fd':
            calculatedBins = calculateBinsFD(data);
            break;
          case 'sqrt':
            calculatedBins = calculateBinsSqrt(data.length);
            break;
          case 'rice':
            calculatedBins = calculateBinsRice(data.length);
            break;
        }
        
        numBinsInput.value = calculatedBins;
        binsValue.textContent = calculatedBins;
        numBinsInput.disabled = true;
        createHistogram(true); // Animate when changing method
      }
    }

    // Get filtered data based on range sliders
    let originalDataMin, originalDataMax;
    let prevLeftPercent = 0;
    let prevRightPercent = 100;
    let updateTimeout = null;
    
    function getFilteredData() {
      if (!resultsData || !resultsData.rawData) return [];
      
      const leftPercent = parseFloat(document.getElementById('leftTruncation')?.value || 0);
      const rightPercent = parseFloat(document.getElementById('rightTruncation')?.value || 100);
      
      const leftValue = originalDataMin + (originalDataMax - originalDataMin) * (leftPercent / 100);
      const rightValue = originalDataMin + (originalDataMax - originalDataMin) * (rightPercent / 100);
      
      return resultsData.rawData.filter(d => d >= leftValue && d <= rightValue);
    }

    // ===== BOX PLOT VIEW =====
    function displayBoxPlotView() {
      const { descriptive, n, column, dataSource, rawData } = resultsData;
      
      if (!rawData || rawData.length === 0) {
        document.getElementById('resultsContent').innerHTML = `
          <div class="loading">
            <i class="fa-solid fa-exclamation-triangle" style="font-size: 40px; color: #dc2626; margin-bottom: 16px;"></i>
            <div style="color: #dc2626;">No data available for Box Plot</div>
          </div>
        `;
        return;
      }

      // Calculate box plot data
      const sortedData = [...rawData].sort((a, b) => a - b);
      const boxData = calculateBoxPlotData(sortedData);
      
      // Update header with variable info
      document.getElementById('variableName').textContent = column || 'Variable';
      document.getElementById('sampleSize').textContent = `(n=${n})`;
      
      // Render the box plot view
      const content = document.getElementById('resultsContent');
      content.innerHTML = `
        <div class="boxplot-container">
          <!-- Box Plot with Outliers -->
          <div class="boxplot-panel">
            <div class="panel-heading">Box Plot with Outliers</div>
            <div id="boxWithOutliers"></div>
          </div>
          
          <!-- Box Plot without Outliers -->
          <div class="boxplot-panel">
            <div class="panel-heading">Box Plot Without Outliers + Outlier Points</div>
            <div id="boxWithoutOutliers"></div>
          </div>
        </div>
      `;
      
      // Wait for DOM to render, then create charts
      setTimeout(() => {
        createBoxPlotCharts(boxData, column || 'Variable');
      }, 100);
    }

    function calculateBoxPlotData(sortedData) {
      const n = sortedData.length;
      const min = sortedData[0];
      const max = sortedData[n - 1];
      
      // Calculate quartiles
      const median = (sortedData[Math.floor((n - 1) / 2)] + sortedData[Math.ceil((n - 1) / 2)]) / 2;
      const q1 = (sortedData[Math.floor((n - 1) / 4)] + sortedData[Math.ceil((n - 1) / 4)]) / 2;
      const q3 = (sortedData[Math.floor((3 * (n - 1)) / 4)] + sortedData[Math.ceil((3 * (n - 1)) / 4)]) / 2;
      
      // Calculate IQR and fences
      const iqr = q3 - q1;
      const lowerFence = q1 - 1.5 * iqr;
      const upperFence = q3 + 1.5 * iqr;
      
      // Find outliers
      const outliers = sortedData.filter(v => v < lowerFence || v > upperFence);
      
      // Find adjusted bounds (min/max within fences)
      const adjustedLow = sortedData.find(v => v >= lowerFence);
      const adjustedHigh = [...sortedData].reverse().find(v => v <= upperFence);
      
      return {
        boxWithOutliers: [min, q1, median, q3, max],
        boxWithoutOutliers: [adjustedLow, q1, median, q3, adjustedHigh],
        outliers: outliers
      };
    }

    function buildStatLabelSeries(boxArray, labelColor) {
      // boxArray: [low, q1, median, q3, high]
      const labels = [
        { key: 'Min', y: boxArray[0], dx: 10 },
        { key: 'Q1', y: boxArray[1], dx: 10 },
        { key: 'Median', y: boxArray[2], dx: -10, align: 'right' },
        { key: 'Q3', y: boxArray[3], dx: 10 },
        { key: 'Max', y: boxArray[4], dx: 10 }
      ];
      
      return labels.map(l => ({
        x: 0,
        y: l.y,
        dataLabels: {
          enabled: true,
          formatter() { return `${l.key}: ${this.y.toFixed(1)}`; },
          style: { color: labelColor, fontSize: '10px', fontWeight: 600 },
          align: l.align || 'left',
          verticalAlign: 'middle',
          x: l.dx,
          y: 0,
          padding: 2,
          backgroundColor: 'rgba(0,0,0,0.3)',
          borderRadius: 3
        }
      }));
    }

    function createBoxPlotCharts(boxData, variableName) {
      const labelColor = document.body.classList.contains('theme-dark') ? '#ffa578' : '#f97316';
      const textColor = document.body.classList.contains('theme-dark') ? '#ffffff' : '#1e293b';
      const gridColor = document.body.classList.contains('theme-dark') ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
      
      // Build stat labels for both charts
      const statLabelsWithOutliers = buildStatLabelSeries(boxData.boxWithOutliers, labelColor);
      const statLabelsWithoutOutliers = buildStatLabelSeries(boxData.boxWithoutOutliers, labelColor);
      
      // Chart 1: With Outliers
      Highcharts.chart('boxWithOutliers', {
        chart: {
          type: 'boxplot',
          inverted: true,
          backgroundColor: 'transparent',
          height: null, // Auto-size
          marginTop: 40,
          marginBottom: 50,
          marginLeft: 80,
          marginRight: 20,
          reflow: true
        },
        title: {
          text: 'With Outliers',
          style: { color: textColor, fontSize: '13px' },
          margin: 15
        },
        xAxis: {
          categories: [variableName],
          labels: { style: { color: textColor, fontSize: '11px' } },
          gridLineColor: gridColor,
          title: {
            text: 'Distribution',
            style: { color: textColor, fontSize: '11px' }
          }
        },
        yAxis: {
          labels: { style: { color: textColor, fontSize: '11px' } },
          gridLineColor: gridColor,
          title: {
            text: 'Values',
            style: { color: textColor, fontSize: '11px' }
          }
        },
        legend: { enabled: false },
        tooltip: {
          backgroundColor: 'rgba(0, 0, 0, 0.8)',
          style: { color: '#ffffff' },
          formatter: function() {
            const point = this.point;
            return `<b>${variableName}</b><br/>` +
                   `Min: ${point.low}<br/>` +
                   `Q1: ${point.q1}<br/>` +
                   `Median: ${point.median}<br/>` +
                   `Q3: ${point.q3}<br/>` +
                   `Max: ${point.high}`;
          }
        },
        plotOptions: {
          boxplot: {
            dataLabels: { enabled: false },
            fillColor: 'rgba(255, 255, 255, 0.1)',
            lineWidth: 2,
            medianWidth: 3,
            stemWidth: 1,
            whiskerLength: '50%',
            whiskerWidth: 2
          }
        },
        series: [
          {
            name: 'Box Plot',
            data: [boxData.boxWithOutliers],
            color: '#e94560'
          },
          {
            name: 'Stats',
            type: 'scatter',
            data: statLabelsWithOutliers,
            marker: { enabled: false },
            enableMouseTracking: false,
            tooltip: { enabled: false },
            showInLegend: false
          }
        ]
      });
      
      // Chart 2: Without Outliers + Outlier Points
      Highcharts.chart('boxWithoutOutliers', {
        chart: {
          type: 'boxplot',
          inverted: true,
          backgroundColor: 'transparent',
          height: null, // Auto-size
          marginTop: 40,
          marginBottom: 50,
          marginLeft: 80,
          marginRight: 20,
          reflow: true
        },
        title: {
          text: 'Without Outliers + Outlier Points',
          style: { color: textColor, fontSize: '13px' },
          margin: 15
        },
        xAxis: {
          categories: [variableName],
          labels: { style: { color: textColor, fontSize: '11px' } },
          gridLineColor: gridColor,
          title: {
            text: 'Distribution',
            style: { color: textColor, fontSize: '11px' }
          }
        },
        yAxis: {
          labels: { style: { color: textColor, fontSize: '11px' } },
          gridLineColor: gridColor,
          title: {
            text: 'Values',
            style: { color: textColor, fontSize: '11px' }
          }
        },
        legend: {
          enabled: true,
          align: 'right',
          verticalAlign: 'top',
          layout: 'vertical',
          x: -10,
          y: 20,
          itemStyle: { color: textColor, fontSize: '10px' },
          itemMarginBottom: 2
        },
        tooltip: {
          backgroundColor: 'rgba(0, 0, 0, 0.8)',
          style: { color: '#ffffff' }
        },
        plotOptions: {
          boxplot: {
            dataLabels: { enabled: false },
            fillColor: 'rgba(255, 255, 255, 0.1)',
            lineWidth: 2,
            medianWidth: 3,
            stemWidth: 1,
            whiskerLength: '50%',
            whiskerWidth: 2
          },
          scatter: {
            marker: { radius: 3 }
          }
        },
        series: [
          {
            name: 'Box Plot',
            data: [boxData.boxWithoutOutliers],
            color: '#00bcd4',
            tooltip: {
              pointFormatter: function() {
                return `<b>${variableName}</b><br/>` +
                       `Min: ${this.low}<br/>` +
                       `Q1: ${this.q1}<br/>` +
                       `Median: ${this.median}<br/>` +
                       `Q3: ${this.q3}<br/>` +
                       `Max: ${this.high}`;
              }
            }
          },
          {
            name: `Outliers (${boxData.outliers.length})`,
            type: 'scatter',
            data: boxData.outliers.map(v => [0, v]),
            marker: { radius: 3 },
            color: '#ff6b6b',
            tooltip: {
              pointFormat: 'Outlier: <b>{point.y}</b>'
            }
          },
          {
            name: 'Stats',
            type: 'scatter',
            data: statLabelsWithoutOutliers,
            marker: { enabled: false },
            enableMouseTracking: false,
            tooltip: { enabled: false },
            showInLegend: false
          }
        ]
      });
    }

    // ===== Q-Q PLOT VIEW =====
    let currentPlotType = 'qq'; // 'qq' or 'pp'
    let currentDistribution = 'normal';

    function displayQQPlotView() {
      const { descriptive, n, column, dataSource, rawData } = resultsData;
      
      if (!rawData || rawData.length === 0) {
        document.getElementById('resultsContent').innerHTML = `
          <div class="loading">
            <i class="fa-solid fa-exclamation-triangle" style="font-size: 40px; color: #dc2626; margin-bottom: 16px;"></i>
            <div style="color: #dc2626;">No data available for Q-Q Plot</div>
          </div>
        `;
        return;
      }

      // Update header
      document.getElementById('variableName').textContent = column || 'Variable';
      document.getElementById('sampleSize').textContent = `(n=${n})`;
      
      // Render Q-Q Plot view
      const content = document.getElementById('resultsContent');
      content.innerHTML = `
        <!-- Plot Type Selector -->
        <div style="background: var(--surface-0); border: 1.5px solid var(--border); border-radius: 8px; padding: 16px; margin-bottom: 16px; text-align: center;">
          <label style="font-weight: 600; color: var(--text-secondary); margin-right: 20px;">Plot Type:</label>
          <label style="margin-right: 20px; cursor: pointer;">
            <input type="radio" name="plotType" value="qq" checked onchange="switchPlotType('qq')" style="margin-right: 6px;">
            <span style="color: var(--text-primary);">QQ</span>
          </label>
          <label style="cursor: pointer;">
            <input type="radio" name="plotType" value="pp" onchange="switchPlotType('pp')" style="margin-right: 6px;">
            <span style="color: var(--text-primary);">PP</span>
          </label>
        </div>

        <!-- Charts -->
        <div class="qqpp-container">
          <!-- Regular Plot -->
          <div class="qqpp-panel">
            <div class="panel-heading" id="plot1Title">QQ Plot (Normal)</div>
            <div id="plot1"></div>
          </div>
          
          <!-- Detrended Plot -->
          <div class="qqpp-panel">
            <div class="panel-heading" id="plot2Title">QQ Plot - Detrended (Normal)</div>
            <div id="plot2"></div>
          </div>
        </div>

        <!-- Distribution Selector -->
        <div style="background: var(--surface-0); border: 1.5px solid var(--border); border-radius: 8px; padding: 16px; margin-top: 16px;">
          <label style="font-weight: 600; color: var(--text-secondary); margin-right: 12px; display: inline-block; margin-bottom: 8px;">Distribution:</label>
          <div style="display: flex; flex-wrap: wrap; gap: 16px;">
            <label style="cursor: pointer;">
              <input type="radio" name="distribution" value="normal" checked onchange="switchDistribution('normal')" style="margin-right: 6px;">
              <span style="color: var(--text-primary);">Normal</span>
            </label>
            <label style="cursor: pointer;">
              <input type="radio" name="distribution" value="exponential" onchange="switchDistribution('exponential')" style="margin-right: 6px;">
              <span style="color: var(--text-primary);">Exponential</span>
            </label>
            <label style="cursor: pointer;">
              <input type="radio" name="distribution" value="uniform" onchange="switchDistribution('uniform')" style="margin-right: 6px;">
              <span style="color: var(--text-primary);">Uniform</span>
            </label>
            <label style="cursor: pointer;">
              <input type="radio" name="distribution" value="lognormal" onchange="switchDistribution('lognormal')" style="margin-right: 6px;">
              <span style="color: var(--text-primary);">LogNormal</span>
            </label>
            <label style="cursor: pointer;">
              <input type="radio" name="distribution" value="gamma" onchange="switchDistribution('gamma')" style="margin-right: 6px;">
              <span style="color: var(--text-primary);">Gamma</span>
            </label>
          </div>
        </div>
      `;
      
      setTimeout(() => {
        createQQPPPlots(rawData, column || 'Variable');
      }, 100);
    }

    function switchPlotType(type) {
      currentPlotType = type;
      const { rawData, column } = resultsData;
      createQQPPPlots(rawData, column || 'Variable');
    }

    function switchDistribution(dist) {
      currentDistribution = dist;
      const { rawData, column } = resultsData;
      createQQPPPlots(rawData, column || 'Variable');
    }

    function createQQPPPlots(data, variableName) {
      const sortedData = [...data].sort((a, b) => a - b);
      const n = sortedData.length;
      const mean = jStat.mean(data);
      const std = jStat.stdev(data, true);
      
      // Distribution name for display
      const distNames = {
        'normal': 'Normal',
        'exponential': 'Exponential',
        'uniform': 'Uniform',
        'lognormal': 'LogNormal',
        'gamma': 'Gamma'
      };
      const distName = distNames[currentDistribution] || 'Normal';
      
      // Update titles
      if (currentPlotType === 'qq') {
        document.getElementById('plot1Title').textContent = `QQ Plot (${distName})`;
        document.getElementById('plot2Title').textContent = `QQ Plot - Detrended (${distName})`;
      } else {
        document.getElementById('plot1Title').textContent = `PP Plot (${distName})`;
        document.getElementById('plot2Title').textContent = `PP Plot - Detrended (${distName})`;
      }
      
      let plotData, detrendedData;
      
      if (currentPlotType === 'qq') {
        // Q-Q Plot
        plotData = [];
        for (let i = 0; i < n; i++) {
          const p = (i + 0.5) / n;
          let theoretical;
          
          switch (currentDistribution) {
            case 'normal':
              theoretical = jStat.normal.inv(p, 0, 1);
              break;
            case 'exponential':
              theoretical = -Math.log(1 - p);
              break;
            case 'uniform':
              theoretical = p;
              break;
            case 'lognormal':
              theoretical = Math.exp(jStat.normal.inv(p, 0, 1));
              break;
            case 'gamma':
              theoretical = jStat.gamma.inv(p, 2, 1);
              break;
            default:
              theoretical = jStat.normal.inv(p, 0, 1);
          }
          
          plotData.push([theoretical, sortedData[i]]);
        }
        
        // Detrended: deviation from expected linear relationship
        const minX = Math.min(...plotData.map(p => p[0]));
        const maxX = Math.max(...plotData.map(p => p[0]));
        const minY = Math.min(...plotData.map(p => p[1]));
        const maxY = Math.max(...plotData.map(p => p[1]));
        const rangeX = maxX - minX || 1;
        const rangeY = maxY - minY;
        
        detrendedData = plotData.map(p => {
          const x = p[0];
          const y = p[1];
          const expectedY = minY + ((x - minX) / rangeX) * rangeY;
          return [y, y - expectedY];
        });
        
      } else {
        // P-P Plot
        plotData = [];
        for (let i = 0; i < n; i++) {
          const empiricalP = (i + 1) / n;
          let theoreticalP;
          
          switch (currentDistribution) {
            case 'normal':
              theoreticalP = jStat.normal.cdf(sortedData[i], mean, std);
              break;
            case 'exponential':
              const lambda = 1 / mean;
              theoreticalP = 1 - Math.exp(-lambda * sortedData[i]);
              break;
            case 'uniform':
              const min = Math.min(...data);
              const max = Math.max(...data);
              theoreticalP = (sortedData[i] - min) / (max - min);
              break;
            case 'lognormal':
              if (sortedData[i] > 0) {
                const logMean = Math.log(mean * mean / Math.sqrt(std * std + mean * mean));
                const logStd = Math.sqrt(Math.log(1 + (std * std) / (mean * mean)));
                theoreticalP = jStat.normal.cdf(Math.log(sortedData[i]), logMean, logStd);
              } else {
                theoreticalP = 0;
              }
              break;
            case 'gamma':
              theoreticalP = jStat.gamma.cdf(sortedData[i], 2, mean / 2);
              break;
            default:
              theoreticalP = jStat.normal.cdf(sortedData[i], mean, std);
          }
          
          plotData.push([empiricalP, theoreticalP]);
        }
        
        // Detrended: deviation from diagonal
        detrendedData = plotData.map(p => [p[0], p[1] - p[0]]);
      }
      
      const textColor = document.body.classList.contains('theme-dark') ? '#ffffff' : '#1e293b';
      const gridColor = document.body.classList.contains('theme-dark') ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
      
      // Chart 1: Regular plot
      const xLabel = currentPlotType === 'qq' ? 'Theoretical Quantiles' : 'Empirical Cumulative Probability';
      const yLabel = currentPlotType === 'qq' ? 'Sample Quantiles' : 'Theoretical Cumulative Probability';
      
      Highcharts.chart('plot1', {
        chart: {
          type: 'scatter',
          backgroundColor: 'transparent',
          height: null,
          reflow: true
        },
        title: null,
        xAxis: {
          title: { text: xLabel, style: { color: textColor } },
          labels: { style: { color: textColor } },
          gridLineColor: gridColor,
          ...(currentPlotType === 'pp' && { min: 0, max: 1 })
        },
        yAxis: {
          title: { text: yLabel, style: { color: textColor } },
          labels: { style: { color: textColor } },
          gridLineColor: gridColor,
          ...(currentPlotType === 'pp' && { min: 0, max: 1 })
        },
        legend: { enabled: false },
        tooltip: {
          backgroundColor: 'rgba(0, 0, 0, 0.8)',
          style: { color: '#ffffff' },
          pointFormat: currentPlotType === 'qq' 
            ? 'Theoretical: <b>{point.x:.2f}</b><br/>Sample: <b>{point.y:.2f}</b>'
            : 'Empirical: <b>{point.x:.3f}</b><br/>Theoretical: <b>{point.y:.3f}</b>'
        },
        plotOptions: {
          scatter: { marker: { radius: 3, symbol: 'circle' } },
          line: { marker: { enabled: false }, enableMouseTracking: false }
        },
        series: [
          {
            name: currentPlotType === 'qq' ? 'Q-Q Plot' : 'P-P Plot',
            data: plotData,
            color: '#3b82f6',
            marker: { radius: 3 }
          },
          {
            name: 'Reference Line',
            type: 'line',
            data: currentPlotType === 'qq' 
              ? [[Math.min(...plotData.map(p => p[0])), Math.min(...plotData.map(p => p[1]))],
                 [Math.max(...plotData.map(p => p[0])), Math.max(...plotData.map(p => p[1]))]]
              : [[0, 0], [1, 1]],
            color: '#f97316',
            dashStyle: 'Dash',
            lineWidth: 2,
            showInLegend: false
          }
        ]
      });
      
      // Chart 2: Detrended plot
      Highcharts.chart('plot2', {
        chart: {
          type: 'scatter',
          backgroundColor: 'transparent',
          height: null,
          reflow: true
        },
        title: null,
        xAxis: {
          title: { text: currentPlotType === 'qq' ? 'Observed Value' : 'Empirical Probability', style: { color: textColor } },
          labels: { style: { color: textColor } },
          gridLineColor: gridColor
        },
        yAxis: {
          title: { text: 'Deviation from Expected', style: { color: textColor } },
          labels: { style: { color: textColor } },
          gridLineColor: gridColor,
          plotLines: [{
            value: 0,
            color: '#f97316',
            dashStyle: 'Dash',
            width: 2
          }]
        },
        legend: { enabled: false },
        tooltip: {
          backgroundColor: 'rgba(0, 0, 0, 0.8)',
          style: { color: '#ffffff' },
          pointFormat: 'Value: <b>{point.x:.2f}</b><br/>Deviation: <b>{point.y:.2f}</b>'
        },
        plotOptions: {
          scatter: { marker: { radius: 3, symbol: 'circle' } }
        },
        series: [
          {
            name: 'Detrended',
            data: detrendedData,
            color: '#f97316',
            marker: { radius: 3 }
          }
        ]
      });
    }

    // ===== NORMALITY TESTS VIEW =====
    function displayNormalityView() {
      const { descriptive, n, column, dataSource, rawData } = resultsData;
      
      if (!rawData || rawData.length === 0) {
        document.getElementById('resultsContent').innerHTML = `
          <div class="loading">
            <i class="fa-solid fa-exclamation-triangle" style="font-size: 40px; color: #dc2626; margin-bottom: 16px;"></i>
            <div style="color: #dc2626;">No data available for Normality Tests</div>
          </div>
        `;
        return;
      }

      // Update header
      document.getElementById('variableName').textContent = column || 'Variable';
      document.getElementById('sampleSize').textContent = `(n=${n})`;
      
      // Calculate normality tests
      const tests = calculateNormalityTests(rawData);
      const normalityScore = calculateNormalityScore(tests);
      
      // Render view
      const content = document.getElementById('resultsContent');
      content.innerHTML = `
        <div class="normality-container">
          <!-- Summary Row -->
          <div class="normality-summary">
            <div class="normality-gauge">
              <div class="panel-heading" style="margin-bottom: 12px;">Normality Score</div>
              <div id="normalityGauge"></div>
            </div>
            <div class="normality-stats">
              <div class="stat-box">
                <div class="stat-box-value">${descriptive.mean}</div>
                <div class="stat-box-label">Mean</div>
              </div>
              <div class="stat-box">
                <div class="stat-box-value">${descriptive.stdDev}</div>
                <div class="stat-box-label">Std Dev</div>
              </div>
              <div class="stat-box">
                <div class="stat-box-value">${descriptive.skewness}</div>
                <div class="stat-box-label">Skewness</div>
              </div>
              <div class="stat-box">
                <div class="stat-box-value">${descriptive.kurtosis}</div>
                <div class="stat-box-label">Kurtosis</div>
              </div>
            </div>
          </div>
          
          <!-- Tests Grid -->
          <div class="tests-grid">
            ${tests.map(test => `
              <div class="test-card">
                <div class="test-header">
                  <div class="test-name">${test.name}</div>
                  <div class="test-badge ${test.pass ? 'pass' : 'fail'}">${test.pass ? 'PASS' : 'FAIL'}</div>
                </div>
                <div class="test-details">
                  <div class="test-detail-row">
                    <span class="test-detail-label">Statistic:</span>
                    <span class="test-detail-value">${test.statistic.toFixed(4)}</span>
                  </div>
                  <div class="test-detail-row">
                    <span class="test-detail-label">p-value:</span>
                    <span class="test-detail-value">${test.pValue !== null ? test.pValue.toFixed(4) : 'N/A'}</span>
                  </div>
                  <div class="test-detail-row">
                    <span class="test-detail-label">Alpha:</span>
                    <span class="test-detail-value">0.05</span>
                  </div>
                </div>
              </div>
            `).join('')}
          </div>
        </div>
      `;
      
      setTimeout(() => {
        createNormalityGauge(normalityScore);
      }, 100);
    }

    function calculateNormalityTests(data) {
      const n = data.length;
      const mean = jStat.mean(data);
      const std = jStat.stdev(data, true);
      const alpha = 0.05;
      
      const tests = [];
      
      // Shapiro-Wilk approximation
      const shapiroW = calculateShapiroWilk(data);
      tests.push({
        name: 'Shapiro-Wilk',
        statistic: shapiroW.statistic,
        pValue: shapiroW.pValue,
        pass: shapiroW.pValue > alpha
      });
      
      // Jarque-Bera test
      const jb = calculateJarqueBera(data);
      tests.push({
        name: 'Jarque-Bera',
        statistic: jb.statistic,
        pValue: jb.pValue,
        pass: jb.pValue > alpha
      });
      
      // Kolmogorov-Smirnov test
      const ks = calculateKSTest(data);
      tests.push({
        name: 'Kolmogorov-Smirnov',
        statistic: ks.statistic,
        pValue: ks.pValue,
        pass: ks.pValue > alpha
      });
      
      // Anderson-Darling approximation
      const ad = calculateAndersonDarling(data);
      tests.push({
        name: 'Anderson-Darling',
        statistic: ad.statistic,
        pValue: ad.pValue,
        pass: ad.pValue > alpha
      });
      
      return tests;
    }

    function calculateShapiroWilk(data) {
      // Simplified Shapiro-Wilk approximation
      const n = data.length;
      const sorted = [...data].sort((a, b) => a - b);
      const mean = jStat.mean(data);
      
      // Calculate W statistic (simplified)
      let numerator = 0;
      let denominator = 0;
      
      for (let i = 0; i < n; i++) {
        const weight = jStat.normal.inv((i + 0.5) / n, 0, 1);
        numerator += weight * sorted[i];
        denominator += Math.pow(sorted[i] - mean, 2);
      }
      
      const W = Math.pow(numerator, 2) / denominator;
      const pValue = W > 0.9 ? 0.5 : 0.01; // Simplified p-value
      
      return { statistic: W, pValue: pValue };
    }

    function calculateJarqueBera(data) {
      const n = data.length;
      const skewness = jStat.skewness(data);
      const kurtosis = jStat.kurtosis(data);
      
      const JB = (n / 6) * (Math.pow(skewness, 2) + Math.pow(kurtosis - 3, 2) / 4);
      const pValue = 1 - jStat.chisquare.cdf(JB, 2);
      
      return { statistic: JB, pValue: pValue };
    }

    function calculateKSTest(data) {
      const n = data.length;
      const sorted = [...data].sort((a, b) => a - b);
      const mean = jStat.mean(data);
      const std = jStat.stdev(data, true);
      
      let maxD = 0;
      for (let i = 0; i < n; i++) {
        const empiricalCDF = (i + 1) / n;
        const theoreticalCDF = jStat.normal.cdf(sorted[i], mean, std);
        const D = Math.abs(empiricalCDF - theoreticalCDF);
        if (D > maxD) maxD = D;
      }
      
      const KS = maxD * Math.sqrt(n);
      const pValue = Math.exp(-2 * Math.pow(KS, 2));
      
      return { statistic: maxD, pValue: pValue };
    }

    function calculateAndersonDarling(data) {
      const n = data.length;
      const sorted = [...data].sort((a, b) => a - b);
      const mean = jStat.mean(data);
      const std = jStat.stdev(data, true);
      
      let sum = 0;
      for (let i = 0; i < n; i++) {
        const zi = (sorted[i] - mean) / std;
        const Fi = jStat.normal.cdf(zi, 0, 1);
        sum += (2 * (i + 1) - 1) * (Math.log(Fi) + Math.log(1 - jStat.normal.cdf(sorted[n - 1 - i], mean, std)));
      }
      
      const A2 = -n - sum / n;
      const pValue = A2 < 0.5 ? 0.5 : 0.01; // Simplified p-value
      
      return { statistic: A2, pValue: pValue };
    }

    function calculateNormalityScore(tests) {
      const weights = {
        'Shapiro-Wilk': 1.0,
        'Jarque-Bera': 0.9,
        'Kolmogorov-Smirnov': 0.8,
        'Anderson-Darling': 0.9
      };
      
      let totalWeight = 0;
      let weightedScore = 0;
      
      tests.forEach(test => {
        const p = test.pValue;
        const w = weights[test.name] || 1.0;
        let score = 0;
        
        if (p < 0.001) score = 0;
        else if (p < 0.05) score = 20 + (20 * (Math.log10(p) - Math.log10(0.001)) / (Math.log10(0.05) - Math.log10(0.001)));
        else if (p < 0.5) score = 40 + (40 * (Math.log10(p) - Math.log10(0.05)) / (Math.log10(0.5) - Math.log10(0.05)));
        else score = 80 + (20 * (p - 0.5) / 0.5);
        
        weightedScore += score * w;
        totalWeight += w;
      });
      
      return Math.round(weightedScore / totalWeight);
    }

    function createNormalityGauge(score) {
      const isDark = document.body.classList.contains('theme-dark');
      const textColor = isDark ? '#ffffff' : '#1e293b';
      
      Highcharts.chart('normalityGauge', {
        chart: {
          type: 'solidgauge',
          backgroundColor: 'transparent',
          height: 180
        },
        title: null,
        pane: {
          center: ['50%', '70%'],
          size: '140%',
          startAngle: -90,
          endAngle: 90,
          background: {
            backgroundColor: isDark ? '#242938' : '#f1f3f5',
            innerRadius: '60%',
            outerRadius: '100%',
            shape: 'arc'
          }
        },
        yAxis: {
          min: 0,
          max: 100,
          stops: [
            [0.1, '#e74c3c'],
            [0.5, '#f39c12'],
            [0.9, '#2ecc71']
          ],
          lineWidth: 0,
          tickWidth: 0,
          minorTickInterval: null,
          tickAmount: 2,
          labels: { y: 16, style: { color: textColor } }
        },
        plotOptions: {
          solidgauge: {
            dataLabels: {
              y: -30,
              borderWidth: 0,
              useHTML: true,
              format: '<div style="text-align:center"><span style="font-size:32px;font-weight:bold;color:' + textColor + '">{y}</span><br/><span style="font-size:12px;color:' + textColor + ';opacity:0.7">Score</span></div>'
            }
          }
        },
        credits: { enabled: false },
        series: [{
          name: 'Normality',
          data: [score]
        }]
      });
    }

    // ===== KERNEL DENSITY VIEW =====
    function displayKernelView() {
      const { descriptive, n, column, dataSource, rawData } = resultsData;
      
      if (!rawData || rawData.length === 0) {
        document.getElementById('resultsContent').innerHTML = `
          <div class="loading">
            <i class="fa-solid fa-exclamation-triangle" style="font-size: 40px; color: #dc2626; margin-bottom: 16px;"></i>
            <div style="color: #dc2626;">No data available for Kernel Density</div>
          </div>
        `;
        return;
      }

      // Update header
      document.getElementById('variableName').textContent = column || 'Variable';
      document.getElementById('sampleSize').textContent = `(n=${n})`;
      
      // Render view
      const content = document.getElementById('resultsContent');
      content.innerHTML = `
        <div class="kernel-container">
          <!-- Controls -->
          <div class="kernel-controls">
            <div class="kernel-control-group">
              <label class="kernel-control-label">Bandwidth Multiplier</label>
              <input type="range" id="bandwidthSlider" class="kernel-slider" min="0.1" max="3" step="0.1" value="1.0">
              <div class="kernel-value-display" id="bandwidthValue">1.0x (Scott's Rule)</div>
            </div>
            <div class="kernel-control-group">
              <label class="kernel-control-label">Kernel Type</label>
              <select id="kernelType" style="width: 100%; padding: 8px; border-radius: 6px; background: var(--surface-1); color: var(--text-primary); border: 1px solid var(--border);">
                <option value="gaussian">Gaussian</option>
                <option value="epanechnikov">Epanechnikov</option>
                <option value="triangular">Triangular</option>
                <option value="uniform">Uniform</option>
              </select>
            </div>
          </div>
          
          <!-- Chart -->
          <div id="kernelChart"></div>
        </div>
      `;
      
      setTimeout(() => {
        initializeKernelDensity(rawData, column || 'Variable');
      }, 100);
    }

    let kernelChart = null;
    let kernelData = null;

    function initializeKernelDensity(data, variableName) {
      kernelData = data;
      
      // Event listeners
      document.getElementById('bandwidthSlider').addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        document.getElementById('bandwidthValue').textContent = `${value.toFixed(1)}x (Scott's Rule)`;
        updateKernelChart();
      });
      
      document.getElementById('kernelType').addEventListener('change', () => {
        updateKernelChart();
      });
      
      // Initial render
      updateKernelChart();
    }

    function updateKernelChart() {
      if (!kernelData) return;
      
      const bandwidthMultiplier = parseFloat(document.getElementById('bandwidthSlider').value);
      const kernelType = document.getElementById('kernelType').value;
      
      const { kde, bandwidth } = calculateKDE(kernelData, bandwidthMultiplier, kernelType);
      
      const textColor = document.body.classList.contains('theme-dark') ? '#ffffff' : '#1e293b';
      const gridColor = document.body.classList.contains('theme-dark') ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
      
      if (kernelChart) {
        kernelChart.destroy();
      }
      
      kernelChart = Highcharts.chart('kernelChart', {
        chart: {
          backgroundColor: 'transparent',
          height: null,
          reflow: true
        },
        title: {
          text: 'Kernel Density Estimation',
          style: { color: textColor }
        },
        xAxis: {
          title: { text: 'Value', style: { color: textColor } },
          labels: { style: { color: textColor } },
          gridLineColor: gridColor
        },
        yAxis: {
          title: { text: 'Density', style: { color: textColor } },
          labels: { style: { color: textColor } },
          gridLineColor: gridColor
        },
        legend: { enabled: true, itemStyle: { color: textColor } },
        tooltip: {
          backgroundColor: 'rgba(0, 0, 0, 0.8)',
          style: { color: '#ffffff' },
          shared: true
        },
        plotOptions: {
          area: {
            fillOpacity: 0.3
          }
        },
        series: [
          {
            name: 'Kernel Density',
            type: 'area',
            data: kde,
            color: '#3b82f6',
            lineWidth: 2
          }
        ]
      });
    }

    function calculateKDE(data, bandwidthMultiplier, kernelType) {
      const n = data.length;
      const mean = jStat.mean(data);
      const std = jStat.stdev(data, true);
      
      // Scott's rule for bandwidth
      const scottsH = 1.06 * std * Math.pow(n, -0.2);
      const bandwidth = scottsH * bandwidthMultiplier;
      
      // Kernel functions
      const kernels = {
        gaussian: (u) => Math.exp(-0.5 * u * u) / Math.sqrt(2 * Math.PI),
        epanechnikov: (u) => Math.abs(u) <= 1 ? 0.75 * (1 - u * u) : 0,
        triangular: (u) => Math.abs(u) <= 1 ? (1 - Math.abs(u)) : 0,
        uniform: (u) => Math.abs(u) <= 1 ? 0.5 : 0
      };
      
      const kernelFunc = kernels[kernelType];
      
      // Create evaluation points
      const min = Math.min(...data);
      const max = Math.max(...data);
      const range = max - min;
      const start = min - range * 0.1;
      const end = max + range * 0.1;
      const points = 200;
      const step = (end - start) / (points - 1);
      
      const kde = [];
      for (let i = 0; i < points; i++) {
        const x = start + i * step;
        let density = 0;
        
        for (let j = 0; j < n; j++) {
          const u = (x - data[j]) / bandwidth;
          density += kernelFunc(u);
        }
        
        density = density / (n * bandwidth);
        kde.push([x, density]);
      }
      
      return { kde, bandwidth };
    }

    function showView(viewName) {
      // View names mapping
      const viewTitles = {
        'histogram': 'Interactive Histogram',
        'boxplot': 'Box Plot Analysis',
        'qqplot': 'Q-Q Plot Analysis',
        'normality': 'Normality Tests',
        'kernel': 'Kernel Density Estimation'
      };
      
      // Update view name in header
      document.getElementById('viewName').textContent = viewTitles[viewName] || 'Analysis';
      
      // Update active state
      document.querySelectorAll('.analysis-option').forEach(opt => opt.classList.remove('active'));
      event.target.closest('.analysis-option').classList.add('active');
      
      // Close dropdown
      document.getElementById('dropdownMenu').classList.remove('show');
      
      // Show view
      if (viewName === 'histogram') {
        displayHistogramView();
      } else if (viewName === 'boxplot') {
        displayBoxPlotView();
      } else if (viewName === 'qqplot') {
        displayQQPlotView();
      } else if (viewName === 'normality') {
        displayNormalityView();
      } else if (viewName === 'kernel') {
        displayKernelView();
      } else {
        document.getElementById('resultsContent').innerHTML = `
          <div style="text-align: center; padding: 60px 20px; color: var(--text-muted);">
            <i class="fa-solid fa-info-circle" style="font-size: 48px; margin-bottom: 16px;"></i>
            <div>${viewTitles[viewName]} coming soon!</div>
          </div>
        `;
      }
    }

    function toggleDropdown() {
      document.getElementById('dropdownMenu').classList.toggle('show');
    }

    // Initialize range sliders
    function initializeRangeSliders() {
      if (!resultsData || !resultsData.rawData) return;
      
      originalDataMin = Math.min(...resultsData.rawData);
      originalDataMax = Math.max(...resultsData.rawData);
      
      // Update display labels with current decimal places
      document.getElementById('data-min-value').textContent = `Min: ${originalDataMin.toFixed(currentDecimals)}`;
      document.getElementById('data-max-value').textContent = `Max: ${originalDataMax.toFixed(currentDecimals)}`;
      document.getElementById('leftRangeValue').textContent = originalDataMin.toFixed(currentDecimals);
      document.getElementById('rightRangeValue').textContent = originalDataMax.toFixed(currentDecimals);
      document.getElementById('remainingN').textContent = resultsData.rawData.length;
      
      // Setup slider event listeners
      const leftSlider = document.getElementById('leftTruncation');
      const rightSlider = document.getElementById('rightTruncation');
      
      // Left slider event handlers (VB6 mechanism)
      if (leftSlider) {
        // Bring left slider to front while dragging; temporarily disable right slider hit-testing
        const bringLeftFront = () => {
          if (leftSlider) leftSlider.style.zIndex = '3';
          if (rightSlider) rightSlider.style.zIndex = '2';
          if (rightSlider) rightSlider.style.pointerEvents = 'none';
        };
        const releaseLeftFront = () => {
          if (rightSlider) rightSlider.style.pointerEvents = '';
          if (leftSlider) leftSlider.style.zIndex = '';
          if (rightSlider) rightSlider.style.zIndex = '';
        };
        
        leftSlider.addEventListener('mousedown', bringLeftFront);
        leftSlider.addEventListener('touchstart', bringLeftFront, { passive: true });
        window.addEventListener('mouseup', releaseLeftFront);
        window.addEventListener('touchend', releaseLeftFront, { passive: true });
        
        leftSlider.addEventListener('input', function() {
          const leftPercent = +this.value;
          const rightPercent = rightSlider ? +rightSlider.value : 100;
          
          if (leftPercent >= rightPercent - 1 && rightSlider) {
            rightSlider.value = Math.min(100, leftPercent + 1);
          }
          
          updateRangeSliders();
        });
      }
      
      // Right slider event handlers (VB6 mechanism)
      if (rightSlider) {
        // Bring right slider to front while dragging; temporarily disable left slider hit-testing
        const bringRightFront = () => {
          if (rightSlider) rightSlider.style.zIndex = '3';
          if (leftSlider) leftSlider.style.zIndex = '2';
          if (leftSlider) leftSlider.style.pointerEvents = 'none';
        };
        const releaseRightFront = () => {
          if (leftSlider) leftSlider.style.pointerEvents = '';
          if (rightSlider) rightSlider.style.zIndex = '';
          if (leftSlider) leftSlider.style.zIndex = '';
        };
        
        rightSlider.addEventListener('mousedown', bringRightFront);
        rightSlider.addEventListener('touchstart', bringRightFront, { passive: true });
        window.addEventListener('mouseup', releaseRightFront);
        window.addEventListener('touchend', releaseRightFront, { passive: true });
        
        rightSlider.addEventListener('input', function() {
          const rightPercent = +this.value;
          const leftPercent = leftSlider ? +leftSlider.value : 0;
          
          if (rightPercent <= leftPercent + 1 && leftSlider) {
            leftSlider.value = Math.max(0, rightPercent - 1);
          }
          
          updateRangeSliders();
        });
      }
    }

    // Update range sliders and filter data
    function updateRangeSliders() {
      const leftPercent = parseFloat(document.getElementById('leftTruncation').value);
      const rightPercent = parseFloat(document.getElementById('rightTruncation').value);
      
      // Prevent sliders from crossing
      if (leftPercent >= rightPercent - 1) {
        document.getElementById('rightTruncation').value = Math.min(100, leftPercent + 1);
        return;
      }
      if (rightPercent <= leftPercent + 1) {
        document.getElementById('leftTruncation').value = Math.max(0, rightPercent - 1);
        return;
      }
      
      // Calculate actual values
      const leftValue = originalDataMin + (originalDataMax - originalDataMin) * (leftPercent / 100);
      const rightValue = originalDataMin + (originalDataMax - originalDataMin) * (rightPercent / 100);
      
      // Check filtered data count BEFORE updating (use 5% of total or minimum 5)
      const filteredData = resultsData.rawData.filter(d => d >= leftValue && d <= rightValue);
      const minRequired = Math.max(5, Math.ceil(resultsData.rawData.length * 0.05));
      
      if (filteredData.length < minRequired) {
        // Revert to previous valid positions
        document.getElementById('leftTruncation').value = prevLeftPercent;
        document.getElementById('rightTruncation').value = prevRightPercent;
        
        // Show warning in UI (not alert - not supported in Office dialogs)
        const remainingNEl = document.getElementById('remainingN');
        if (remainingNEl) {
          remainingNEl.textContent = `min ${minRequired}`;
          remainingNEl.style.color = '#dc2626';
          setTimeout(() => {
            remainingNEl.style.color = '';
            remainingNEl.textContent = filteredData.length;
          }, 1500);
        }
        return;
      }
      
      // Update previous positions (valid state)
      prevLeftPercent = leftPercent;
      prevRightPercent = rightPercent;
      
      // Update display with current decimal places
      document.getElementById('leftRangeValue').textContent = leftValue.toFixed(currentDecimals);
      document.getElementById('rightRangeValue').textContent = rightValue.toFixed(currentDecimals);
      document.getElementById('remainingN').textContent = filteredData.length;
      
      // Update active range indicator
      const activeRange = document.getElementById('activeRangeIndicator');
      if (activeRange) {
        activeRange.style.left = leftPercent + '%';
        activeRange.style.width = (rightPercent - leftPercent) + '%';
      }
      
      // Re-create histogram with filtered data (no animation for smooth slider updates)
      createHistogram(false);
    }

    // Reset range sliders
    function resetRangeSliders() {
      document.getElementById('leftTruncation').value = 0;
      document.getElementById('rightTruncation').value = 100;
      prevLeftPercent = 0;
      prevRightPercent = 100;
      
      document.getElementById('leftRangeValue').textContent = originalDataMin.toFixed(currentDecimals);
      document.getElementById('rightRangeValue').textContent = originalDataMax.toFixed(currentDecimals);
      
      const activeRange = document.getElementById('activeRangeIndicator');
      if (activeRange) {
        activeRange.style.left = '0%';
        activeRange.style.width = '100%';
      }
      
      document.getElementById('remainingN').textContent = resultsData.rawData.length;
      createHistogram(false); // No animation for reset
    }

    function closeDialog() {
      try {
        // Try to close using Office.js dialog API
        if (typeof Office !== 'undefined' && Office.context && Office.context.ui) {
          // Message parent to close this dialog
          Office.context.ui.messageParent(JSON.stringify({ action: 'closeDialog' }));
        }
        // Also try window.close() as fallback
        window.close();
      } catch (e) {
        console.error('Error closing dialog:', e);
        // Force close as last resort
        try {
          window.close();
        } catch (e2) {
          console.error('Could not close window:', e2);
        }
      }
    }

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      const dropdown = document.getElementById('dropdownMenu');
      if (dropdown && !e.target.closest('.dropdown-btn') && !e.target.closest('.dropdown-content')) {
        dropdown.classList.remove('show');
      }
    });
  </script>

  <!-- Floating Close Button -->
  <button class="close-btn-floating" onclick="closeDialog()" title="Close Dialog">
    <i class="fa-solid fa-times"></i>
  </button>
</body>
</html>
