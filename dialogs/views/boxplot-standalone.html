<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Box Plot Analysis</title>
  
  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" rel="stylesheet">
  
  <!-- Highcharts -->
  <script src="https://code.highcharts.com/highcharts.js"></script>
  <script src="https://code.highcharts.com/highcharts-more.js"></script>
  <script src="https://code.highcharts.com/modules/exporting.js"></script>
  <script src="https://code.highcharts.com/modules/export-data.js"></script>
  <script src="https://code.highcharts.com/modules/annotations.js"></script>
  
  <!-- Shared Components -->
  <link rel="stylesheet" href="shared-header.css">
  <script src="shared-header.js"></script>
  
  <!-- Responsive Layout System -->
  <link rel="stylesheet" href="responsive-layout.css">
  <script src="responsive-layout.js"></script>

  <style>
    :root {
      --surface-0: #0c1624;
      --surface-1: #1a1f2e;
      --surface-2: #242938;
      --border: #2d3748;
      --accent-1: rgb(255,165,120);
      --accent-2: rgb(120,200,255);
      --text-primary: #ffffff;
      --text-secondary: rgba(255,255,255,0.8);
      --text-muted: rgba(255,255,255,0.6);
    }

    body {
      background-color: var(--surface-0);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      color: var(--text-primary);
      overflow: hidden;
    }

    /* Override responsive layout padding */
    .responsive-container {
      padding: 6px 12px !important;
      gap: 4px;
    }

    .responsive-panel {
      padding: 0 !important;
      margin-bottom: 0 !important;
    }

    .responsive-panel-body {
      padding: 0 !important;
    }

    /* Results Container */
    .results-container {
      display: none;
      flex-direction: column;
      gap: 8px;
      padding: 0;
      flex: 1;
      height: 100%;
    }
    
    .results-container.show {
      display: flex !important;
    }

    /* Panel Styling */
    .chart-panel {
      background: var(--surface-1);
      border-radius: 8px;
      border: 1px solid var(--border);
      box-shadow: 0px 4px 20px rgba(0, 0, 0, 0.4);
      overflow: hidden;
      flex: 1;
      padding: 0 !important;
      margin: 0;
      display: flex;
      flex-direction: column;
    }

    /* Chart Container - Spread to Fill */
    .chart-container {
      width: 100%;
      flex: 1;
      min-height: 220px;
      background: transparent;
    }

    /* Loading State */
    .awaiting-overlay {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 60px 20px;
      color: var(--text-secondary);
    }

    #awaitingPanel {
      margin: 0 !important;
    }

    .awaiting-overlay i {
      font-size: 64px;
      margin-bottom: 24px;
      color: var(--accent-2);
      animation: pulse 2s ease-in-out infinite;
    }

    .awaiting-overlay h3 {
      font-size: 1.5em;
      margin: 0 0 12px 0;
      color: var(--text-primary);
    }

    .awaiting-overlay p {
      margin: 0;
      font-size: 1em;
      color: var(--text-muted);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Responsive breakpoints */
    @media (max-height: 800px) {
      .chart-container {
        min-height: 200px;
      }
    }

    @media (max-height: 700px) {
      .chart-container {
        min-height: 180px;
      }
    }

    @media (max-height: 600px) {
      .chart-container {
        min-height: 160px;
      }
    }
  </style>
</head>
<body>
  <statistico-header view-name="Box Plot Analysis" module-name="Univariate Analysis"></statistico-header>
  
  <!-- Responsive Container -->
  <div class="responsive-container">
    
    <!-- Awaiting State -->
    <div class="responsive-panel" id="awaitingPanel">
      <div class="awaiting-overlay">
        <i class="fa-solid fa-chart-simple"></i>
        <h3>Box Plot Analysis</h3>
        <p>Awaiting data from Excel...</p>
      </div>
    </div>

    <!-- Results Container -->
    <div class="results-container" id="results-container">
      
      <!-- Box Plot With Outliers -->
      <div class="chart-panel">
        <div class="chart-container" id="withOutliers"></div>
      </div>

      <!-- Box Plot Without Outliers -->
      <div class="chart-panel">
        <div class="chart-container" id="withoutOutliers"></div>
      </div>
      
    </div>
    
  </div>

  <script>
    let originalData = [];
    let currentVariableName = 'Variable';
    let currentSampleSize = 0;

    // Initialize Office.js
    if (typeof Office !== 'undefined') {
      Office.initialize = function() {
        console.log('‚úÖ Office.js initialized for box plot dialog');
        Office.context.ui.addHandlerAsync(
          Office.EventType.DialogMessageReceived,
          onMessageReceived
        );
      };
      
      setTimeout(() => {
        const container = document.getElementById('results-container');
        if (!container.classList.contains('show')) {
          console.log('‚è∞ No data received from parent, loading sample data...');
          loadSampleData();
        }
      }, 2000);
    };
    
    // Fallback for browser testing
    window.addEventListener('DOMContentLoaded', function() {
      console.log('üöÄ DOM Content Loaded');
      
      // Initialize shared header
      StatisticoHeader.init('boxplot', 'Variable', 0);
      console.log('‚úÖ Shared header initialized');
      
      setTimeout(() => {
        if (typeof Office === 'undefined' || !Office.context) {
          console.log('‚ö†Ô∏è Office.js not available - loading sample data for browser testing');
          loadSampleData();
        }
      }, 100);
    });

    // Handle messages from parent window
    function onMessageReceived(arg) {
      console.log('üì® Message received:', arg);
      const message = JSON.parse(arg.message);
      
      if (message.type === 'data') {
        handleDataReceived(message.data);
      }
    }

    // Handle data received
    function handleDataReceived(data) {
      try {
        console.log('üìä Data received:', data);
        
        originalData = data.values || data.trimmedValues || data.transformedValues || data.rawValues || [];
        currentVariableName = data.variable || data.column || 'Variable';
        currentSampleSize = data.n || originalData.length;
        
        console.log('‚úÖ Data loaded:', { length: originalData.length, variable: currentVariableName });
        
        // Update shared header
        StatisticoHeader.updateVariable(currentVariableName, currentSampleSize);
        
        // Calculate and display
        displayBoxPlot();
        
        // Hide awaiting, show results
        document.getElementById('awaitingPanel').style.display = 'none';
        document.getElementById('results-container').classList.add('show');
        
      } catch (error) {
        console.error('‚ùå Error handling data:', error);
      }
    }

    // Load sample data for testing
    function loadSampleData() {
      console.log('üìä Loading sample data...');
      
      // Generate sample data (Horsepower-like)
      const sampleData = [];
      for (let i = 0; i < 369; i++) {
        const u1 = Math.random();
        const u2 = Math.random();
        const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        sampleData.push(201.17 + z * 60.64);
      }
      
      handleDataReceived({
        values: sampleData,
        column: 'Horsepower',
        n: sampleData.length
      });
    }

    // Calculate box plot statistics
    function calculateBoxPlot(data) {
      const sorted = [...data].sort((a, b) => a - b);
      const n = sorted.length;
      
      const q1 = sorted[Math.floor(n * 0.25)];
      const median = sorted[Math.floor(n * 0.5)];
      const q3 = sorted[Math.floor(n * 0.75)];
      const iqr = q3 - q1;
      
      const lowerFence = q1 - 1.5 * iqr;
      const upperFence = q3 + 1.5 * iqr;
      
      const outliers = sorted.filter(v => v < lowerFence || v > upperFence);
      const dataWithoutOutliers = sorted.filter(v => v >= lowerFence && v <= upperFence);
      
      const min = dataWithoutOutliers[0];
      const max = dataWithoutOutliers[dataWithoutOutliers.length - 1];
      
      return {
        min,
        q1,
        median,
        q3,
        max,
        outliers,
        dataWithoutOutliers,
        iqr
      };
    }

    // Display box plot
    function displayBoxPlot() {
      const boxData = calculateBoxPlot(originalData);
      console.log('üì¶ Box plot data:', boxData);
      
      // Create charts
      createBoxPlotWithOutliers(boxData);
      createBoxPlotWithoutOutliers(boxData);
    }

    // Create box plot with outliers
    function createBoxPlotWithOutliers(boxData) {
      const boxArray = [boxData.min, boxData.q1, boxData.median, boxData.q3, boxData.max];
      
      Highcharts.chart('withOutliers', {
        chart: { 
          type: 'boxplot',
          inverted: true,
          backgroundColor: 'transparent',
          marginTop: 35,
          marginBottom: 45,
          marginLeft: 75,
          marginRight: 25,
          spacingTop: 5,
          spacingBottom: 5,
          spacingLeft: 5,
          spacingRight: 5
        },
        title: { 
          text: 'Box Plot with Outliers',
          style: { color: 'rgb(255,165,120)', fontSize: '14px', fontWeight: '600' },
          margin: 10
        },
        legend: { enabled: false },
        credits: { enabled: false },
        xAxis: {
          categories: [currentVariableName],
          title: { 
            text: 'Distribution',
            style: { color: '#ffffff', fontSize: '12px' }
          },
          labels: { style: { color: '#ffffff', fontSize: '12px' } },
          gridLineColor: 'rgba(255, 255, 255, 0.1)'
        },
        yAxis: {
          title: { 
            text: 'Values',
            style: { color: '#ffffff', fontSize: '12px' }
          },
          labels: { style: { color: '#ffffff', fontSize: '11px' } },
          gridLineColor: 'rgba(255, 255, 255, 0.1)'
        },
        plotOptions: {
          boxplot: {
            fillColor: 'rgba(255, 165, 120, 0.3)',
            lineWidth: 2,
            medianColor: 'rgb(255, 165, 120)',
            medianWidth: 3,
            stemColor: 'rgb(255, 165, 120)',
            stemDashStyle: 'solid',
            stemWidth: 2,
            whiskerColor: 'rgb(255, 165, 120)',
            whiskerLength: '20%',
            whiskerWidth: 2
          }
        },
        series: [{
          name: currentVariableName,
          data: [[boxArray[0], boxArray[1], boxArray[2], boxArray[3], boxArray[4]]],
          tooltip: {
            headerFormat: '<em>{point.key}</em><br/>',
            pointFormatter: function() {
              return `
                <b>Maximum:</b> ${this.high != null ? this.high.toFixed(2) : '--'}<br/>
                <b>Q3 (75%):</b> ${this.q3 != null ? this.q3.toFixed(2) : '--'}<br/>
                <b>Median:</b> ${this.median != null ? this.median.toFixed(2) : '--'}<br/>
                <b>Q1 (25%):</b> ${this.q1 != null ? this.q1.toFixed(2) : '--'}<br/>
                <b>Minimum:</b> ${this.low != null ? this.low.toFixed(2) : '--'}
              `;
            }
          }
        }, {
          name: 'Outliers',
          type: 'scatter',
          data: boxData.outliers.map(v => [0, v]),
          marker: {
            fillColor: 'rgb(120, 200, 255)',
            lineWidth: 1,
            lineColor: 'rgb(120, 200, 255)',
            radius: 4
          },
          tooltip: {
            pointFormatter: function() {
              return `<b>Outlier:</b> ${this.y != null ? this.y.toFixed(2) : '--'}`;
            }
          }
        }, {
          name: 'Stat Labels',
          type: 'scatter',
          data: [
            { x: 0, y: boxArray[0], name: `Min: ${boxArray[0].toFixed(1)}` },
            { x: 0, y: boxArray[1], name: `Q1: ${boxArray[1].toFixed(1)}` },
            { x: 0, y: boxArray[2], name: `Median: ${boxArray[2].toFixed(1)}` },
            { x: 0, y: boxArray[3], name: `Q3: ${boxArray[3].toFixed(1)}` },
            { x: 0, y: boxArray[4], name: `Max: ${boxArray[4].toFixed(1)}` }
          ],
          marker: { enabled: false },
          enableMouseTracking: false,
          dataLabels: {
            enabled: true,
            formatter: function() { return this.point.name; },
            style: { color: 'rgb(255, 165, 120)', fontSize: '11px', textOutline: 'none' }
          }
        }]
      });
    }

    // Create box plot without outliers
    function createBoxPlotWithoutOutliers(boxData) {
      const dataNoOutliers = boxData.dataWithoutOutliers;
      const minNoOut = dataNoOutliers[0];
      const maxNoOut = dataNoOutliers[dataNoOutliers.length - 1];
      const boxArray = [minNoOut, boxData.q1, boxData.median, boxData.q3, maxNoOut];
      
      Highcharts.chart('withoutOutliers', {
        chart: { 
          type: 'boxplot',
          inverted: true,
          backgroundColor: 'transparent',
          marginTop: 35,
          marginBottom: 45,
          marginLeft: 75,
          marginRight: 25,
          spacingTop: 5,
          spacingBottom: 5,
          spacingLeft: 5,
          spacingRight: 5
        },
        title: { 
          text: 'Box Plot Without Outliers + Outlier Points',
          style: { color: 'rgb(255,165,120)', fontSize: '14px', fontWeight: '600' },
          margin: 10
        },
        legend: { enabled: false },
        credits: { enabled: false },
        xAxis: {
          categories: [currentVariableName],
          title: { 
            text: 'Distribution',
            style: { color: '#ffffff', fontSize: '12px' }
          },
          labels: { style: { color: '#ffffff', fontSize: '12px' } },
          gridLineColor: 'rgba(255, 255, 255, 0.1)'
        },
        yAxis: {
          title: { 
            text: 'Values',
            style: { color: '#ffffff', fontSize: '12px' }
          },
          labels: { style: { color: '#ffffff', fontSize: '11px' } },
          gridLineColor: 'rgba(255, 255, 255, 0.1)'
        },
        plotOptions: {
          boxplot: {
            fillColor: 'rgba(120, 200, 255, 0.3)',
            lineWidth: 2,
            medianColor: 'rgb(120, 200, 255)',
            medianWidth: 3,
            stemColor: 'rgb(120, 200, 255)',
            stemDashStyle: 'solid',
            stemWidth: 2,
            whiskerColor: 'rgb(120, 200, 255)',
            whiskerLength: '20%',
            whiskerWidth: 2
          }
        },
        series: [{
          name: currentVariableName,
          data: [[boxArray[0], boxArray[1], boxArray[2], boxArray[3], boxArray[4]]],
          tooltip: {
            headerFormat: '<em>{point.key}</em><br/>',
            pointFormatter: function() {
              return `
                <b>Maximum:</b> ${this.high != null ? this.high.toFixed(2) : '--'}<br/>
                <b>Q3 (75%):</b> ${this.q3 != null ? this.q3.toFixed(2) : '--'}<br/>
                <b>Median:</b> ${this.median != null ? this.median.toFixed(2) : '--'}<br/>
                <b>Q1 (25%):</b> ${this.q1 != null ? this.q1.toFixed(2) : '--'}<br/>
                <b>Minimum:</b> ${this.low != null ? this.low.toFixed(2) : '--'}
              `;
            }
          }
        }, {
          name: 'Outlier Points',
          type: 'scatter',
          data: boxData.outliers.map(v => [0, v]),
          marker: {
            symbol: 'diamond',
            fillColor: 'rgba(255, 100, 100, 0.6)',
            lineWidth: 1,
            lineColor: 'rgb(255, 100, 100)',
            radius: 5
          },
          tooltip: {
            pointFormatter: function() {
              return `<b>Outlier Point:</b> ${this.y != null ? this.y.toFixed(2) : '--'}`;
            }
          }
        }, {
          name: 'Stat Labels',
          type: 'scatter',
          data: [
            { x: 0, y: boxArray[0], name: `Min: ${boxArray[0].toFixed(1)}` },
            { x: 0, y: boxArray[1], name: `Q1: ${boxArray[1].toFixed(1)}` },
            { x: 0, y: boxArray[2], name: `Median: ${boxArray[2].toFixed(1)}` },
            { x: 0, y: boxArray[3], name: `Q3: ${boxArray[3].toFixed(1)}` },
            { x: 0, y: boxArray[4], name: `Max: ${boxArray[4].toFixed(1)}` }
          ],
          marker: { enabled: false },
          enableMouseTracking: false,
          dataLabels: {
            enabled: true,
            formatter: function() { return this.point.name; },
            style: { color: 'rgb(120, 200, 255)', fontSize: '11px', textOutline: 'none' }
          }
        }]
      });
    }

    // Auto-test on load (browser only)
    if (typeof Office === 'undefined') {
      window.addEventListener('load', () => {
        setTimeout(() => {
          if (!document.querySelector('#withOutliers .highcharts-container')) {
            console.log('üîÑ No charts detected, running auto-test...');
            loadSampleData();
          }
        }, 1000);
      });
    }
  </script>
</body>
</html>
