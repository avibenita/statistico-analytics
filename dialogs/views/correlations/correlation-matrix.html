<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>Correlation Matrix</title>
  
  <!-- Office.js -->
  <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
  
  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" rel="stylesheet"/>

  <!-- Highcharts + Regression for Scatter -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highcharts/10.3.3/highcharts.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highcharts/10.3.3/modules/exporting.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highcharts/10.3.3/modules/export-data.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.9.5/jstat.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/regression/2.0.1/regression.min.js"></script>
  
  <!-- Shared Header -->
  <link rel="stylesheet" href="../shared-header.css?v=20260206-003">
  <script src="../shared-header.js?v=20260206-003"></script>

  <style>
    /* Dark Theme (Default) */
    :root{
      --surface-0:#0c1624;
      --surface-1:#1a1f2e;
      --surface-2:#242938;
      --border:#2d3748;
      --accent-1:rgb(255,165,120);
      --accent-2:rgb(120,200,255);
      --text-primary:#fff;
      --text-secondary:rgba(255,255,255,0.8);
      --text-muted:rgba(255,255,255,0.5);
    }
    
    /* Light Theme */
    :root[data-theme="light"]{
      --surface-0:#f3f4f6;
      --surface-1:#ffffff;
      --surface-2:#f9fafb;
      --border:#e5e7eb;
      --accent-1:#2563eb;
      --accent-2:#1d4ed8;
      --text-primary:#111827;
      --text-secondary:#4b5563;
      --text-muted:#6b7280;
    }

    *{
      margin:0;
      padding:0;
      box-sizing:border-box;
    }

    body{
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,sans-serif;
      background:linear-gradient(135deg, var(--surface-0) 0%, #1a2332 100%);
      color:var(--text-primary);
      line-height:1.6;
      padding:0;
      margin:0;
      min-height:100vh;
      overflow-x:hidden;
    }

    .container{
      max-width:100%;
      margin:0;
      padding:0;
      display:flex;
      flex-direction:column;
      min-height:100vh;
    }

    .results-container{
      flex:1;
      padding:20px;
      overflow:auto;
    }

    h1{
      display: none;
    }

    /* Control Group */
    .controls{
      background:var(--surface-1);
      padding:20px;
      border-radius:10px;
      margin-bottom:25px;
      border:2px solid var(--border);
      box-shadow:0 4px 20px rgba(0,0,0,0.3);
      display:grid;
      grid-template-columns:repeat(auto-fit, minmax(220px, 1fr));
      align-items:stretch;
      gap:16px;
      overflow-x:hidden;
    }

    .control-group{
      margin-bottom:0;
      min-width:0;
      width:100%;
    }

    .type-group{
      min-width:0;
    }

    .control-group label{
      font-size:14px;
      color:var(--text-secondary);
      font-weight:600;
      margin-bottom:8px;
      display:block;
    }

    /* Radio Bar */
    .radio-bar{
      display:flex;
      gap:8px;
      flex-wrap:nowrap;
      align-items:center;
    }

    .radio-bar label{
      flex:0 0 auto;
      min-width:90px;
      background:var(--surface-2);
      border:2px solid var(--border);
      border-radius:8px;
      padding:8px 12px;
      cursor:pointer;
      transition:all 0.3s ease;
      display:flex;
      align-items:center;
      justify-content:center;
      white-space:nowrap;
      flex-shrink:0;
      font-size:13px;
    }

    .radio-bar label:hover{
      border-color:var(--accent-1);
      transform:translateY(-2px);
    }

    .radio-bar input[type="radio"]{
      display:none;
    }

    .view-toggle{
      display:flex;
      gap:8px;
      background:var(--surface-2);
      border:2px solid var(--border);
      border-radius:20px;
      padding:4px;
      max-width:150px;
    }

    .view-toggle button{
      border:none;
      background:transparent;
      color:var(--text-secondary);
      font-size:13px;
      font-weight:600;
      padding:6px 12px;
      border-radius:16px;
      cursor:pointer;
      transition:all 0.2s ease;
      white-space:nowrap;
    }

    .view-toggle button.active{
      background:var(--accent-1);
      color:var(--surface-0);
      box-shadow:0 0 10px rgba(255,165,120,0.3);
    }

    .radio-bar input[type="radio"]:checked + span{
      color:var(--accent-1);
      font-weight:700;
    }

    .radio-bar label:has(input:checked){
      background:linear-gradient(135deg, rgba(255,165,120,0.2), rgba(120,200,255,0.2));
      border-color:var(--accent-1);
      box-shadow:0 0 15px rgba(255,165,120,0.3);
    }

    /* Filter Controls Frame */
    .filter-controls-frame{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:20px;
      margin-top:20px;
      padding-top:20px;
      border-top:1px solid var(--border);
      flex-wrap:nowrap;
    }

    .slider-center{
      flex:1;
      display:flex;
      justify-content:center;
    }

    .checkbox-right{
      flex-shrink:0;
    }

    .slider-container{
      display:flex;
      align-items:center;
      gap:12px;
      margin-bottom:0;
      min-width:0;
    }

    .slider-label{
      font-size:14px;
      color:var(--text-secondary);
      font-weight:600;
      white-space:nowrap;
    }

    input[type="range"]{
      flex:1;
      min-width:140px;
      height:8px;
      border-radius:5px;
      background:linear-gradient(90deg, var(--surface-2) 0%, var(--accent-1) 100%);
      outline:none;
      -webkit-appearance:none;
    }

    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width:20px;
      height:20px;
      border-radius:50%;
      background:linear-gradient(135deg, var(--accent-1), var(--accent-2));
      cursor:pointer;
      box-shadow:0 2px 10px rgba(255,165,120,0.5);
      transition:all 0.3s ease;
    }

    input[type="range"]::-webkit-slider-thumb:hover{
      transform:scale(1.2);
      box-shadow:0 4px 15px rgba(255,165,120,0.7);
    }

    input[type="range"]::-moz-range-thumb{
      width:20px;
      height:20px;
      border-radius:50%;
      background:linear-gradient(135deg, var(--accent-1), var(--accent-2));
      cursor:pointer;
      border:none;
      box-shadow:0 2px 10px rgba(255,165,120,0.5);
      transition:all 0.3s ease;
    }

    input[type="range"]::-moz-range-thumb:hover{
      transform:scale(1.2);
      box-shadow:0 4px 15px rgba(255,165,120,0.7);
    }

    .slider-value{
      font-size:16px;
      color:var(--accent-1);
      font-weight:700;
      min-width:50px;
      text-align:right;
    }

    /* Checkbox Group */
    .checkbox-group{
      display:flex;
      gap:15px;
      flex-wrap:wrap;
      margin-bottom:0;
      align-items:center;
      white-space:normal;
    }

    @media (max-width: 900px){
      .controls{
        grid-template-columns:repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 600px){
      .controls{
        grid-template-columns:1fr;
      }
      .view-toggle{
        max-width:none;
      }
    }

    .checkbox-label{
      display:flex;
      align-items:center;
      gap:8px;
      cursor:pointer;
      font-size:14px;
      color:var(--text-secondary);
      transition:color 0.3s ease;
    }

    .checkbox-label:hover{
      color:var(--text-primary);
    }

    .checkbox-label input[type="checkbox"]{
      width:18px;
      height:18px;
      cursor:pointer;
      accent-color:var(--accent-1);
    }

    .checkbox-label:has(input:checked){
      color:var(--accent-1);
      font-weight:600;
    }

    .table-container{
      width:100%;
      border:2px solid var(--border);
      border-radius:8px;
      overflow:auto;
      max-height:70vh;
      position:relative;
      scroll-behavior:smooth;
      background:
        linear-gradient(90deg, var(--surface-1) 30%, rgba(26,31,46,0)),
        linear-gradient(90deg, rgba(26,31,46,0), var(--surface-1) 70%) 100% 0,
        radial-gradient(farthest-side at 0 50%, rgba(0,0,0,.3), rgba(0,0,0,0)),
        radial-gradient(farthest-side at 100% 50%, rgba(0,0,0,.3), rgba(0,0,0,0)) 100% 0;
      background-repeat:no-repeat;
      background-color:var(--surface-1);
      background-size:40px 100%, 40px 100%, 14px 100%, 14px 100%;
      background-attachment:local, local, scroll, scroll;
    }

    .table-container::-webkit-scrollbar{
      height:12px;
      width:12px;
    }

    #tableContainerTop{
      overflow-x:auto;
      overflow-y:hidden;
      height:14px;
      margin-bottom:8px;
    }

    #tableContainerTop::-webkit-scrollbar{
      height:12px;
    }

    .table-container::-webkit-scrollbar-track{
      background:var(--surface-2);
      border-radius:6px;
    }

    .table-container::-webkit-scrollbar-thumb{
      background:linear-gradient(135deg, var(--accent-1), var(--accent-2));
      border-radius:6px;
      border:2px solid var(--surface-2);
    }

    .table-container::-webkit-scrollbar-thumb:hover{
      background:linear-gradient(135deg, #ffb890, #90d0ff);
    }

    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      background:var(--surface-1);
    }

    thead{
      position:sticky;
      top:0;
      z-index:10;
      background:var(--surface-2);
    }

    thead th{
      position:sticky;
      top:0;
      background:linear-gradient(135deg, var(--surface-2), #2d3545);
      padding:14px 12px;
      text-align:center;
      font-weight:800;
      font-size:16px;
      color:var(--accent-1);
      border-bottom:3px solid var(--accent-1);
      border-right:1px solid var(--border);
      white-space:nowrap;
      text-transform:uppercase;
      letter-spacing:0.5px;
    }

    thead th:first-child{
      position:sticky;
      left:0;
      z-index:11;
      text-align:left;
      min-width:120px;
    }

    tbody tr:nth-child(even){
      background:rgba(36,41,56,0.5);
    }

    tbody tr:hover{
      background:rgba(255,165,120,0.05);
    }

    tbody td{
      padding:10px;
      text-align:center;
      font-size:12px;
      border-right:1px solid var(--border);
      border-bottom:1px solid var(--border);
    }

    tbody td:first-child{
      position:sticky;
      left:0;
      background:inherit;
      font-weight:700;
      text-align:left;
      color:var(--accent-2);
      z-index:2;
      min-width:120px;
    }

    tbody tr:nth-child(even) td:first-child{
      background:rgba(36,41,56,0.5);
    }

    tbody tr:hover td:first-child{
      background:rgba(255,165,120,0.05);
    }

    .corr-value{
      font-weight:700;
      font-size:14px;
      text-decoration:underline;
      text-underline-offset:3px;
      cursor:pointer;
    }

    .p-value{
      font-size:11px;
      color:var(--text-muted);
    }

    .n-value{
      font-size:10px;
      color:var(--text-muted);
      font-style:italic;
    }

    .diagonal-cell{
      background:transparent !important;
      position:relative;
    }

    .diagonal-cell .corr-value{
      color:var(--accent-2);
      text-decoration:none;
      cursor:default;
    }

    .diagonal-cell::after{
      content:'';
      position:absolute;
      top:0;
      left:0;
      right:0;
      bottom:0;
      border:1px solid rgba(120,200,255,0.3);
      pointer-events:none;
    }

    .threshold-highlight{
      background:linear-gradient(135deg, rgba(255,165,120,0.25), rgba(120,200,255,0.25))!important;
      animation:pulse-highlight 2s ease-in-out infinite;
    }

    .heatmap-container{
      width:100%;
      border:2px solid var(--border);
      border-radius:8px;
      overflow:auto;
      max-height:70vh;
      background:var(--surface-1);
    }

    .heatmap-table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      background:var(--surface-1);
    }

    .heatmap-table thead th{
      position:sticky;
      top:0;
      z-index:10;
      background:linear-gradient(135deg, var(--surface-2), #2d3545);
      padding:10px 8px;
      text-align:center;
      font-weight:700;
      font-size:12px;
      color:var(--accent-1);
      border-bottom:2px solid var(--accent-1);
      border-right:1px solid var(--border);
      white-space:nowrap;
    }

    .heatmap-table thead th:first-child{
      position:sticky;
      left:0;
      z-index:11;
      text-align:left;
      min-width:150px;
    }

    .heatmap-table tbody td{
      padding:8px;
      text-align:center;
      font-size:12px;
      border-right:1px solid var(--border);
      border-bottom:1px solid var(--border);
      color:#0c1624;
      font-weight:700;
    }

    .heatmap-table tbody td:first-child{
      position:sticky;
      left:0;
      background:var(--surface-1);
      color:var(--accent-2);
      font-weight:700;
      text-align:left;
      z-index:2;
      min-width:150px;
    }

    .heatmap-cell.threshold-highlight{
      outline:2px solid rgba(255,165,120,0.9);
      outline-offset:-2px;
      box-shadow:inset 0 0 10px rgba(255,165,120,0.6);
    }
    .scatter-modal{
      display:none;
      position:fixed;
      z-index:9999;
      top:0;
      left:0;
      right:0;
      bottom:0;
      background:rgba(0,0,0,0.65);
      align-items:center;
      justify-content:center;
      padding:20px;
    }

    .scatter-modal-content{
      background:var(--surface-1);
      border:2px solid var(--border);
      border-radius:12px;
      width:90%;
      max-width:900px;
      max-height:90vh;
      overflow:hidden;
      box-shadow:0 20px 60px rgba(0,0,0,0.5);
      display:flex;
      flex-direction:column;
    }

    .scatter-modal-header{
      padding:10px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      border-bottom:1px solid var(--border);
      color:var(--accent-1);
      font-weight:600;
    }

    .scatter-modal-body{
      padding:10px 14px 12px;
      overflow:auto;
    }

    .scatter-close{
      cursor:pointer;
      font-size:20px;
      color:var(--text-secondary);
    }

    .scatter-chart{
      width:100%;
      height:320px;
      background:rgba(0,0,0,0.15);
      border:1px solid var(--border);
      border-radius:8px;
      position:relative;
    }

    .scatter-stats{
      display:grid;
      grid-template-columns:repeat(4, minmax(140px, 1fr));
      gap:8px;
      margin-bottom:8px;
    }

    .scatter-stat{
      background:rgba(255,255,255,0.06);
      border:1px solid var(--border);
      border-radius:8px;
      padding:8px 10px;
      text-align:center;
    }

    .scatter-stat-value{
      font-size:18px;
      font-weight:700;
      color:var(--accent-1);
    }

    .scatter-stat-value.adjusted::after{
      content:"*";
      margin-left:4px;
      color:var(--accent-2);
      font-weight:700;
    }

    .scatter-stat-label{
      font-size:11px;
      color:var(--text-muted);
    }

    .scatter-controls{
      display:grid;
      grid-template-columns:repeat(3, minmax(190px, 1fr));
      gap:10px;
      margin-top:10px;
    }

    .scatter-panel{
      background:rgba(255,255,255,0.04);
      border:1px solid var(--border);
      border-radius:10px;
      padding:8px;
      overflow:hidden;
    }

    .scatter-panel-title{
      display:flex;
      align-items:center;
      gap:8px;
      font-weight:600;
      margin-bottom:6px;
      color:var(--accent-1);
      font-size:13px;
    }

    .scatter-slider{
      margin-bottom:8px;
      width:100%;
      min-width:0;
    }

    .scatter-slider-header{
      display:flex;
      justify-content:space-between;
      font-size:12px;
      color:var(--text-secondary);
      margin-bottom:3px;
    }

    .scatter-slider input[type="range"]{
      width:100%;
    }

    .scatter-buttons{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
    }

    .fit-equation{
      margin-top:8px;
      padding:6px 8px;
      border-radius:6px;
      background:rgba(255,255,255,0.06);
      border:1px solid var(--border);
      color:var(--text-secondary);
      font-size:12px;
      text-align:center;
      min-height:28px;
      display:flex;
      align-items:center;
      justify-content:center;
      word-break:break-word;
    }

    .scatter-btn{
      background:rgba(255,255,255,0.08);
      border:1px solid var(--border);
      color:var(--text-secondary);
      padding:5px 8px;
      border-radius:6px;
      font-size:12px;
      cursor:pointer;
    }

    .scatter-btn.active{
      color:var(--surface-0);
      background:var(--accent-1);
      border-color:var(--accent-1);
      font-weight:600;
    }

    .scatter-axis-toggle{
      display:flex;
      gap:6px;
      margin-bottom:6px;
    }

    .axis-grid{
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    .axis-row{
      display:grid;
      grid-template-columns:minmax(0, 1fr) minmax(0, 1fr);
      gap:10px;
    }

    @media (max-width: 1000px){
      .scatter-controls{
        grid-template-columns:1fr;
      }
      .axis-row{
        grid-template-columns:1fr;
      }
    }

    .scatter-axis-toggle .scatter-btn{
      flex:1;
    }

    @keyframes pulse-highlight{
      0%, 100%{
        box-shadow:inset 0 0 8px rgba(255,165,120,0.4);
      }
      50%{
        box-shadow:inset 0 0 15px rgba(255,165,120,0.6);
      }
    }

    .loading{
      text-align:center;
      padding:60px 20px;
      color:var(--text-secondary);
    }

    .loading i{
      font-size:48px;
      color:var(--accent-1);
      animation:spin 1s linear infinite;
    }

    @keyframes spin{
      0%{transform:rotate(0deg);}
      100%{transform:rotate(360deg);}
    }

    .loading p{
      margin-top:20px;
      font-size:18px;
    }

    .scroll-hint{
      background:linear-gradient(135deg, rgba(255,165,120,0.15), rgba(120,200,255,0.15));
      padding:12px 20px;
      border-radius:8px;
      text-align:center;
      margin-bottom:15px;
      font-size:14px;
      color:var(--text-secondary);
      border:1px solid rgba(255,165,120,0.3);
    }

    .scroll-hint i{
      color:var(--accent-1);
      margin-right:8px;
    }

    /* Responsive Design */
    @media (max-width: 1200px){
      .filter-controls-frame{
        flex-direction:column;
        align-items:flex-start;
      }
      .slider-center{
        width:100%;
        justify-content:flex-start;
      }
      input[type="range"]{
        min-width:150px;
      }
    }

    @media (max-width: 768px){
      .results-container{
        padding:15px;
      }
      h1{
        font-size:22px;
      }
      .controls{
        padding:15px;
      }
      .radio-bar{
        flex-direction:column;
      }
      .radio-bar label{
        min-width:unset;
      }
      tbody td{
        font-size:11px;
        padding:8px;
      }
      .corr-value{
        font-size:12px;
      }
    }

    @media (max-width: 480px){
      .results-container{
        padding:10px;
      }
      h1{
        font-size:18px;
      }
      .controls{
        padding:12px;
      }
      input[type="range"]{
        min-width:100px;
      }
    }
  </style>
</head>
<body>
  <div class="container" id="mainContainer" style="display:none;">
    <div class="results-container">
      <div class="controls">
        <div class="control-group type-group">
          <label>Correlation Type:</label>
          <div class="radio-bar">
            <label>
              <input type="radio" name="corrType" value="Pearson" checked onchange="recalculate()">
              <span>Pearson</span>
            </label>
            <label>
              <input type="radio" name="corrType" value="Spearman" onchange="recalculate()">
              <span>Spearman</span>
            </label>
            <label>
              <input type="radio" name="corrType" value="Kendall" onchange="recalculate()">
              <span>Kendall</span>
            </label>
            <label>
              <input type="radio" name="corrType" value="Biweight" onchange="recalculate()">
              <span>Biweight</span>
            </label>
          </div>
        </div>
        <div class="control-group">
          <label>View:</label>
          <div class="view-toggle" role="tablist" aria-label="Matrix view">
            <button type="button" id="viewTableBtn" class="active" onclick="setMatrixView('table')">Table</button>
            <button type="button" id="viewHeatmapBtn" onclick="setMatrixView('heatmap')">Heatmap</button>
          </div>
        </div>
        <div class="control-group slider-container">
          <span class="slider-label">Highlight r ‚â•</span>
          <input type="range" id="thresholdSlider" min="0" max="1" step="0.05" value="0" oninput="updateThreshold(this.value)">
          <span class="slider-value" id="thresholdValue">0.00</span>
        </div>
        <div class="control-group checkbox-group">
          <label class="checkbox-label">
            <input type="checkbox" id="showPValue" checked onchange="toggleDisplay()">
            <span>Show p-value</span>
          </label>
          <label class="checkbox-label">
            <input type="checkbox" id="showN" checked onchange="toggleDisplay()">
            <span>Show n</span>
          </label>
        </div>
      </div>

      <div id="loadingMessage" class="loading">
        <i class="fa-solid fa-spinner"></i>
        <p>Loading correlation data...</p>
      </div>

      <div id="scatterModal" class="scatter-modal" role="dialog" aria-hidden="true">
        <div class="scatter-modal-content">
          <div class="scatter-modal-header">
            <span id="scatterTitle">Scatter Plot</span>
            <span class="scatter-close" onclick="closeScatterModal()">&times;</span>
          </div>
          <div class="scatter-modal-body">
            <div class="scatter-stats">
              <div class="scatter-stat">
                <div class="scatter-stat-value" id="scatterN">--</div>
                <div class="scatter-stat-label">Observations</div>
              </div>
              <div class="scatter-stat">
                <div class="scatter-stat-value" id="scatterR">--</div>
                <div class="scatter-stat-label">Correlation (R)</div>
              </div>
              <div class="scatter-stat">
                <div class="scatter-stat-value" id="scatterP">--</div>
                <div class="scatter-stat-label">p-value</div>
              </div>
              <div class="scatter-stat">
                <div class="scatter-stat-value" id="scatterR2">--</div>
                <div class="scatter-stat-label">R¬≤</div>
              </div>
            </div>
            <div id="scatterChart" class="scatter-chart"></div>
            <div class="scatter-controls">
              <div class="scatter-panel">
                <div class="scatter-panel-title"><i class="fas fa-sliders-h"></i>Axis Controls</div>
                <div class="axis-grid">
                  <div class="axis-row">
                    <div class="scatter-slider">
                      <div class="scatter-slider-header"><span>X Min</span><span id="xMinVal">--</span></div>
                      <input type="range" id="xMinRange" oninput="updateAxisRange('x','min', this.value)">
                    </div>
                    <div class="scatter-slider">
                      <div class="scatter-slider-header"><span>X Max</span><span id="xMaxVal">--</span></div>
                      <input type="range" id="xMaxRange" oninput="updateAxisRange('x','max', this.value)">
                    </div>
                  </div>
                  <div class="axis-row">
                    <div class="scatter-slider">
                      <div class="scatter-slider-header"><span>Y Min</span><span id="yMinVal">--</span></div>
                      <input type="range" id="yMinRange" oninput="updateAxisRange('y','min', this.value)">
                    </div>
                    <div class="scatter-slider">
                      <div class="scatter-slider-header"><span>Y Max</span><span id="yMaxVal">--</span></div>
                      <input type="range" id="yMaxRange" oninput="updateAxisRange('y','max', this.value)">
                    </div>
                  </div>
                </div>
              </div>
              <div class="scatter-panel">
                <div class="scatter-panel-title"><i class="fas fa-wave-square"></i>Curve Fitting</div>
                <div class="scatter-buttons">
                  <button class="scatter-btn active" id="fit-none" onclick="applyFit('none')">None</button>
                  <button class="scatter-btn" id="fit-linear" onclick="applyFit('linear')">Linear</button>
                  <button class="scatter-btn" id="fit-polynomial" onclick="applyFit('polynomial')">Polynomial</button>
                  <button class="scatter-btn" id="fit-exponential" onclick="applyFit('exponential')">Exponential</button>
                  <button class="scatter-btn" id="fit-logarithmic" onclick="applyFit('logarithmic')">Logarithmic</button>
                  <button class="scatter-btn" id="fit-power" onclick="applyFit('power')">Power</button>
                </div>
                <div class="fit-equation" id="fitEquation">Equation: ‚Äî</div>
              </div>
              <div class="scatter-panel">
                <div class="scatter-panel-title"><i class="fas fa-exchange-alt"></i>Axis Transformations</div>
                <div class="scatter-axis-toggle">
                  <button class="scatter-btn active" id="transform-x-tab" onclick="setTransformAxis('x')">X-Axis</button>
                  <button class="scatter-btn" id="transform-y-tab" onclick="setTransformAxis('y')">Y-Axis</button>
                </div>
                <div class="scatter-buttons">
                  <button class="scatter-btn active" id="transform-none" onclick="applyTransformation('none')">None</button>
                  <button class="scatter-btn" id="transform-ln" onclick="applyTransformation('ln')">ln</button>
                  <button class="scatter-btn" id="transform-inverse" onclick="applyTransformation('inverse')">1/x</button>
                  <button class="scatter-btn" id="transform-sqrt" onclick="applyTransformation('sqrt')">‚àö</button>
                  <button class="scatter-btn" id="transform-square" onclick="applyTransformation('square')">x¬≤</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="resultsContainer" style="display:none;">
        <div class="table-container" id="tableContainerTop" style="height:12px;">
          <div id="tableScrollTop" style="height:1px;"></div>
        </div>
        <div class="table-container" id="tableContainer">
          <table id="correlationTable">
            <thead id="tableHead"></thead>
            <tbody id="tableBody"></tbody>
          </table>
        </div>
      </div>
      <div id="heatmapContainer" style="display:none;">
        <div class="heatmap-container">
          <table id="heatmapTable" class="heatmap-table">
            <thead id="heatmapHead"></thead>
            <tbody id="heatmapBody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <script>
    let correlationData = null;
    let currentType = 'Pearson';
    let scatterPointsCache = new Map();
    let scatterState = {
      rawPoints: [],
      xVar: '',
      yVar: '',
      xTransform: 'none',
      yTransform: 'none',
      fitType: 'none',
      activeTransformAxis: 'x',
      chart: null,
      xRange: null,
      yRange: null,
      xRangeFull: null,
      yRangeFull: null
    };
    let currentMatrix = null;
    let currentHeaders = null;
    let currentView = 'table';

    // Check if we're in an iframe
    const isInIframe = window.self !== window.top;
    
    if (isInIframe) {
      // Running in iframe - listen for postMessage
      console.log('üìä Running in iframe, waiting for data via postMessage');
      
      window.addEventListener('message', function(event) {
        console.log('üì• Received postMessage:', event.data);
        if (event.data && event.data.type === 'CORRELATION_DATA') {
          correlationData = event.data.payload;
          console.log('‚úÖ Data received via postMessage');
          renderMatrix();
        } else if (event.data && event.data.type === 'THEME_CHANGE') {
          console.log('üé® Theme change received:', event.data.theme);
          applyTheme(event.data.theme);
        }
      });
      
      // Function to apply theme
      function applyTheme(theme) {
        const root = document.documentElement;
        if (theme === 'light') {
          root.setAttribute('data-theme', 'light');
          console.log('‚òÄÔ∏è Applied Light Theme to correlation matrix');
        } else {
          root.removeAttribute('data-theme');
          console.log('üåô Applied Dark Theme to correlation matrix');
        }
      }
      
      // Also try sessionStorage as fallback
      document.addEventListener('DOMContentLoaded', function() {
        setTimeout(function() {
          if (!correlationData) {
            console.log('‚è∞ Trying sessionStorage as fallback');
            const storedData = sessionStorage.getItem('correlationData');
            if (storedData) {
              try {
                correlationData = JSON.parse(storedData);
                console.log('üì¶ Loaded correlation data from sessionStorage:', correlationData);
                renderMatrix();
              } catch (e) {
                console.error('Error loading data from sessionStorage:', e);
              }
            }
          }
        }, 1000);
      });
    } else {
      // Initialize Office.js (standalone dialog)
      Office.onReady(function(info) {
        console.log('Office initialized in correlation matrix dialog');
        
        // Only initialize header if NOT in iframe mode (standalone mode)
        const isInIframe = window.self !== window.top;
        if (!isInIframe && typeof StatisticoHeader !== 'undefined') {
          StatisticoHeader.init('correlation-matrix', 'Correlation Matrix', 0, 'correlations');
        } else if (isInIframe) {
          console.log('üì¶ Running in iframe mode - header hidden');
        }
        
        // Check if data was pre-loaded in sessionStorage (e.g., from regression dialog)
        const storedData = sessionStorage.getItem('correlationData');
        if (storedData) {
          try {
            correlationData = JSON.parse(storedData);
            console.log('üì¶ Loaded correlation data from sessionStorage:', correlationData);
            
            // If data came from regression model, update the title
            if (correlationData.source === 'regression-model' && correlationData.modelInfo) {
              const modelInfo = correlationData.modelInfo;
              console.log('üìä Showing correlations for regression model:', modelInfo);
            }
            
            // Render the matrix immediately
            renderMatrix();
            
            // Clear the sessionStorage after loading to prevent stale data
            sessionStorage.removeItem('correlationData');
          } catch (e) {
            console.error('Error loading data from sessionStorage:', e);
          }
        }
        
        // Listen for messages from parent (for normal dialog usage)
        Office.context.ui.addHandlerAsync(
          Office.EventType.DialogParentMessageReceived,
          onMessageFromParent
        );
        
        // Notify parent that dialog is ready (if opened as a child dialog)
        Office.context.ui.messageParent(JSON.stringify({
          action: 'ready'
        }));
      });
    }

    /**
     * Handle messages from parent taskpane
     */
    function onMessageFromParent(arg) {
      try {
        const message = JSON.parse(arg.message);
        console.log('Received message from parent:', message);

        if (message.type === 'CORRELATION_DATA' && message.payload) {
          correlationData = message.payload;
          console.log('Correlation data received:', correlationData);
          renderMatrix();
        }
      } catch (error) {
        console.error('Error parsing message:', error);
      }
    }

    /**
     * Render correlation matrix
     */
    function renderMatrix() {
      const container = document.getElementById('mainContainer');
      const loading = document.getElementById('loadingMessage');
      const results = document.getElementById('resultsContainer');

      if (!correlationData || !correlationData.headers || correlationData.headers.length === 0) {
        console.error('Invalid correlation data');
        loading.innerHTML = '<i class="fa-solid fa-exclamation-triangle"></i><p>No correlation data available</p>';
        container.style.display = 'flex';
        return;
      }

      console.log('Rendering matrix with data:', correlationData);
      
      // Calculate sample size
      const sampleSize = correlationData.data ? correlationData.data.length : 0;
      
      // Update header with correct sample size (only if not in iframe)
      const isInIframe = window.self !== window.top;
      if (!isInIframe && typeof StatisticoHeader !== 'undefined') {
        StatisticoHeader.sampleSize = sampleSize;
        StatisticoHeader.variableName = `${correlationData.headers.length} Variables`;
        StatisticoHeader.render();
      }
      
      // Hide loading, show results
      loading.style.display = 'none';
      results.style.display = 'block';
      container.style.display = 'flex';

      // Build correlation matrix
      buildCorrelationMatrix();
      setMatrixView(currentView);
    }

    /**
     * Build correlation table
     */
    function buildCorrelationMatrix() {
      const { headers, data, types } = correlationData;
      console.log('Building matrix for headers:', headers);

      // Calculate correlations
      const matrix = calculateCorrelationMatrix(data, headers, currentType);
      currentMatrix = matrix;
      currentHeaders = headers;
      
      // Build table
      const thead = document.getElementById('tableHead');
      const tbody = document.getElementById('tableBody');
      
      // Clear existing content
      thead.innerHTML = '';
      tbody.innerHTML = '';

      // Create header row
      const headerRow = document.createElement('tr');
      const cornerTh = document.createElement('th');
      cornerTh.textContent = 'Variable';
      headerRow.appendChild(cornerTh);

      headers.forEach(col => {
        const th = document.createElement('th');
        th.textContent = col;
        headerRow.appendChild(th);
      });

      thead.appendChild(headerRow);

      // Create data rows
      headers.forEach((rowCol, i) => {
        const row = document.createElement('tr');
        
        // Row header
        const rowTh = document.createElement('td');
        rowTh.textContent = rowCol;
        row.appendChild(rowTh);

        // Correlation cells
        headers.forEach((colCol, j) => {
          const td = document.createElement('td');
          const corrData = matrix[i][j];

          // Check if diagonal
          const isDiagonal = i === j;
          if (isDiagonal) {
            td.classList.add('diagonal-cell');
          }

          // Correlation value
          const corrValue = document.createElement('div');
          corrValue.className = 'corr-value';
          corrValue.textContent = corrData.r.toFixed(3);
          corrValue.setAttribute('data-corr', corrData.r);
          corrValue.setAttribute('data-row', rowCol);
          corrValue.setAttribute('data-col', colCol);
          if (!isDiagonal) {
            corrValue.addEventListener('click', () => {
              openScatterModal(rowCol, colCol, corrData.r);
            });
          }
          td.appendChild(corrValue);

          // P-value
          if (corrData.p !== null) {
            if (!isDiagonal) {
              const pValue = document.createElement('div');
              pValue.className = 'p-value';
              pValue.textContent = `p = ${corrData.p.toFixed(4)}`;
              td.appendChild(pValue);
            }
          }

          // N value
          if (!isDiagonal) {
            const nValue = document.createElement('div');
            nValue.className = 'n-value';
            nValue.textContent = `N = ${corrData.n}`;
            td.appendChild(nValue);
          }

          row.appendChild(td);
        });

        tbody.appendChild(row);
      });

      // Build heatmap
      buildHeatmapMatrix(headers, matrix);

      // Sync top scroll width
      syncTopScroll();

      // Apply display settings
      toggleDisplay();
      applyThresholdFilter();
    }

    function syncTopScroll() {
      const tableContainer = document.getElementById('tableContainer');
      const topContainer = document.getElementById('tableContainerTop');
      const topScroll = document.getElementById('tableScrollTop');
      if (!tableContainer || !topContainer || !topScroll) return;

      topScroll.style.width = `${tableContainer.scrollWidth}px`;
      topContainer.scrollLeft = tableContainer.scrollLeft;

      if (!tableContainer._syncAttached) {
        tableContainer.addEventListener('scroll', () => {
          topContainer.scrollLeft = tableContainer.scrollLeft;
        });
        topContainer.addEventListener('scroll', () => {
          tableContainer.scrollLeft = topContainer.scrollLeft;
        });
        window.addEventListener('resize', () => {
          topScroll.style.width = `${tableContainer.scrollWidth}px`;
        });
        tableContainer._syncAttached = true;
      }
    }

    function openScatterModal(rowVar, colVar, rValue) {
      if (!correlationData || !correlationData.data) {
        return;
      }

      const modal = document.getElementById('scatterModal');
      const titleEl = document.getElementById('scatterTitle');

      const cacheKey = `${rowVar}__${colVar}`;
      let points = scatterPointsCache.get(cacheKey);
      if (!points) {
        points = correlationData.data
          .map(row => [row[rowVar], row[colVar]])
          .filter(([x, y]) => typeof x === 'number' && typeof y === 'number' && isFinite(x) && isFinite(y));
        scatterPointsCache.set(cacheKey, points);
      }

      titleEl.textContent = `Scatter Plot: ${rowVar} vs ${colVar}`;

      scatterState.rawPoints = points;
      scatterState.xVar = rowVar;
      scatterState.yVar = colVar;
      scatterState.xTransform = 'none';
      scatterState.yTransform = 'none';
      scatterState.fitType = 'none';
      scatterState.activeTransformAxis = 'x';
      scatterState.chart = null;
      scatterState.xRange = null;
      scatterState.yRange = null;

      resetScatterControls();
      refreshScatter();

      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
    }

    function setMatrixView(view) {
      currentView = view;
      const results = document.getElementById('resultsContainer');
      const heatmap = document.getElementById('heatmapContainer');
      const tableBtn = document.getElementById('viewTableBtn');
      const heatmapBtn = document.getElementById('viewHeatmapBtn');

      if (view === 'heatmap') {
        results.style.display = 'none';
        heatmap.style.display = 'block';
      } else {
        results.style.display = 'block';
        heatmap.style.display = 'none';
      }

      tableBtn.classList.toggle('active', view === 'table');
      heatmapBtn.classList.toggle('active', view === 'heatmap');

      if (currentHeaders && currentMatrix && view === 'heatmap') {
        buildHeatmapMatrix(currentHeaders, currentMatrix);
        applyThresholdFilter();
      }
    }

    function closeScatterModal() {
      const modal = document.getElementById('scatterModal');
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
    }

    function resetScatterControls() {
      document.getElementById('fit-none').classList.add('active');
      ['fit-linear','fit-polynomial','fit-exponential','fit-logarithmic','fit-power'].forEach(id => {
        document.getElementById(id).classList.remove('active');
      });
      setTransformAxis('x');
      ['transform-none','transform-ln','transform-inverse','transform-sqrt','transform-square'].forEach(id => {
        document.getElementById(id).classList.remove('active');
      });
      document.getElementById('transform-none').classList.add('active');
    }

    function transformValue(value, type) {
      if (!isFinite(value)) return null;
      switch (type) {
        case 'ln':
          return value > 0 ? Math.log(value) : null;
        case 'inverse':
          return value !== 0 ? 1 / value : null;
        case 'sqrt':
          return value >= 0 ? Math.sqrt(value) : null;
        case 'square':
          return value * value;
        default:
          return value;
      }
    }

    function getTransformedPoints() {
      return scatterState.rawPoints
        .map(([x, y]) => [
          transformValue(x, scatterState.xTransform),
          transformValue(y, scatterState.yTransform)
        ])
        .filter(([x, y]) => x !== null && y !== null && isFinite(x) && isFinite(y));
    }

    function getVisiblePoints() {
      const points = getTransformedPoints();
      if (!scatterState.xRange || !scatterState.yRange) {
        return points;
      }
      const xMin = Math.min(scatterState.xRange.min, scatterState.xRange.max);
      const xMax = Math.max(scatterState.xRange.min, scatterState.xRange.max);
      const yMin = Math.min(scatterState.yRange.min, scatterState.yRange.max);
      const yMax = Math.max(scatterState.yRange.min, scatterState.yRange.max);
      return points.filter(([x, y]) => x >= xMin && x <= xMax && y >= yMin && y <= yMax);
    }

    function refreshScatter() {
      const points = getTransformedPoints();
      renderScatterChart(points);
      initAxisControls(points);
      const visiblePoints = getVisiblePoints();
      updateScatterStats(visiblePoints);
      applyFit(scatterState.fitType, visiblePoints);
    }

    function updateScatterStats(points) {
      const n = points.length;
      const xs = points.map(p => p[0]);
      const ys = points.map(p => p[1]);
      const r = calculatePearson(xs, ys);
      const r2 = r * r;
      const p = calculatePValue(r, n);

      setScatterStatValue('scatterN', n);
      setScatterStatValue('scatterR', isFinite(r) ? r.toFixed(4) : '--');
      setScatterStatValue('scatterP', isFinite(p) ? p.toExponential(2) : '--');
      setScatterStatValue('scatterR2', isFinite(r2) ? r2.toFixed(4) : '--');
    }

    function setScatterStatValue(id, value) {
      const el = document.getElementById(id);
      el.textContent = value;
      el.classList.toggle('adjusted', isScatterAdjusted());
    }

    function isScatterAdjusted() {
      const axisAdjusted = hasAxisOverrides();
      const transformAdjusted = scatterState.xTransform !== 'none' || scatterState.yTransform !== 'none';
      const fitAdjusted = scatterState.fitType !== 'none';
      return axisAdjusted || transformAdjusted || fitAdjusted;
    }

    function hasAxisOverrides() {
      if (!scatterState.xRange || !scatterState.yRange || !scatterState.xRangeFull || !scatterState.yRangeFull) {
        return false;
      }
      const eps = 1e-9;
      const xChanged = Math.abs(scatterState.xRange.min - scatterState.xRangeFull.min) > eps ||
        Math.abs(scatterState.xRange.max - scatterState.xRangeFull.max) > eps;
      const yChanged = Math.abs(scatterState.yRange.min - scatterState.yRangeFull.min) > eps ||
        Math.abs(scatterState.yRange.max - scatterState.yRangeFull.max) > eps;
      return xChanged || yChanged;
    }

    function calculatePearson(x, y) {
      if (x.length < 2) return NaN;
      const meanX = x.reduce((a, b) => a + b, 0) / x.length;
      const meanY = y.reduce((a, b) => a + b, 0) / y.length;
      let num = 0, denX = 0, denY = 0;
      for (let i = 0; i < x.length; i++) {
        const dx = x[i] - meanX;
        const dy = y[i] - meanY;
        num += dx * dy;
        denX += dx * dx;
        denY += dy * dy;
      }
      return denX === 0 || denY === 0 ? NaN : num / Math.sqrt(denX * denY);
    }

    function calculatePValue(r, n) {
      if (!isFinite(r) || n < 3 || typeof jStat === 'undefined') return NaN;
      const t = r * Math.sqrt((n - 2) / (1 - r * r));
      return 2 * (1 - jStat.studentt.cdf(Math.abs(t), n - 2));
    }

    function renderScatterChart(points) {
      const series = [{
        type: 'scatter',
        name: 'Observations',
        data: points,
        color: 'rgba(255,165,120,0.75)',
        marker: { radius: 4 }
      }];

      if (!scatterState.chart) {
        scatterState.chart = Highcharts.chart('scatterChart', {
          chart: {
            type: 'scatter',
            backgroundColor: 'transparent',
            zoomType: 'xy'
          },
          title: { text: '' },
          xAxis: { title: { text: scatterState.xVar }, gridLineColor: 'rgba(255,255,255,0.08)' },
          yAxis: { title: { text: scatterState.yVar }, gridLineColor: 'rgba(255,255,255,0.08)' },
          legend: { itemStyle: { color: '#fff' } },
          credits: { enabled: false },
          series
        });
      } else {
        while (scatterState.chart.series.length) {
          scatterState.chart.series[0].remove(false);
        }
        series.forEach(s => scatterState.chart.addSeries(s, false));
        scatterState.chart.xAxis[0].setTitle({ text: scatterState.xVar });
        scatterState.chart.yAxis[0].setTitle({ text: scatterState.yVar });
        scatterState.chart.redraw();
      }
    }

    function initAxisControls(points) {
      if (!points.length) return;
      const xs = points.map(p => p[0]);
      const ys = points.map(p => p[1]);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);

      scatterState.xRange = { min: minX, max: maxX };
      scatterState.yRange = { min: minY, max: maxY };
      scatterState.xRangeFull = { min: minX, max: maxX };
      scatterState.yRangeFull = { min: minY, max: maxY };

      setupAxisRange('xMinRange', 'xMinVal', minX, maxX, minX);
      setupAxisRange('xMaxRange', 'xMaxVal', minX, maxX, maxX);
      setupAxisRange('yMinRange', 'yMinVal', minY, maxY, minY);
      setupAxisRange('yMaxRange', 'yMaxVal', minY, maxY, maxY);

      updateChartExtremes();
    }

    function setupAxisRange(id, labelId, min, max, value) {
      const input = document.getElementById(id);
      input.min = min;
      input.max = max;
      input.step = (max - min) / 100 || 1;
      input.value = value;
      document.getElementById(labelId).textContent = value.toFixed(2);
    }

    function updateAxisRange(axis, which, value) {
      const val = parseFloat(value);
      if (axis === 'x') {
        scatterState.xRange[which] = val;
        document.getElementById(which === 'min' ? 'xMinVal' : 'xMaxVal').textContent = val.toFixed(2);
      } else {
        scatterState.yRange[which] = val;
        document.getElementById(which === 'min' ? 'yMinVal' : 'yMaxVal').textContent = val.toFixed(2);
      }
      const visiblePoints = getVisiblePoints();
      updateScatterStats(visiblePoints);
      applyFit(scatterState.fitType, visiblePoints);
      updateScatterAdjustmentIndicator();
      updateChartExtremes();
    }

    function updateChartExtremes() {
      if (!scatterState.chart) return;
      const { min: xMin, max: xMax } = scatterState.xRange;
      const { min: yMin, max: yMax } = scatterState.yRange;
      scatterState.chart.xAxis[0].setExtremes(Math.min(xMin, xMax), Math.max(xMin, xMax), false);
      scatterState.chart.yAxis[0].setExtremes(Math.min(yMin, yMax), Math.max(yMin, yMax), false);
      scatterState.chart.redraw();
    }

    function applyFit(type, pointsOverride = null) {
      scatterState.fitType = type;
      ['fit-none','fit-linear','fit-polynomial','fit-exponential','fit-logarithmic','fit-power'].forEach(id => {
        document.getElementById(id).classList.remove('active');
      });
      document.getElementById(`fit-${type}`).classList.add('active');
      updateScatterAdjustmentIndicator();

      if (!scatterState.chart) return;
      const points = pointsOverride || getVisiblePoints();
      const fitResult = buildFitSeries(points, type);

      const existing = scatterState.chart.series.find(s => s.name === 'Fit');
      if (existing) {
        existing.remove(false);
      }
      if (fitResult && fitResult.series) {
        scatterState.chart.addSeries(fitResult.series, false);
      }
      updateFitEquation(type, fitResult ? fitResult.equation : null);
      scatterState.chart.redraw();
    }

    function buildFitSeries(points, type) {
      if (type === 'none' || points.length < 2 || typeof regression === 'undefined') {
        return null;
      }
      let model;
      if (type === 'linear') model = regression.linear(points);
      if (type === 'polynomial') model = regression.polynomial(points, { order: 2 });
      if (type === 'exponential') model = regression.exponential(points);
      if (type === 'logarithmic') model = regression.logarithmic(points);
      if (type === 'power') model = regression.power(points);
      if (!model || !model.predict) return null;

      const xs = points.map(p => p[0]);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const steps = 50;
      const line = [];
      for (let i = 0; i <= steps; i++) {
        const x = minX + (maxX - minX) * (i / steps);
        const y = model.predict(x)[1];
        if (isFinite(y)) line.push([x, y]);
      }

      return {
        series: {
          name: 'Fit',
          type: 'line',
          data: line,
          color: 'rgba(120,200,255,0.9)',
          marker: { enabled: false },
          lineWidth: 2
        },
        equation: model.string || null
      };
    }

    function updateFitEquation(type, equation) {
      const el = document.getElementById('fitEquation');
      if (!el) return;
      if (type === 'none' || !equation) {
        el.textContent = 'Equation: ‚Äî';
      } else {
        el.textContent = `Equation: ${equation}`;
      }
    }

    function setTransformAxis(axis) {
      scatterState.activeTransformAxis = axis;
      document.getElementById('transform-x-tab').classList.toggle('active', axis === 'x');
      document.getElementById('transform-y-tab').classList.toggle('active', axis === 'y');
      updateTransformButtons();
    }

    function applyTransformation(type) {
      if (scatterState.activeTransformAxis === 'x') {
        scatterState.xTransform = type;
      } else {
        scatterState.yTransform = type;
      }

      updateTransformButtons();
      updateScatterAdjustmentIndicator();
      refreshScatter();
    }

    function updateScatterAdjustmentIndicator() {
      ['scatterN','scatterR','scatterP','scatterR2'].forEach(id => {
        const el = document.getElementById(id);
        if (el) {
          el.classList.toggle('adjusted', isScatterAdjusted());
        }
      });
    }

    function updateTransformButtons() {
      const activeType = scatterState.activeTransformAxis === 'x'
        ? scatterState.xTransform
        : scatterState.yTransform;
      ['transform-none','transform-ln','transform-inverse','transform-sqrt','transform-square'].forEach(id => {
        document.getElementById(id).classList.remove('active');
      });
      document.getElementById(`transform-${activeType}`).classList.add('active');
    }

    /**
     * Calculate correlation matrix
     */
    function calculateCorrelationMatrix(data, headers, type) {
      const n = headers.length;
      const matrix = Array(n).fill(null).map(() => Array(n));

      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          const col1Data = data.map(row => row[headers[i]]);
          const col2Data = data.map(row => row[headers[j]]);

          let r, p, validN;

          // Force diagonal to 1.000 for all correlation types
          if (i === j) {
            validN = col1Data.filter(v => typeof v === 'number' && !isNaN(v)).length;
            r = 1;
            p = 0;
          } else if (type === 'Pearson') {
            ({ r, p, n: validN } = calculatePearsonCorrelation(col1Data, col2Data));
          } else if (type === 'Spearman') {
            ({ r, p, n: validN } = calculateSpearmanCorrelation(col1Data, col2Data));
          } else if (type === 'Kendall') {
            ({ r, p, n: validN } = calculateKendallCorrelation(col1Data, col2Data));
          } else if (type === 'Biweight') {
            ({ r, p, n: validN } = calculateBiweightMidcorrelation(col1Data, col2Data));
          }

          matrix[i][j] = { r, p, n: validN };
        }
      }

      return matrix;
    }

    /**
     * Calculate Pearson correlation
     */
    function calculatePearsonCorrelation(x, y) {
      const pairs = x.map((xi, i) => [xi, y[i]]).filter(([xi, yi]) => 
        typeof xi === 'number' && typeof yi === 'number' && !isNaN(xi) && !isNaN(yi)
      );

      const n = pairs.length;
      if (n < 2) return { r: 0, p: null, n: 0 };

      const xVals = pairs.map(p => p[0]);
      const yVals = pairs.map(p => p[1]);

      const meanX = xVals.reduce((a, b) => a + b, 0) / n;
      const meanY = yVals.reduce((a, b) => a + b, 0) / n;

      let num = 0, denX = 0, denY = 0;
      for (let i = 0; i < n; i++) {
        const dx = xVals[i] - meanX;
        const dy = yVals[i] - meanY;
        num += dx * dy;
        denX += dx * dx;
        denY += dy * dy;
      }

      const r = denX === 0 || denY === 0 ? 0 : num / Math.sqrt(denX * denY);

      // Calculate p-value using t-distribution approximation
      const t = r * Math.sqrt(n - 2) / Math.sqrt(1 - r * r);
      const p = 2 * (1 - tDistCDF(Math.abs(t), n - 2));

      return { r, p, n };
    }

    /**
     * Calculate Spearman correlation
     */
    function calculateSpearmanCorrelation(x, y) {
      const pairs = x.map((xi, i) => [xi, y[i]]).filter(([xi, yi]) => 
        typeof xi === 'number' && typeof yi === 'number' && !isNaN(xi) && !isNaN(yi)
      );

      const n = pairs.length;
      if (n < 2) return { r: 0, p: null, n: 0 };

      const xRanks = getRanks(pairs.map(p => p[0]));
      const yRanks = getRanks(pairs.map(p => p[1]));

      return calculatePearsonCorrelation(xRanks, yRanks);
    }

    /**
     * Calculate Kendall correlation
     */
    function calculateKendallCorrelation(x, y) {
      const pairs = x.map((xi, i) => [xi, y[i]]).filter(([xi, yi]) => 
        typeof xi === 'number' && typeof yi === 'number' && !isNaN(xi) && !isNaN(yi)
      );

      const n = pairs.length;
      if (n < 2) return { r: 0, p: null, n: 0 };

      let concordant = 0;
      let discordant = 0;

      for (let i = 0; i < n - 1; i++) {
        for (let j = i + 1; j < n; j++) {
          const dx = pairs[j][0] - pairs[i][0];
          const dy = pairs[j][1] - pairs[i][1];

          if (dx * dy > 0) concordant++;
          else if (dx * dy < 0) discordant++;
        }
      }

      const tau = (concordant - discordant) / (n * (n - 1) / 2);

      // Approximate p-value
      const z = tau * Math.sqrt(n * (n - 1) / (2 * (2 * n + 5) / 9));
      const p = 2 * (1 - normalCDF(Math.abs(z)));

      return { r: tau, p, n };
    }

    /**
     * Calculate Biweight Midcorrelation (robust, downweights outliers)
     */
    function calculateBiweightMidcorrelation(x, y) {
      const pairs = x.map((xi, i) => [xi, y[i]]).filter(([xi, yi]) =>
        typeof xi === 'number' && typeof yi === 'number' && isFinite(xi) && isFinite(yi)
      );
      const n = pairs.length;
      if (n < 2) return { r: 0, p: null, n: 0 };

      const xs = pairs.map(p => p[0]);
      const ys = pairs.map(p => p[1]);
      const medX = median(xs);
      const medY = median(ys);
      const madX = mad(xs, medX);
      const madY = mad(ys, medY);
      if (madX === 0 || madY === 0) return { r: 0, p: null, n };

      const tunedX = xs.map(v => (v - medX) / (9 * madX));
      const tunedY = ys.map(v => (v - medY) / (9 * madY));
      const wX = tunedX.map(u => Math.abs(u) < 1 ? Math.pow(1 - u * u, 2) : 0);
      const wY = tunedY.map(u => Math.abs(u) < 1 ? Math.pow(1 - u * u, 2) : 0);

      const xPrime = xs.map((v, i) => (v - medX) * wX[i]);
      const yPrime = ys.map((v, i) => (v - medY) * wY[i]);

      const num = xPrime.reduce((sum, v, i) => sum + v * yPrime[i], 0);
      const denX = Math.sqrt(xPrime.reduce((sum, v) => sum + v * v, 0));
      const denY = Math.sqrt(yPrime.reduce((sum, v) => sum + v * v, 0));
      const r = denX === 0 || denY === 0 ? 0 : num / (denX * denY);

      const t = r * Math.sqrt(n - 2) / Math.sqrt(1 - r * r);
      const p = 2 * (1 - tDistCDF(Math.abs(t), n - 2));

      return { r, p, n };
    }

    /**
     * Get ranks for Spearman
     */
    function getRanks(arr) {
      const sorted = arr.map((val, idx) => ({ val, idx })).sort((a, b) => a.val - b.val);
      const ranks = new Array(arr.length);

      for (let i = 0; i < sorted.length; i++) {
        let j = i;
        while (j < sorted.length - 1 && sorted[j].val === sorted[j + 1].val) {
          j++;
        }

        const avgRank = (i + j + 2) / 2;
        for (let k = i; k <= j; k++) {
          ranks[sorted[k].idx] = avgRank;
        }

        i = j;
      }

      return ranks;
    }

    function median(arr) {
      const sorted = arr.slice().sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      if (sorted.length % 2 === 0) {
        return (sorted[mid - 1] + sorted[mid]) / 2;
      }
      return sorted[mid];
    }

    function mad(arr, med) {
      const deviations = arr.map(v => Math.abs(v - med));
      return median(deviations) || 0;
    }

    /**
     * T-distribution CDF approximation
     */
    function tDistCDF(t, df) {
      const x = df / (df + t * t);
      return 1 - 0.5 * betaIncomplete(df / 2, 0.5, x);
    }

    /**
     * Normal CDF approximation
     */
    function normalCDF(x) {
      return 0.5 * (1 + erf(x / Math.sqrt(2)));
    }

    /**
     * Error function approximation
     */
    function erf(x) {
      const sign = x >= 0 ? 1 : -1;
      x = Math.abs(x);

      const a1 = 0.254829592;
      const a2 = -0.284496736;
      const a3 = 1.421413741;
      const a4 = -1.453152027;
      const a5 = 1.061405429;
      const p = 0.3275911;

      const t = 1 / (1 + p * x);
      const y = 1 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);

      return sign * y;
    }

    /**
     * Incomplete beta function approximation
     */
    function betaIncomplete(a, b, x) {
      if (x === 0) return 0;
      if (x === 1) return 1;
      
      // Simplified approximation
      return Math.pow(x, a) * Math.pow(1 - x, b);
    }

    /**
     * Recalculate with new correlation type
     */
    function recalculate() {
      const selected = document.querySelector('input[name="corrType"]:checked');
      currentType = selected ? selected.value : 'Pearson';
      console.log('Recalculating with type:', currentType);
      buildCorrelationMatrix();
    }

    /**
     * Toggle display of p-values and n-values
     */
    function toggleDisplay() {
      const showPValue = document.getElementById('showPValue').checked;
      const showN = document.getElementById('showN').checked;

      const pValues = document.querySelectorAll('.p-value');
      const nValues = document.querySelectorAll('.n-value');

      pValues.forEach(el => el.style.display = showPValue ? 'block' : 'none');
      nValues.forEach(el => el.style.display = showN ? 'block' : 'none');
    }

    /**
     * Update threshold slider
     */
    function updateThreshold(value) {
      document.getElementById('thresholdValue').textContent = parseFloat(value).toFixed(2);
      applyThresholdFilter();
    }

    /**
     * Apply threshold filter (highlight cells)
     */
    function applyThresholdFilter() {
      const threshold = parseFloat(document.getElementById('thresholdSlider').value);
      const allCells = document.querySelectorAll('tbody td');
      const heatmapCells = document.querySelectorAll('.heatmap-cell');

      allCells.forEach(cell => {
        const corrValueEl = cell.querySelector('.corr-value');
        if (corrValueEl) {
          const corrValue = parseFloat(corrValueEl.getAttribute('data-corr'));
          const isDiagonal = cell.classList.contains('diagonal-cell');
          const isPerfect = Math.abs(Math.abs(corrValue) - 1.0) < 0.001;
          
          if (Math.abs(corrValue) >= threshold && !isDiagonal && !isPerfect && threshold > 0) {
            cell.classList.add('threshold-highlight');
          } else {
            cell.classList.remove('threshold-highlight');
          }
        }
      });

      heatmapCells.forEach(cell => {
        const corrValue = parseFloat(cell.getAttribute('data-corr'));
        const isDiagonal = cell.classList.contains('diagonal-cell');
        const isPerfect = Math.abs(Math.abs(corrValue) - 1.0) < 0.001;
        if (Math.abs(corrValue) >= threshold && !isDiagonal && !isPerfect && threshold > 0) {
          cell.classList.add('threshold-highlight');
        } else {
          cell.classList.remove('threshold-highlight');
        }
      });
    }

    function buildHeatmapMatrix(headers, matrix) {
      const head = document.getElementById('heatmapHead');
      const body = document.getElementById('heatmapBody');
      if (!head || !body) return;

      head.innerHTML = '';
      body.innerHTML = '';

      const headerRow = document.createElement('tr');
      const cornerTh = document.createElement('th');
      cornerTh.textContent = 'Variable';
      headerRow.appendChild(cornerTh);

      headers.forEach(col => {
        const th = document.createElement('th');
        th.textContent = col;
        headerRow.appendChild(th);
      });
      head.appendChild(headerRow);

      headers.forEach((rowCol, i) => {
        const row = document.createElement('tr');
        const rowTh = document.createElement('td');
        rowTh.textContent = rowCol;
        row.appendChild(rowTh);

        headers.forEach((colCol, j) => {
          const td = document.createElement('td');
          const corrData = matrix[i][j];
          const value = corrData.r;
          td.classList.add('heatmap-cell');
          if (i === j) {
            td.classList.add('diagonal-cell');
          }
          td.setAttribute('data-corr', value);
          td.textContent = value.toFixed(2);
          td.style.background = getHeatmapColor(value);
          td.style.color = getHeatmapTextColor(value);
          row.appendChild(td);
        });

        body.appendChild(row);
      });
    }

    function getHeatmapColor(value) {
      const v = Math.max(-1, Math.min(1, value));
      const intensity = Math.abs(v);
      const lightness = 20 + (1 - intensity) * 55;
      if (v >= 0) {
        return `hsl(24, 85%, ${lightness}%)`;
      }
      return `hsl(200, 75%, ${lightness}%)`;
    }

    function getHeatmapTextColor(value) {
      return Math.abs(value) > 0.45 ? '#0c1624' : '#e7edf8';
    }
  </script>
</body>
</html>
