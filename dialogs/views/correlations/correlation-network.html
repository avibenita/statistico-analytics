<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>Correlation Network</title>
  
  <!-- Office.js -->
  <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
  
  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" rel="stylesheet"/>
  
  <!-- D3.js for network visualization -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  
  <!-- Shared Header -->
  <link rel="stylesheet" href="../shared-header.css">
  <script src="../shared-header.js"></script>

  <style>
    :root{
      --surface-0:#0c1624;
      --surface-1:#1a1f2e;
      --surface-2:#242938;
      --border:#2d3748;
      --accent-1:rgb(255,165,120);
      --accent-2:rgb(120,200,255);
      --text-primary:#fff;
      --text-secondary:rgba(255,255,255,0.8);
      --text-muted:rgba(255,255,255,0.5);
    }

    *{
      margin:0;
      padding:0;
      box-sizing:border-box;
    }

    body{
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,sans-serif;
      background:linear-gradient(135deg, var(--surface-0) 0%, #1a2332 100%);
      color:var(--text-primary);
      line-height:1.6;
      padding:0;
      margin:0;
      min-height:100vh;
      overflow:hidden;
    }

    .container{
      max-width:100%;
      margin:0;
      padding:0;
      display:flex;
      flex-direction:column;
      height:100vh;
    }

    .results-container{
      flex:1;
      padding:20px;
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }

    .controls{
      background:var(--surface-1);
      padding:15px 20px;
      border-radius:10px;
      margin-bottom:15px;
      border:2px solid var(--border);
      box-shadow:0 4px 20px rgba(0,0,0,0.3);
      display:flex;
      gap:20px;
      align-items:center;
      flex-wrap:wrap;
    }

    .control-group{
      display:flex;
      align-items:center;
      gap:12px;
    }

    .slider-label{
      font-size:14px;
      color:var(--text-secondary);
      font-weight:600;
      white-space:nowrap;
    }

    input[type="range"]{
      min-width:150px;
      height:8px;
      border-radius:5px;
      background:linear-gradient(90deg, var(--surface-2) 0%, var(--accent-1) 100%);
      outline:none;
      -webkit-appearance:none;
    }

    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width:20px;
      height:20px;
      border-radius:50%;
      background:linear-gradient(135deg, var(--accent-1), var(--accent-2));
      cursor:pointer;
      box-shadow:0 2px 10px rgba(255,165,120,0.5);
      transition:all 0.3s ease;
    }

    input[type="range"]::-webkit-slider-thumb:hover{
      transform:scale(1.2);
      box-shadow:0 4px 15px rgba(255,165,120,0.7);
    }

    input[type="range"]::-moz-range-thumb{
      width:20px;
      height:20px;
      border-radius:50%;
      background:linear-gradient(135deg, var(--accent-1), var(--accent-2));
      cursor:pointer;
      border:none;
      box-shadow:0 2px 10px rgba(255,165,120,0.5);
      transition:all 0.3s ease;
    }

    input[type="range"]::-moz-range-thumb:hover{
      transform:scale(1.2);
      box-shadow:0 4px 15px rgba(255,165,120,0.7);
    }

    .slider-value{
      font-size:16px;
      color:var(--accent-1);
      font-weight:700;
      min-width:50px;
      text-align:right;
    }

    .checkbox-label{
      display:flex;
      align-items:center;
      gap:8px;
      cursor:pointer;
      font-size:14px;
      color:var(--text-secondary);
      transition:color 0.3s ease;
    }

    .checkbox-label:hover{
      color:var(--text-primary);
    }

    .checkbox-label input[type="checkbox"]{
      width:18px;
      height:18px;
      cursor:pointer;
      accent-color:var(--accent-1);
    }

    .checkbox-label:has(input:checked){
      color:var(--accent-1);
      font-weight:600;
    }

    .network-container{
      flex:1;
      min-height:500px;
      background:var(--surface-1);
      border-radius:10px;
      border:2px solid var(--border);
      position:relative;
      overflow:hidden;
      box-shadow:0 4px 20px rgba(0,0,0,0.3);
    }

    #networkSVG{
      width:100%;
      height:100%;
      cursor:move;
      touch-action:none;
    }

    .network-link{
      stroke-opacity:0.6;
      transition:all 0.3s;
    }

    .network-link.dimmed{
      stroke-opacity:0.1;
    }

    .network-node{
      cursor:pointer;
      transition:all 0.2s;
    }

    .network-node:hover{
      filter:brightness(1.3);
    }

    .network-label{
      font-size:12px;
      font-weight:600;
      fill:var(--text-primary);
      text-anchor:middle;
      pointer-events:none;
      user-select:none;
    }

    .network-corr-label{
      font-size:10px;
      fill:var(--text-secondary);
      pointer-events:none;
      text-anchor:middle;
    }

    .network-corr-label.dimmed{
      opacity:0.2;
    }

    .loading{
      text-align:center;
      padding:60px 20px;
      color:var(--text-secondary);
    }

    .loading i{
      font-size:48px;
      color:var(--accent-1);
      animation:spin 1s linear infinite;
    }

    @keyframes spin{
      0%{transform:rotate(0deg);}
      100%{transform:rotate(360deg);}
    }

    .loading p{
      margin-top:20px;
      font-size:18px;
    }

    /* Responsive Design */
    @media (max-width: 1024px){
      .controls{
        flex-direction:column;
        align-items:flex-start;
      }
      .network-container{
        min-height:400px;
      }
      .network-label{
        font-size:11px;
      }
      .network-node{
        r:18;
      }
    }

    @media (max-width: 768px){
      .results-container{
        padding:15px;
      }
      .controls{
        padding:12px 15px;
      }
      .network-container{
        min-height:400px;
        margin:0 -10px;
        border-radius:0;
      }
      .network-label{
        font-size:11px;
      }
      .network-node{
        r:18;
      }
    }

    @media (max-width: 480px){
      .results-container{
        padding:10px;
      }
      .network-container{
        min-height:300px;
        margin:0 -5px;
      }
      .network-label{
        font-size:10px;
      }
      .network-corr-label{
        font-size:9px;
      }
      .network-node{
        r:15;
      }
    }

    @media (orientation: landscape) and (max-height: 600px){
      .network-container{
        min-height:350px;
        max-height:calc(100vh - 180px);
      }
    }

    @media (min-width: 768px) and (max-width: 1024px){
      .network-container{
        min-height:450px;
      }
      .network-node{
        r:18;
      }
      .network-label{
        font-size:11px;
      }
    }
  </style>
</head>
<body>
  <div class="container" id="mainContainer" style="display:none;">
    <div id="header-container"></div>

    <div class="results-container">
      <div class="controls">
        <div class="control-group">
          <span class="slider-label">Highlight r ‚â•</span>
          <input type="range" id="networkThresholdSlider" min="0" max="1" step="0.05" value="0" oninput="updateNetworkThreshold(this.value)">
          <span class="slider-value" id="networkThresholdValue">0.00</span>
        </div>

        <div class="control-group">
          <label class="checkbox-label">
            <input type="checkbox" id="showCorrValues" checked onchange="toggleCorrValues()">
            <span>Show r</span>
          </label>
        </div>
      </div>

      <div id="networkLoadingMessage" class="loading">
        <i class="fa-solid fa-spinner"></i>
        <p>Loading correlation network...</p>
      </div>

      <div class="network-container" id="networkContainer" style="display:none;">
        <svg id="networkSVG"></svg>
      </div>
    </div>
  </div>

  <script>
    let correlationData = null;
    let networkSimulation = null;
    let networkThreshold = 0;
    let showCorr = true;
    let currentMatrix = null;
    let currentVarNames = null;

    // Handle window resize for responsiveness
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        if (currentVarNames && currentMatrix) {
          console.log('üîÑ Redrawing network due to resize');
          drawNetwork(currentVarNames, currentMatrix);
        }
      }, 250);
    });

    // Initialize Office.js
    Office.onReady(function(info) {
      console.log('Office initialized in correlation network dialog');
      
      // Initialize shared header
      if (typeof StatisticoHeader !== 'undefined') {
        StatisticoHeader.init('correlation-network', 'Correlation Network', 0, 'correlations');
      }
      
      // Listen for messages from parent
      Office.context.ui.addHandlerAsync(
        Office.EventType.DialogParentMessageReceived,
        onMessageFromParent
      );
      
      // Notify parent that dialog is ready
      Office.context.ui.messageParent(JSON.stringify({
        action: 'ready'
      }));
    });

    /**
     * Handle messages from parent taskpane
     */
    function onMessageFromParent(arg) {
      try {
        const message = JSON.parse(arg.message);
        console.log('Received message from parent:', message);

        if (message.type === 'CORRELATION_DATA' && message.payload) {
          correlationData = message.payload;
          console.log('Correlation data received:', correlationData);
          renderNetwork();
        }
      } catch (error) {
        console.error('Error parsing message:', error);
      }
    }

    /**
     * Render correlation network
     */
    function renderNetwork() {
      const container = document.getElementById('mainContainer');
      const loading = document.getElementById('networkLoadingMessage');
      const networkContainer = document.getElementById('networkContainer');

      console.log('üîç Validating correlation data...');
      console.log('  correlationData exists:', !!correlationData);
      console.log('  correlationData.headers exists:', !!correlationData?.headers);
      console.log('  headers length:', correlationData?.headers?.length);
      console.log('  Full data structure:', correlationData);

      if (!correlationData || !correlationData.headers || correlationData.headers.length === 0) {
        console.error('‚ùå Invalid correlation data - requirements not met');
        loading.innerHTML = '<i class="fa-solid fa-exclamation-triangle"></i><p>No correlation data available</p>';
        container.style.display = 'flex';
        return;
      }

      console.log('‚úÖ Rendering network with data:', correlationData);
      
      const { headers, data } = correlationData;

      // Calculate correlation matrix
      const matrix = calculateCorrelationMatrix(data, headers, 'Pearson');

      // Store for resize handling
      currentVarNames = headers;
      currentMatrix = matrix;

      // Update header with correct sample size
      const sampleSize = data ? data.length : 0;
      if (typeof StatisticoHeader !== 'undefined') {
        StatisticoHeader.sampleSize = sampleSize;
        StatisticoHeader.variableName = `${headers.length} Variables`;
        StatisticoHeader.render();
      }

      // Hide loading, show network
      loading.style.display = 'none';
      networkContainer.style.display = 'flex';
      container.style.display = 'flex';

      // Draw network
      drawNetwork(headers, matrix);
    }

    /**
     * Draw D3.js network visualization
     */
    function drawNetwork(varNames, matrix) {
      const container = document.getElementById('networkContainer');
      const width = container.clientWidth || window.innerWidth - 40;
      const height = Math.max(container.clientHeight || 600, 600);

      console.log('üìê Network dimensions:', { width, height, containerWidth: container.clientWidth, containerHeight: container.clientHeight });

      if (width === 0 || height === 0) {
        console.error('‚ùå Invalid container dimensions, retrying in 100ms...');
        setTimeout(() => drawNetwork(varNames, matrix), 100);
        return;
      }

      // Clear existing
      d3.select("#networkSVG").selectAll("*").remove();

      const svg = d3.select("#networkSVG")
        .attr("width", width)
        .attr("height", height);

      // Create nodes
      const nodes = varNames.map(name => ({ id: name }));

      // Create links (only if |r| >= 0.3 to avoid clutter)
      const links = [];
      for (let i = 0; i < varNames.length; i++) {
        for (let j = i + 1; j < varNames.length; j++) {
          const value = matrix[i][j].r;
          if (value !== null && Math.abs(value) >= 0.3) {
            links.push({
              source: varNames[i],
              target: varNames[j],
              value: value
            });
          }
        }
      }

      console.log(`üìä Network: ${nodes.length} nodes, ${links.length} links`);

      // Create force simulation
      networkSimulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(d => 150 * (1 - Math.abs(d.value))))
        .force("charge", d3.forceManyBody().strength(-500))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("collision", d3.forceCollide().radius(40));

      const g = svg.append("g");

      // Add zoom
      const zoom = d3.zoom()
        .scaleExtent([0.5, 3])
        .on("zoom", (event) => {
          g.attr("transform", event.transform);
        });
      svg.call(zoom);

      // Draw links
      const link = g.append("g")
        .selectAll("line")
        .data(links)
        .enter().append("line")
        .attr("class", "network-link")
        .attr("stroke", d => d.value > 0 ? "var(--accent-2)" : "var(--accent-1)")
        .attr("stroke-width", d => Math.abs(d.value) * 5)
        .attr("data-value", d => Math.abs(d.value));

      // Link labels
      const linkLabels = g.append("g")
        .selectAll("text")
        .data(links)
        .enter().append("text")
        .attr("class", "network-corr-label")
        .text(d => d.value.toFixed(2))
        .style("display", showCorr ? "block" : "none");

      // Nodes
      const node = g.append("g")
        .selectAll("circle")
        .data(nodes)
        .enter().append("circle")
        .attr("class", "network-node")
        .attr("r", 20)
        .attr("fill", "var(--accent-1)")
        .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));

      // Node labels
      const labels = g.append("g")
        .selectAll("text")
        .data(nodes)
        .enter().append("text")
        .attr("class", "network-label")
        .text(d => d.id)
        .attr("dy", 35);

      // Update positions
      networkSimulation.on("tick", () => {
        link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        linkLabels
          .attr("x", d => (d.source.x + d.target.x) / 2)
          .attr("y", d => (d.source.y + d.target.y) / 2);

        node
          .attr("cx", d => d.x)
          .attr("cy", d => d.y);

        labels
          .attr("x", d => d.x)
          .attr("y", d => d.y);
      });

      // Store references
      window.networkElements = { link, linkLabels };
      applyNetworkThreshold(networkThreshold);
    }

    function dragstarted(event, d) {
      if (!event.active) networkSimulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragged(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }

    function dragended(event, d) {
      if (!event.active) networkSimulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }

    function updateNetworkThreshold(value) {
      networkThreshold = parseFloat(value);
      document.getElementById('networkThresholdValue').textContent = value;
      applyNetworkThreshold(networkThreshold);
    }

    function applyNetworkThreshold(threshold) {
      if (!window.networkElements) return;
      const { link, linkLabels } = window.networkElements;
      link.classed("dimmed", d => Math.abs(d.value) < threshold);
      linkLabels.classed("dimmed", d => Math.abs(d.value) < threshold);
    }

    function toggleCorrValues() {
      showCorr = document.getElementById('showCorrValues').checked;
      if (window.networkElements) {
        window.networkElements.linkLabels.style("display", showCorr ? "block" : "none");
      }
    }

    /**
     * Calculate correlation matrix (Pearson only for network)
     */
    function calculateCorrelationMatrix(data, headers, type) {
      const n = headers.length;
      const matrix = Array(n).fill(null).map(() => Array(n));

      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          const col1Data = data.map(row => row[headers[i]]);
          const col2Data = data.map(row => row[headers[j]]);

          const { r, p, n: validN } = calculatePearsonCorrelation(col1Data, col2Data);
          matrix[i][j] = { r, p, n: validN };
        }
      }

      return matrix;
    }

    /**
     * Calculate Pearson correlation
     */
    function calculatePearsonCorrelation(x, y) {
      const pairs = x.map((xi, i) => [xi, y[i]]).filter(([xi, yi]) => 
        typeof xi === 'number' && typeof yi === 'number' && !isNaN(xi) && !isNaN(yi)
      );

      const n = pairs.length;
      if (n < 2) return { r: 0, p: null, n: 0 };

      const xVals = pairs.map(p => p[0]);
      const yVals = pairs.map(p => p[1]);

      const meanX = xVals.reduce((a, b) => a + b, 0) / n;
      const meanY = yVals.reduce((a, b) => a + b, 0) / n;

      let num = 0, denX = 0, denY = 0;
      for (let i = 0; i < n; i++) {
        const dx = xVals[i] - meanX;
        const dy = yVals[i] - meanY;
        num += dx * dy;
        denX += dx * dx;
        denY += dy * dy;
      }

      const r = denX === 0 || denY === 0 ? 0 : num / Math.sqrt(denX * denY);

      // Calculate p-value using t-distribution approximation
      const t = r * Math.sqrt(n - 2) / Math.sqrt(1 - r * r);
      const p = 2 * (1 - tDistCDF(Math.abs(t), n - 2));

      return { r, p, n };
    }

    /**
     * T-distribution CDF approximation
     */
    function tDistCDF(t, df) {
      const x = df / (df + t * t);
      return 1 - 0.5 * betaIncomplete(df / 2, 0.5, x);
    }

    /**
     * Incomplete beta function approximation
     */
    function betaIncomplete(a, b, x) {
      if (x === 0) return 0;
      if (x === 1) return 1;
      return Math.pow(x, a) * Math.pow(1 - x, b);
    }

    console.log('‚úÖ Correlation Network Dialog loaded');
  </script>
</body>
</html>
