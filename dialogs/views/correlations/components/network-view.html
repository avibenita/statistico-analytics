<div class="controls">
  <div class="control-group">
    <span class="slider-label">Highlight r ‚â•</span>
    <input type="range" id="networkThresholdSlider" min="0" max="1" step="0.05" value="0" oninput="updateNetworkThreshold(this.value)">
    <span class="slider-value" id="networkThresholdValue">0.00</span>
  </div>

  <div class="control-group">
    <label class="checkbox-label">
      <input type="checkbox" id="showCorrValues" checked onchange="toggleCorrValues()">
      <span>Show r</span>
    </label>
  </div>
</div>

<div id="networkLoadingMessage" class="loading" style="display:none;">
  <i class="fa-solid fa-spinner"></i>
  <p>Loading correlation network...</p>
</div>

<div class="network-container" id="networkContainer" style="display:none;">
  <svg id="networkSVG"></svg>
</div>

<script>
  // Network View Logic
  (function() {
    let networkSimulation = null;
    let networkThreshold = 0;
    let showCorr = true;
    let networkElements = null;

    window.initializeNetworkView = function(data) {
      console.log('üåê Initializing Network View');
      window.networkData = data;
      renderNetwork();
    };

    function renderNetwork() {
      if (!window.networkData || !window.networkData.headers || !window.networkData.data) {
        console.error('Invalid correlation data for network');
        return;
      }

      const headers = window.networkData.headers;
      const data = window.networkData.data;

      document.getElementById('networkLoadingMessage').style.display = 'none';
      document.getElementById('networkContainer').style.display = 'flex';

      const matrix = calculateNetworkCorrelationMatrix(data, headers);
      drawNetwork(headers, matrix);
    }

    function calculateNetworkCorrelationMatrix(data, headers) {
      const n = headers.length;
      const matrix = [];

      for (let i = 0; i < n; i++) {
        matrix[i] = [];
        for (let j = 0; j < n; j++) {
          if (i === j) {
            matrix[i][j] = { r: 1.000 };
          } else {
            const result = calculateNetworkCorrelation(data, headers[i], headers[j]);
            matrix[i][j] = result;
          }
        }
      }

      return matrix;
    }

    function calculateNetworkCorrelation(data, var1, var2) {
      const pairs = [];
      data.forEach(row => {
        const x = row[var1];
        const y = row[var2];
        if (typeof x === 'number' && typeof y === 'number' && !isNaN(x) && !isNaN(y)) {
          pairs.push([x, y]);
        }
      });

      if (pairs.length < 2) {
        return { r: null };
      }

      const xValues = pairs.map(p => p[0]);
      const yValues = pairs.map(p => p[1]);

      const n = xValues.length;
      const sumX = xValues.reduce((a, b) => a + b, 0);
      const sumY = yValues.reduce((a, b) => a + b, 0);
      const sumXY = xValues.reduce((sum, x, i) => sum + x * yValues[i], 0);
      const sumX2 = xValues.reduce((sum, x) => sum + x * x, 0);
      const sumY2 = yValues.reduce((sum, y) => sum + y * y, 0);

      const numerator = n * sumXY - sumX * sumY;
      const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

      if (denominator === 0) return { r: null };
      return { r: numerator / denominator };
    }

    function drawNetwork(varNames, matrix) {
      const container = document.getElementById('networkContainer');
      const width = container.clientWidth;
      const height = Math.max(container.clientHeight, 600);

      d3.select("#networkSVG").selectAll("*").remove();

      const svg = d3.select("#networkSVG")
        .attr("width", width)
        .attr("height", height);

      const nodes = varNames.map(name => ({ id: name }));
      const links = [];

      for (let i = 0; i < varNames.length; i++) {
        for (let j = i + 1; j < varNames.length; j++) {
          const value = matrix[i][j].r;
          if (value !== null && Math.abs(value) >= 0.3) {
            links.push({
              source: varNames[i],
              target: varNames[j],
              value: value
            });
          }
        }
      }

      console.log(`üìä Network: ${nodes.length} nodes, ${links.length} links`);

      networkSimulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(d => 150 * (1 - Math.abs(d.value))))
        .force("charge", d3.forceManyBody().strength(-500))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("collision", d3.forceCollide().radius(40));

      const g = svg.append("g");

      const zoom = d3.zoom()
        .scaleExtent([0.5, 3])
        .on("zoom", (event) => {
          g.attr("transform", event.transform);
        });
      svg.call(zoom);

      const link = g.append("g")
        .selectAll("line")
        .data(links)
        .enter().append("line")
        .attr("class", "network-link")
        .attr("stroke", d => d.value > 0 ? "var(--accent-2)" : "var(--accent-1)")
        .attr("stroke-width", d => Math.abs(d.value) * 5)
        .attr("data-value", d => Math.abs(d.value));

      const linkLabels = g.append("g")
        .selectAll("text")
        .data(links)
        .enter().append("text")
        .attr("class", "network-corr-label")
        .text(d => d.value.toFixed(2))
        .style("display", showCorr ? "block" : "none");

      const node = g.append("g")
        .selectAll("circle")
        .data(nodes)
        .enter().append("circle")
        .attr("class", "network-node")
        .attr("r", 20)
        .attr("fill", "var(--accent-1)")
        .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));

      const labels = g.append("g")
        .selectAll("text")
        .data(nodes)
        .enter().append("text")
        .attr("class", "network-label")
        .text(d => d.id)
        .attr("dy", 35);

      networkSimulation.on("tick", () => {
        link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        linkLabels
          .attr("x", d => (d.source.x + d.target.x) / 2)
          .attr("y", d => (d.source.y + d.target.y) / 2);

        node
          .attr("cx", d => d.x)
          .attr("cy", d => d.y);

        labels
          .attr("x", d => d.x)
          .attr("y", d => d.y);
      });

      networkElements = { link, linkLabels };
      applyNetworkThreshold(networkThreshold);
    }

    function dragstarted(event, d) {
      if (!event.active) networkSimulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragged(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }

    function dragended(event, d) {
      if (!event.active) networkSimulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }

    window.updateNetworkThreshold = function(value) {
      networkThreshold = parseFloat(value);
      document.getElementById('networkThresholdValue').textContent = value;
      applyNetworkThreshold(networkThreshold);
    };

    function applyNetworkThreshold(threshold) {
      if (!networkElements) return;
      const { link, linkLabels } = networkElements;
      link.classed("dimmed", d => Math.abs(d.value) < threshold);
      linkLabels.classed("dimmed", d => Math.abs(d.value) < threshold);
    }

    window.toggleCorrValues = function() {
      showCorr = document.getElementById('showCorrValues').checked;
      if (networkElements) {
        networkElements.linkLabels.style("display", showCorr ? "block" : "none");
      }
    };

    console.log('‚úÖ Network view component loaded');
  })();
</script>
