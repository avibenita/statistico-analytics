<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Dependent (Repeated Measures) Results (3+ Timepoints)</title>
  <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <script src="https://code.highcharts.com/highcharts.js"></script>
  <script src="https://code.highcharts.com/highcharts-more.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" rel="stylesheet"/>
  <script>
    // AI API Key configuration (Groq)
    // You can override via localStorage: localStorage.setItem('GROQ_API_KEY', 'your-key-here')
    window.AI_API_KEY = localStorage.getItem('GROQ_API_KEY') || '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';
    console.log('ðŸ”‘ AI API Key set:', window.AI_API_KEY && window.AI_API_KEY !== '' ? 'YES (***' + window.AI_API_KEY.slice(-4) + ')' : 'NO - Key not configured');
  </script>
  <style>
    :root{--surface-0:#0c1624;--surface-1:#1a1f2e;--surface-2:#242938;--border:#2d3748;--accent-1:rgb(255,165,120);--accent-2:rgb(120,200,255);--text-primary:#fff;--text-secondary:rgba(255,255,255,.82);--text-muted:rgba(255,255,255,.62);--panel-radius:8px;--panel-shadow:0 2px 10px rgba(0,0,0,.3);}
    html,body{height:100%;margin:0;background:var(--surface-0);color:var(--text-primary);font-family:Segoe UI,Tahoma,sans-serif;overflow-x:hidden;}
    .wrap{display:flex;justify-content:center;padding:4px 8px 12px;width:100%;box-sizing:border-box;}
    .card{min-height:680px;border-radius:var(--panel-radius);box-shadow:var(--panel-shadow);border:1px solid var(--border);display:flex;flex-direction:column;width:100%;max-width:100%;box-sizing:border-box;overflow-x:hidden;}
    .hero-section{background:linear-gradient(180deg,#0a1118,#0c1620);border-bottom:1px solid rgba(255,255,255,.06);padding:10px 14px;border-radius:var(--panel-radius) var(--panel-radius) 0 0;}
    .hero-content{display:flex;justify-content:space-between;align-items:center;gap:8px;}
    .hero-title{display:flex;align-items:center;font-size:1.1rem;font-weight:800;letter-spacing:.3px;text-transform:uppercase;}
    .hero-controls{display:flex;align-items:center;gap:8px;}
    .hero-action-btn{border-radius:6px;border:1px solid rgba(148,163,184,.45);background:linear-gradient(145deg,rgba(148,163,184,.18),rgba(100,116,139,.16));color:#fff;padding:6px 12px;font-size:11px;font-weight:650;cursor:pointer;display:flex;align-items:center;gap:6px;position:relative;}
    .hero-action-btn:hover::after{content:attr(title);position:absolute;bottom:100%;left:50%;transform:translateX(-50%);margin-bottom:6px;padding:6px 10px;background:#283593;color:#fff;font-size:10px;font-weight:600;white-space:nowrap;border-radius:6px;box-shadow:0 3px 10px rgba(0,0,0,0.3);z-index:1000;pointer-events:none;}
    .hero-action-btn:hover::before{content:'';position:absolute;bottom:100%;left:50%;transform:translateX(-50%);margin-bottom:1px;border:5px solid transparent;border-top-color:#283593;z-index:1000;pointer-events:none;}
    .tab-navigation{position:sticky;top:0;z-index:50;backdrop-filter:blur(10px);background:linear-gradient(180deg,rgba(7,11,18,.88),rgba(7,11,18,.55));border:1px solid rgba(255,255,255,.10);box-shadow:0 18px 40px rgba(0,0,0,.45);border-radius:18px;padding:10px;margin-top:6px;margin-bottom:14px;}
    .tab-navigation-row{display:flex;align-items:center;gap:8px;flex-wrap:wrap;justify-content:space-between;}
    .tabs{display:flex;gap:6px;flex-wrap:wrap;align-items:center;flex:1;}
    .tab-button{display:flex;align-items:center;gap:8px;padding:10px 12px;border-radius:14px;border:1px solid transparent;cursor:pointer;user-select:none;color:rgba(255,255,255,.55);font-weight:800;font-size:12px;letter-spacing:.25px;transition:background .18s ease,border-color .18s ease,color .18s ease,transform .08s ease;position:relative;background:transparent;}
    .tab-button:hover{background:rgba(255,255,255,.05);color:#fff;}
    .tab-button:active{transform:translateY(1px);}
    .tab-button i{opacity:.9;}
    .tab-button.active{background:linear-gradient(180deg,rgba(124,58,237,.22),rgba(124,58,237,.08));border-color:rgba(124,58,237,.42);color:#fff;}
    .tab-button.active::after{content:'';position:absolute;left:12px;right:12px;bottom:-6px;height:3px;border-radius:999px;background:linear-gradient(90deg,rgba(124,58,237,.85),rgba(124,58,237,.15));}
    .tab-controls-right{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end;}
    .tab-decimal-select{border:1px solid rgba(148,163,184,.45);background:rgba(15,23,42,.82);color:#fff;padding:9px 10px;border-radius:12px;font-weight:800;font-size:12px;outline:none;height:auto;}
    .view-container{padding:10px 12px;}
    .tab-panel{display:none;} .tab-panel.active{display:block;}
    .stats-container{display:grid;grid-template-columns:repeat(auto-fit,minmax(min(280px, 100%),1fr));gap:10px;overflow-x:hidden;}
    
    /* Ensure containers respect parent width */
    .view-container, .stat-panel, .table-container {
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
      overflow-x: auto;
    }
    .stat-panel{background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:8px;overflow:hidden;}
    .stat-panel.secondary{opacity:0.7;transform:scale(0.95);border-color:rgba(45,55,72,0.4);}
    .stat-panel.secondary .stat-panel-heading{background:#37474f;font-size:10px;padding:6px 8px;border-bottom:1px solid rgba(255,165,120,.4);}
    .stat-panel.secondary .stat-field{padding:5px 0;}
    .stat-panel.secondary .stat-label{font-size:12px;opacity:0.85;}
    .stat-panel.secondary .stat-value{font-size:12px;padding:4px 6px;min-width:90px;opacity:0.9;}
    .stat-panel-heading{padding:7px 10px;background:#164e8d;color:#fff;font-weight:800;text-transform:uppercase;letter-spacing:.5px;border-bottom:2px solid rgba(255,165,120,.7);font-size:13px;}
    .stat-panel-heading.parametric{background:#2e5f8a;border-bottom-color:#4a90e2;}
    .stat-panel-heading.nonparametric{background:#00695c;border-bottom-color:#26a69a;}
    .stat-panel-body{padding:6px 10px;}
    .stat-field{display:grid;grid-template-columns:1fr auto;align-items:center;gap:10px;padding:6px 0;border-bottom:1px solid rgba(255,255,255,.06);}
    .stat-field:last-child{border-bottom:none;}
    .stat-label{color:var(--text-secondary);font-weight:600;font-size:12px;}
    .stat-value{font-variant-numeric:tabular-nums;color:var(--accent-2);font-weight:700;background:rgba(120,200,255,.12);border:1px solid rgba(120,200,255,.32);padding:5px 8px;border-radius:6px;min-width:90px;text-align:center;font-size:12px;}
    .table-container{margin-top:8px;overflow:auto;max-height:350px;}
    .analysis-table{width:100%;border-collapse:collapse;}
    .analysis-table th{background:#164e8d;color:#fff;padding:6px;border:1px solid rgba(255,255,255,.2);font-size:11px;}
    .analysis-table td{padding:6px;border:1px solid rgba(255,255,255,.14);color:var(--text-secondary);font-size:11px;}
    .section-note{margin-top:8px;padding:7px;border-left:3px solid var(--accent-1);background:rgba(255,165,120,.1);color:var(--text-muted);font-size:11px;}
    .framework-select{height:28px;padding:0 8px;border-radius:6px;border:1px solid rgba(148,163,184,.45);background:rgba(15,23,42,.82);color:#fff;font-size:11px;}
    .agreement-good{color:#4ade80;font-weight:700;}
    .agreement-warn{color:#fbbf24;font-weight:700;}
    .settings-bar{margin-top:6px;background:linear-gradient(135deg, #e8eaf6 0%, #c5cae9 100%);border:1px solid rgba(92,107,192,0.3);border-radius:0;padding:6px 8px;box-shadow:0 2px 6px rgba(92,107,192,0.15);}
    .settings-panel-title{font-size:10px;font-weight:800;text-transform:uppercase;letter-spacing:1px;color:#283593;margin-bottom:6px;padding-bottom:3px;border-bottom:1px solid rgba(92,107,192,0.3);}
    .settings-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:5px;}
    .settings-grid>div{display:flex;flex-direction:column;}
    .settings-grid label{font-size:10px;color:#37474f;margin-bottom:2px;font-weight:700;text-transform:uppercase;}
    .settings-grid select,.settings-grid input{width:100%;height:28px;border-radius:0;border:1px solid rgba(92,107,192,0.4);background:#ffffff;color:#263238;padding:0 6px;font-weight:600;font-size:11px;}
    .posthoc-radio{display:flex;align-items:center;gap:6px;padding:4px 6px;cursor:pointer;font-size:11px;color:var(--text-secondary);font-weight:600;border-radius:4px;transition:background 0.2s;}
    .posthoc-radio:hover{background:rgba(255,255,255,0.1);}
    .posthoc-radio input[type="radio"]{margin:0;width:16px;height:16px;cursor:pointer;accent-color:#4a90e2;}
    .posthoc-radio input[type="radio"]:checked + span{color:var(--accent-2);font-weight:700;}
    #setPosthocWrap,#setCorrectionWrap{min-width:160px;max-width:200px;display:flex;flex-direction:column;align-items:flex-start;gap:3px;}
    #setPosthocWrap label,#setCorrectionWrap label{white-space:nowrap;line-height:1;margin-bottom:0;font-size:10px;}
    .inference-row{display:flex;align-items:center;justify-content:flex-start;gap:10px;flex-wrap:nowrap;min-width:max-content;}
    .inference-card{display:flex;flex-direction:column;align-items:flex-start;gap:6px;padding:0;border:0;border-radius:0;background:transparent;}
    .inference-card#primaryTestWrap{flex:0 0 auto;min-width:180px;max-width:200px;}
    .inference-title{display:none;}
    
    /* WELL-DESIGNED RADIO BUTTON GROUP */
    .radio-button-group{display:flex;gap:10px;flex-wrap:nowrap;}
    .radio-button-group input[type="radio"]{display:none;}
    .radio-button-label{display:flex;align-items:center;gap:8px;padding:12px 16px;background:#ffffff;border:1px solid rgba(224,231,255,0.6);border-radius:0;cursor:pointer;transition:all 0.25s ease;min-width:140px;position:relative;}
    .radio-button-label:hover{border-color:#5c6bc0;box-shadow:0 2px 8px rgba(92,107,192,0.15);transform:translateY(-1px);}
    .radio-button-group input[type="radio"]:checked + .radio-button-label{border-color:#5c6bc0;background:#f5f7ff;box-shadow:0 3px 12px rgba(92,107,192,0.2);border-width:2px;padding:12px 16px;}
    
    /* Radio check circle */
    .radio-check{display:inline-block;width:20px;height:20px;border:1px solid rgba(203,213,225,0.8);border-radius:50%;position:relative;transition:all 0.25s ease;flex-shrink:0;}
    .radio-button-group input[type="radio"]:checked + .radio-button-label .radio-check{border-color:#5c6bc0;border-width:1px;background:#5c6bc0;}
    .radio-button-group input[type="radio"]:checked + .radio-button-label .radio-check::after{content:'';position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);width:8px;height:8px;background:#ffffff;border-radius:50%;}
    
    /* Radio text */
    .radio-text{font-size:13px;font-weight:700;color:#263238;line-height:1.3;text-align:left;}
    .radio-text small{display:block;font-size:10px;font-weight:500;color:#64748b;margin-top:2px;}
    .radio-button-group input[type="radio"]:checked + .radio-button-label .radio-text{color:#5c6bc0;}
    
    /* Specific colors for different types - MATCHED COLORS */
    .parametric-label .radio-check{border-color:#8b5cf6;}
    .radio-button-group input[type="radio"]:checked + .parametric-label{border-color:#8b5cf6;background:#faf5ff;}
    .radio-button-group input[type="radio"]:checked + .parametric-label .radio-check{background:#8b5cf6;border-color:#8b5cf6;}
    .radio-button-group input[type="radio"]:checked + .parametric-label .radio-text{color:#5b21b6;}
    
    .nonparametric-label .radio-check{border-color:#10b981;}
    .radio-button-group input[type="radio"]:checked + .nonparametric-label{border-color:#10b981;background:#f0fdf4;}
    .radio-button-group input[type="radio"]:checked + .nonparametric-label .radio-check{background:#10b981;border-color:#10b981;}
    .radio-button-group input[type="radio"]:checked + .nonparametric-label .radio-text{color:#065f46;}
    
    /* TEST METHOD CARDS (no radio buttons, display only) */
    .test-method-group{display:flex;gap:10px;flex-wrap:nowrap;}
    .test-method-card{display:flex;align-items:center;padding:12px 16px;background:#ffffff;border:1px solid rgba(224,231,255,0.6);border-radius:8px;min-width:140px;transition:all 0.25s ease;}
    .test-method-card.active{border-color:#8b5cf6;background:#faf5ff;border-width:2px;padding:12px 16px;}
    .test-method-card.active .test-method-text{color:#5b21b6;}
    .test-method-card.disabled{opacity:0.4;border-color:#e5e7eb;background:#f9fafb;pointer-events:none;}
    .test-method-card.disabled .test-method-text{color:#9ca3af;}
    
    /* When non-parametric is selected, switch colors to green */
    .test-method-card.active.nonparametric-active{border-color:#10b981;background:#f0fdf4;}
    .test-method-card.active.nonparametric-active .test-method-text{color:#065f46;}
    
    .test-method-text{font-size:13px;font-weight:700;color:#263238;line-height:1.3;text-align:left;}
    .test-method-text small{display:block;font-size:10px;font-weight:500;color:#64748b;margin-top:2px;}
    
    .test-label .radio-check{border-color:#8b5cf6;}
    .radio-button-group input[type="radio"]:checked + .test-label{border-color:#8b5cf6;background:#faf5ff;}
    .radio-button-group input[type="radio"]:checked + .test-label .radio-check{background:#8b5cf6;border-color:#8b5cf6;}
    .radio-button-group input[type="radio"]:checked + .test-label .radio-text{color:#5b21b6;}
    
    /* Legacy styles (removed) */
    .framework-selector, .test-selector{display:none !important;}
    .fw-radio#setFrameworkNon{background:#26a69a;color:#fff;}
    .fw-radio#setFrameworkNon.active{background:#00695c;border-color:#26a69a;}
    .primary-test-wrap{display:flex;align-items:center;gap:6px;min-width:240px;}
    .test-now{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:6px;border:1px solid rgba(16,185,129,.45);background:rgba(16,185,129,.14);color:#d1fae5;font-size:11px;font-weight:800;}
    .primary-test-wrap label{font-size:10px;color:var(--text-muted);font-weight:800;text-transform:uppercase;}
    .primary-test-wrap select{height:32px;width:100%;border-radius:0;border:3px solid transparent;background:#2e5f8a;color:#ffffff;padding:0 10px;font-weight:700;font-size:13px;box-shadow:0 2px 6px rgba(0,0,0,0.15);text-align:center;text-align-last:center;}
    .primary-test-wrap select.parametric{background:#2e5f8a;border-color:#4a90e2;color:#ffffff;box-shadow:0 3px 10px rgba(46,95,138,0.4);}
    .primary-test-wrap select.nonparametric{background:#00695c;border-color:#26a69a;color:#ffffff;box-shadow:0 3px 10px rgba(0,105,92,0.4);}
    #setPrimaryTest:disabled{appearance:none;-webkit-appearance:none;-moz-appearance:none;background-image:none !important;cursor:default;padding-right:8px !important;}
    select:disabled{appearance:none;-webkit-appearance:none;-moz-appearance:none;}
    .hbox{border:1px solid rgba(148,163,184,.38);border-radius:8px;padding:6px;background:rgba(6,16,30,.55);}
    .hbox-title{font-size:10px;color:var(--text-muted);text-transform:uppercase;font-weight:700;margin-bottom:5px;}
    .hbox-row{display:flex;align-items:center;gap:8px;flex-wrap:nowrap;color:#e5eefc;}
    .h-radio{display:inline-flex;align-items:center;gap:4px;font-size:11px;color:#263238;text-transform:none !important;white-space:nowrap;font-weight:600;}
    .h-radio input{transform:scale(0.85);}
    .hdr-row{display:flex;justify-content:flex-start;align-items:center;gap:8px;flex-wrap:wrap;overflow:visible;padding-bottom:2px;}
    #compareStatsRow{flex-wrap:wrap;overflow:visible;scrollbar-width:auto;}
    .stat-chip{display:inline-flex;align-items:center;justify-content:center;gap:3px;background:#e3f2fd;border:1px solid rgba(25,118,210,0.5);border-radius:0;padding:3px 6px;font-size:10px;color:#0d47a1;font-weight:700;min-width:190px;box-sizing:border-box;}
    .test-chip{display:inline-flex;align-items:center;background:rgba(16,185,129,.16);border:1px solid rgba(16,185,129,.55);color:#d1fae5;border-radius:6px;padding:6px 10px;font-size:11px;font-weight:700;}
    .hyp-card{border:1px solid rgba(92,107,192,0.4);border-radius:0;padding:6px 8px;background:#ffffff;}
    .hyp-row{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;}

.hyp-main{font-size:13px;font-weight:700;color:#283593;white-space:nowrap;min-width:200px;}
.hyp-block{display:flex;align-items:center;gap:8px;white-space:nowrap;}
.hyp-h1-label{font-size:10px;color:#37474f;font-weight:800;text-transform:uppercase;letter-spacing:.2px;margin-bottom:3px;}
.hyp-options{display:flex;align-items:center;gap:10px;white-space:nowrap;}
.hyp-delta{font-weight:800;color:#93c5fd;}
.alpha-wrap{min-width:240px;max-width:300px;}
.alpha-wrap label{font-size:10px;color:#37474f;font-weight:800;text-transform:uppercase;}
#setAlpha{height:3px;opacity:.78;accent-color:#3949ab;max-width:190px;}
/* Descriptive Stats Tab Styles */
.desc-table-wrap{max-height:240px;overflow:auto;border:1px solid var(--border);border-radius:6px;background:var(--surface-2);margin-bottom:12px;}
#desc-stats-table{width:100%;min-width:820px;border-collapse:collapse;table-layout:auto;}
#desc-stats-table th,#desc-stats-table td{padding:6px 8px;border:1px solid rgba(255,255,255,.18);box-sizing:border-box;text-align:right;font-size:10px;line-height:16px;height:30px;white-space:nowrap;}
#desc-stats-table th:first-child,#desc-stats-table td:first-child{text-align:left;min-width:120px;max-width:180px;overflow:hidden;text-overflow:ellipsis;}
#desc-stats-table thead th{background:#003366cc;color:#fff;z-index:2;cursor:pointer;}
#desc-stats-table tbody tr:nth-child(even) td{background:rgba(255,255,255,.05)}
#desc-stats-table tbody tr:hover td{background:rgba(255,221,87,.18)}
#desc-stats-table tbody tr.selected td{background:rgba(255,165,120,.3)}
#histogram-container-kplus{height:280px;margin-top:0;overflow:hidden;}
.histogram-bar{fill:#74b9ff;stroke:#0984e3;stroke-width:1px;}
.histogram-bar:hover{fill:#0984e3;}
.normal-curve{fill:none;stroke:yellow;stroke-width:2px;stroke-dasharray:5,5;}
.axis text{fill:white;font-size:10px;}
.axis path,.axis line{stroke:#999;}
.grid line{stroke:#555;stroke-opacity:0.7;shape-rendering:crispEdges;}
.grid path{stroke-width:0;}
.desc-summary-stats{display:grid;grid-template-columns:1fr 1fr;gap:6px;padding:10px;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:6px;font-size:11px;}
.desc-summary-stats div{display:flex;justify-content:space-between;padding:3px 0;border-bottom:1px solid rgba(255,255,255,.08);}
.desc-summary-stats div:last-child{border-bottom:none;}
.desc-summary-stats strong{color:var(--text-secondary);}
.desc-summary-stats span{color:var(--accent-2);font-weight:700;}
.modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.7);z-index:1000;backdrop-filter:blur(3px);}
.normality-button:hover{background:linear-gradient(to right,rgb(255,160,160),rgb(255,192,192));transform:translateY(-2px);}

/* ===== RESPONSIVE DESIGN ===== */

/* Very narrow containers (Excel task pane) */
@media (max-width: 400px) {
  .wrap { padding: 1px 2px 4px; }
  .view-container { padding: 4px 6px; }
  
  /* Header */
  .hero-section { padding: 6px 8px; }
  .hero-title { font-size: 0.8rem; }
  .hero-action-btn { padding: 4px 6px; font-size: 9px; }
  
  /* Tabs */
  .tab-button { font-size: 8px; height: 26px; padding: 0 2px; }
  .tab-decimal-select { font-size: 9px; height: 26px; }
  
  /* Stats panels - force single column */
  .stats-container { 
    grid-template-columns: 1fr !important; 
    gap: 6px !important; 
  }
  
  /* Panel content */
  .stat-panel-heading { font-size: 10px; padding: 5px 6px; }
  .stat-panel-body { padding: 4px 6px; }
  .stat-field { 
    grid-template-columns: 1fr; 
    gap: 3px; 
    padding: 4px 0;
  }
  .stat-label { font-size: 9px; }
  .stat-value { 
    min-width: auto; 
    width: 100%; 
    font-size: 10px;
    padding: 4px 6px;
  }
  
  /* Power cards - single column with compact spacing */
  .view-container > div[style*="grid-template-columns"] {
    grid-template-columns: 1fr !important;
    gap: 6px !important;
  }
  
  /* Custom power input */
  #customPowerInput { width: 50px !important; font-size: 11px !important; }
  
  /* Tables */
  .table-container { font-size: 9px; }
  .analysis-table th, .analysis-table td { 
    padding: 3px; 
    font-size: 9px; 
  }
  
  /* Settings */
  .settings-bar { padding: 4px 6px; }
  .settings-panel-title { font-size: 9px; }
  .settings-grid { gap: 3px; }
  .settings-grid label { font-size: 9px; }
  .settings-grid select, .settings-grid input { 
    height: 24px; 
    font-size: 9px; 
  }
  
  /* Radio buttons */
  .radio-button-label { 
    padding: 8px 10px; 
    min-width: auto;
  }
  .radio-text { font-size: 11px; }
  .radio-text small { font-size: 9px; }
  
  /* Sections */
  .section-note { font-size: 9px; padding: 5px; }
  
  /* Status message */
  #powStatusMessage { font-size: 10px !important; padding: 6px !important; }
}

@media (max-width: 768px) {
  .wrap { padding: 2px 4px 8px; }
  .card { min-height: auto; }
  .hero-section { padding: 8px 10px; }
  .hero-title { font-size: 0.95rem; }
  .hero-action-btn { padding: 5px 8px; font-size: 10px; }
  .tab-navigation { gap: 8px; }
  .tab-button { font-size: 10px; padding: 0 2px; }
  .view-container { padding: 8px 10px; }
  
  /* Make stats container stack on small screens */
  .stats-container { grid-template-columns: 1fr !important; gap: 8px; }
  
  /* Power cards - 2 columns on mobile */
  #tab-power .stats-container { grid-template-columns: 1fr 1fr !important; }
  
  /* Tables */
  .analysis-table { font-size: 10px; }
  .analysis-table th, .analysis-table td { padding: 4px; }
  
  /* Settings */
  .settings-grid { grid-template-columns: 1fr !important; gap: 4px; }
  .inference-row { flex-direction: column; align-items: stretch; }
  .radio-button-group { flex-direction: column; }
  .radio-button-label { min-width: auto; width: 100%; }
}

@media (max-width: 480px) {
  .hero-content { flex-direction: column; align-items: stretch; gap: 6px; }
  .hero-controls { justify-content: space-between; width: 100%; }
  .tab-button { font-size: 9px; gap: 3px; }
  .stat-panel-heading { font-size: 11px; padding: 6px 8px; }
  .stat-field { grid-template-columns: 1fr; gap: 4px; }
  .stat-label { font-size: 11px; }
  .stat-value { min-width: auto; width: 100%; font-size: 11px; }
  
  /* Power cards - single column on very small screens */
  #tab-power .stats-container { grid-template-columns: 1fr !important; }
}

/* Responsive grid for power level cards */
@media (max-width: 900px) {
  /* 2x2 grid for power cards on medium screens */
  .view-container > div[style*="grid-template-columns:repeat(4,1fr)"] {
    grid-template-columns: repeat(2, 1fr) !important;
  }
}

@media (max-width: 500px) {
  /* Single column for power cards on small screens */
  .view-container > div[style*="grid-template-columns:repeat(4,1fr)"],
  .view-container > div[style*="grid-template-columns:repeat(2,1fr)"] {
    grid-template-columns: 1fr !important;
  }
}

/* ===== SCATTER PLOT MODAL ===== */
.scatter-modal {
  display: none;
  position: fixed;
  z-index: 9999;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.75);
  align-items: center;
  justify-content: center;
  padding: 10px;
}

.scatter-modal-content {
  background: var(--surface-1);
  border: 2px solid var(--border);
  border-radius: 8px;
  width: 95%;
  max-width: 900px;
  max-height: 92vh;
  overflow: hidden;
  box-shadow: 0 20px 60px rgba(0,0,0,0.7);
  display: flex;
  flex-direction: column;
}

.scatter-modal-header {
  padding: 8px 12px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid var(--border);
  color: var(--accent-1);
  font-weight: 700;
  font-size: 14px;
  flex-shrink: 0;
}

.scatter-modal-body {
  padding: 8px 12px;
  overflow: auto;
  flex: 1;
}

.scatter-close {
  cursor: pointer;
  font-size: 20px;
  color: var(--text-secondary);
  line-height: 1;
  transition: color 0.2s;
}

.scatter-close:hover {
  color: var(--accent-1);
}

.scatter-stats {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 8px;
  margin-bottom: 8px;
  padding: 8px;
  background: rgba(255,255,255,0.04);
  border: 1px solid var(--border);
  border-radius: 6px;
}

.scatter-stat {
  text-align: center;
}

.scatter-stat-value {
  font-size: 15px;
  font-weight: 700;
  color: var(--accent-2);
  margin-bottom: 2px;
}

.scatter-stat-label {
  font-size: 9px;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.3px;
}

.scatter-chart {
  width: 100%;
  height: 280px;
  background: var(--surface-2);
  border: 1px solid var(--border);
  border-radius: 6px;
  margin-bottom: 8px;
}

.scatter-controls {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}

.scatter-panel {
  background: rgba(255,255,255,0.03);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 8px;
}

.scatter-panel-title {
  font-size: 11px;
  font-weight: 700;
  color: var(--accent-2);
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 4px;
}

.scatter-panel-title i {
  font-size: 10px;
}

.scatter-buttons {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 4px;
  margin-bottom: 6px;
}

.scatter-btn {
  padding: 5px 6px;
  background: rgba(255,255,255,0.08);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--text-secondary);
  font-size: 10px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.scatter-btn:hover {
  background: rgba(255,255,255,0.15);
  border-color: var(--accent-2);
}

.scatter-btn.active {
  background: var(--accent-2);
  border-color: var(--accent-2);
  color: #000;
}

.scatter-axis-toggle {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 4px;
  margin-bottom: 6px;
}

.fit-equation {
  font-size: 9px;
  color: var(--text-muted);
  text-align: center;
  padding: 4px;
  background: rgba(0,0,0,0.2);
  border-radius: 3px;
  min-height: 20px;
}

/* Scatter data section */
.scatter-data-section {
  margin-top: 8px;
  border: 1px solid var(--border);
  border-radius: 6px;
  background: rgba(255,255,255,0.02);
  overflow: hidden;
}

.scatter-data-header {
  padding: 6px 10px;
  background: rgba(255,255,255,0.05);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: space-between;
  user-select: none;
  transition: background 0.2s;
}

.scatter-data-header:hover {
  background: rgba(255,255,255,0.08);
}

.scatter-data-header i.fa-chevron-right {
  font-size: 10px;
  transition: transform 0.2s;
  margin-right: 6px;
}

.scatter-data-header i.fa-chevron-right.expanded {
  transform: rotate(90deg);
}

.scatter-data-header strong {
  font-size: 11px;
  color: var(--text-secondary);
}

.scatter-data-header #scatterDataCount {
  font-size: 10px;
  color: var(--text-muted);
  margin-left: 4px;
}

.scatter-copy-btn {
  padding: 3px 8px;
  background: rgba(120,200,255,0.2);
  border: 1px solid var(--accent-2);
  border-radius: 4px;
  color: var(--accent-2);
  font-size: 9px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  gap: 4px;
}

.scatter-copy-btn:hover {
  background: var(--accent-2);
  color: #000;
}

.scatter-copy-btn i {
  font-size: 9px;
}

.scatter-data-content {
  padding: 8px;
}

.scatter-data-excluded {
  padding: 6px 8px;
  background: rgba(255,165,120,0.15);
  border: 1px solid rgba(255,165,120,0.3);
  border-radius: 4px;
  font-size: 10px;
  color: var(--accent-1);
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.scatter-data-table-container {
  max-height: 200px;
  overflow: auto;
  border: 1px solid var(--border);
  border-radius: 4px;
}

.scatter-data-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 10px;
}

.scatter-data-table th {
  position: sticky;
  top: 0;
  background: #003366;
  color: #fff;
  padding: 6px 8px;
  text-align: left;
  font-weight: 700;
  border: 1px solid rgba(255,255,255,0.2);
  z-index: 1;
}

.scatter-data-table th:first-child {
  text-align: center;
  width: 40px;
}

.scatter-data-table td {
  padding: 5px 8px;
  border: 1px solid rgba(255,255,255,0.1);
  color: var(--text-secondary);
}

.scatter-data-table td:first-child {
  text-align: center;
  color: var(--text-muted);
  font-weight: 600;
}

.scatter-data-table tbody tr:nth-child(even) {
  background: rgba(255,255,255,0.03);
}

.scatter-data-table tbody tr:hover {
  background: rgba(120,200,255,0.1);
}

/* Responsive adjustments for scatter modal */
@media (max-width: 600px) {
  .scatter-modal-content {
    width: 98%;
    max-height: 95vh;
  }
  
  .scatter-chart {
    height: 220px;
  }
  
  .scatter-controls {
    grid-template-columns: 1fr;
  }
  
  .scatter-stats {
    grid-template-columns: repeat(2, 1fr);
  }
}

  </style>
</head>
<body>
  <div class="wrap">
    <section class="card">
      <div class="hero-section">
        <div class="hero-content">
          <div class="hero-title"><span>Repeated Measures Module (3+ Timepoints)</span></div>
          <div class="hero-controls">
            <button class="hero-action-btn" onclick="openListwiseDataModal()" title="View complete listwise data for all timepoints">
              <i class="fa-solid fa-table"></i> View Data
            </button>
            <button class="hero-action-btn" onclick="saveCurrentModel()" title="Save model configuration to Excel workbook">
              <i class="fa-solid fa-floppy-disk"></i> Model
            </button>
            </button>
            <button class="hero-action-btn" onclick="exportHtml()" title="Export complete report as standalone HTML file">
              <i class="fa-solid fa-floppy-disk"></i> HTML
            </button>
          </div>
        </div>
        <div class="tab-navigation">
          <div class="tab-navigation-row">
            <div class="tabs">
              <button class="tab-button active" data-tab="explore"><i class="fa-solid fa-chart-column"></i> Explore</button>
              <button class="tab-button" data-tab="trajectories"><i class="fa-solid fa-chart-line"></i> Trajectories</button>
              <button class="tab-button" data-tab="assumptions"><i class="fa-solid fa-shield-halved"></i> Assumptions</button>
              <button class="tab-button" data-tab="results"><i class="fa-solid fa-square-poll-vertical"></i> Results</button>
              <button class="tab-button" data-tab="posthoc"><i class="fa-solid fa-table-cells"></i> Post-hoc</button>
              <button class="tab-button" data-tab="effects"><i class="fa-solid fa-wave-square"></i> Effects</button>
              <button class="tab-button" data-tab="power"><i class="fa-solid fa-bolt"></i> Power</button>
              <button class="tab-button" data-tab="ai-interpretation"><i class="fa-solid fa-brain"></i> AI Interpretation</button>
            </div>
            <div class="tab-controls-right">
              <label for="decimalSelect" style="font-size:12px;color:rgba(255,255,255,.70);font-weight:700;">Decimals</label>
              <select id="decimalSelect" class="tab-decimal-select" onchange="setDecimalPrecision()">
                <option value="auto">Auto</option><option value="0">0</option><option value="1">1</option><option value="2" selected>2</option><option value="3">3</option><option value="4">4</option>
              </select>
            </div>
          </div>
        </div>

        <div class="settings-bar">
  <div class="settings-panel-title">Test Configuration Panel (>2 Timepoints)</div>
  <div class="settings-grid">








    <!-- Comparison chips (no design message) -->
    <div style="grid-column:1/-1;">
      <div class="hdr-row" id="compareStatsRow"></div>
    </div>

    <!-- Inference + Test method (side by side, radio buttons) -->
    <div style="grid-column:1/-1;">
      <div class="hdr-row">
        <div class="inference-row">

          <!-- Framework Selection (left) -->
          <div class="inference-card" style="flex:0 0 auto;">
            <div style="font-size:10px;font-weight:700;color:#5c6bc0;text-transform:uppercase;letter-spacing:0.8px;margin-bottom:6px;">Statistical Framework</div>
            <div class="radio-button-group">
              <input id="fwParametric" type="radio" name="frameworkMode" value="parametric" checked onchange="onFrameworkChange()"/>
              <label for="fwParametric" class="radio-button-label parametric-label">
                <span class="radio-check"></span>
                <span class="radio-text">Parametric<br><small>(means)</small></span>
              </label>
              
              <input id="fwNonparametric" type="radio" name="frameworkMode" value="nonparametric" onchange="onFrameworkChange()"/>
              <label for="fwNonparametric" class="radio-button-label nonparametric-label">
                <span class="radio-check"></span>
                <span class="radio-text">Non-parametric<br><small>(ranks)</small></span>
              </label>
            </div>
          </div>

          <!-- Vertical divider -->
          <div style="width:2px;height:80px;background:linear-gradient(to bottom, transparent, rgba(92,107,192,0.25), transparent);margin:0 20px;"></div>

          <!-- Test Method Selection (right) -->
          <div class="inference-card" style="flex:1 1 auto;min-width:280px;">
            <div style="font-size:10px;font-weight:700;color:#5c6bc0;text-transform:uppercase;letter-spacing:0.8px;margin-bottom:6px;">Test Method</div>
            <div class="test-method-group">
              <div id="testRmAnovaCard" class="test-method-card active">
                <span class="test-method-text">RM-ANOVA<br><small>Parametric omnibus test</small></span>
              </div>
              
              <div id="testFriedmanCard" class="test-method-card disabled">
                <span class="test-method-text">Friedman Test<br><small>Nonparametric omnibus test</small></span>
              </div>
            </div>
          </div>

        </div>
      </div>
    </div>

    <!-- (Removed from original position) -->

    <!-- Hypothesis + alpha (compact, less clutter) -->
    <div id="setHypWrap" style="grid-column:1/-1;">
      <div class="hyp-card">
        <div class="hyp-row">

          <div class="hyp-block hyp-main">
            <strong>H0:</strong> <span id="h0Text">All timepoint means equal</span>
          </div>

          <div class="hyp-block">

  <div class="hyp-h1-label">Alternative (H1)</div>

  <div class="hbox-row hyp-options" id="h1Row">
    <label class="h-radio">
      <input type="radio" name="h1Orientation" value="less"/>
      Difference &lt; 0
    </label>

    <label class="h-radio">
      <input type="radio" name="h1Orientation" value="two-sided" checked/>
      Difference â‰  0
    </label>

    <label class="h-radio">
      <input type="radio" name="h1Orientation" value="greater"/>
      Difference &gt; 0
    </label>
  </div>

</div>



          <div class="alpha-wrap">
            <label for="setAlpha" style="font-size:10px;opacity:0.75;">
              Significance: <span id="alphaVal">0.050</span>
            </label>
            <input id="setAlpha" type="range" min="0.001" max="0.2" step="0.001" value="0.05" style="height:3px;"/>
          </div>

        </div>
      </div>
    </div>

  </div>
</div>


        
      <div class="view-container">
        <section id="tab-explore" class="tab-panel active">
          <!-- Descriptive Statistics with integrated summary info -->
          <div class="stat-panel">
            <div class="stat-panel-heading">Descriptive Statistics</div>
            <div style="padding:6px 10px;background:rgba(255,165,120,.08);border-bottom:1px solid var(--border);display:flex;flex-wrap:wrap;gap:8px;font-size:11px;align-items:center;">
              <span style="color:var(--text-secondary);"><strong>Variables:</strong> <span id="expVarCount" style="color:var(--accent-2);font-weight:700;">...</span></span>
              <span style="color:var(--text-secondary);"><strong>Complete Cases:</strong> <span id="expTotalN" style="color:var(--accent-2);font-weight:700;">...</span></span>
              <span style="color:var(--text-secondary);"><strong>Overall xÌ„:</strong> <span id="expOverallMean" style="color:var(--accent-2);font-weight:700;">...</span></span>
              <span style="color:var(--text-secondary);"><strong>Framework:</strong> <span id="expFramework" style="color:var(--accent-2);font-weight:700;">...</span></span>
            </div>
            <div id="missingDataWarning" style="display:none;padding:8px 10px;background:rgba(251,191,36,.12);border-left:3px solid #fbbf24;margin:0 10px 10px;font-size:11px;">
              <strong style="color:#fbbf24;"><i class="fa-solid fa-triangle-exclamation"></i> Missing Data:</strong>
              <span style="color:var(--text-secondary);"> <span id="missingCount" style="font-weight:700;">0</span> rows (<span id="missingPct">0</span>%) excluded due to incomplete timepoint data. RM-ANOVA requires <strong>complete cases</strong> (valid data at all timepoints).</span>
            </div>
            <div class="stat-panel-body">
              <div class="desc-table-wrap">
                <table id="desc-stats-table">
                  <colgroup>
                    <col style="min-width: 140px; max-width: 200px;">
                    <col style="min-width: 70px;">
                    <col style="min-width: 90px;">
                    <col style="min-width: 90px;">
                    <col style="min-width: 90px;">
                    <col style="min-width: 90px;">
                    <col style="min-width: 90px;">
                    <col style="min-width: 80px;">
                    <col style="min-width: 80px;">
                  </colgroup>
                  <thead>
                    <tr>
                      <th data-key="Variable" style="text-align:left">Variable <i class="fa fa-sort"></i></th>
                      <th data-key="N">N <i class="fa fa-sort"></i></th>
                      <th data-key="Mean">Mean <i class="fa fa-sort"></i></th>
                      <th data-key="StdDev">StdDev <i class="fa fa-sort"></i></th>
                      <th data-key="Min">Min <i class="fa fa-sort"></i></th>
                      <th data-key="Median">Median <i class="fa fa-sort"></i></th>
                      <th data-key="Max">Max <i class="fa fa-sort"></i></th>
                      <th data-key="Skew">Skew <i class="fa fa-sort"></i></th>
                      <th data-key="Kurt">Kurt <i class="fa fa-sort"></i></th>
                    </tr>
                  </thead>
                  <tbody id="desc-stats-body"></tbody>
                </table>
              </div>
              
              <div style="display:none;" id="desc-histogram-panel">
                <div style="font-weight:700;margin:16px 0 8px;color:var(--accent-1);display:flex;justify-content:space-between;align-items:center;">
                  <span>Histogram: <span id="desc-histogram-title">Select a variable</span></span>
                  <button class="normality-button" onclick="openNormalityModal()" style="background:linear-gradient(to right, rgb(255,192,192), rgb(255,160,160));color:black;border:none;border-radius:6px;padding:8px 16px;cursor:pointer;font-weight:bold;transition:all 0.3s ease;">
                    Normality Tests
                  </button>
                </div>
                <div style="margin-bottom:12px;display:flex;align-items:center;gap:12px;padding:8px 12px;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:6px;">
                  <label for="histogramBins" style="font-size:11px;color:var(--text-secondary);font-weight:700;white-space:nowrap;">Bins:</label>
                  <input type="range" id="histogramBins" min="5" max="30" value="10" step="1" style="flex:1;height:4px;opacity:0.8;accent-color:#4a90e2;cursor:pointer;">
                  <span id="histogramBinsValue" style="font-size:11px;color:var(--accent-2);font-weight:700;min-width:30px;text-align:center;">10</span>
                </div>
                <div style="display:grid;grid-template-columns:2fr 1fr;gap:16px;">
                  <div id="histogram-container-kplus" style="overflow:hidden;"></div>
                  <div>
                    <div class="desc-summary-stats" id="desc-summary-table"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </section>
        
        <!-- Trajectories Tab (Profile Plot + Correlation Matrix) -->
        <section id="tab-trajectories" class="tab-panel">
          <div class="stat-panel">
            <div class="stat-panel-heading">Trajectory Analysis</div>
            <div class="stat-panel-body" style="padding:12px;">
              
              <!-- Profile Plot (Spaghetti + Mean Line) -->
              <div style="margin-bottom:24px;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
                  <div style="font-weight:700;color:var(--accent-1);font-size:14px;">
                    <i class="fa-solid fa-chart-line"></i> <span id="profilePlotTitle">Profile Plot</span>
                  </div>
                  <div style="display:flex;gap:6px;">
                    <button onclick="switchProfileView('trajectory')" id="btnTrajectory" class="profile-view-btn active" style="padding:4px 10px;background:#ff9800;color:white;border:none;border-radius:4px;cursor:pointer;font-size:10px;font-weight:600;">
                      <i class="fa-solid fa-chart-line"></i> Trajectory
                    </button>
                    <button onclick="switchProfileView('sd')" id="btnSD" class="profile-view-btn" style="padding:4px 10px;background:transparent;color:#9c27b0;border:2px solid #9c27b0;border-radius:4px;cursor:pointer;font-size:10px;font-weight:600;">
                      <i class="fa-solid fa-chart-bar"></i> Variability (SD)
                    </button>
                  </div>
                </div>
                <p style="margin:0 0 12px 0;color:var(--text-muted);font-size:11px;line-height:1.5;">
                  <strong>Purpose:</strong> <span id="profilePurpose">Visualize the group mean trajectory with a shaded envelope showing the full range of individual values (Min-Max). 
                  This reveals patterns of change and where variability is highest across timepoints.</span>
                </p>
                <div style="padding:10px;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:6px;">
                  <div id="profilePlot" style="width:100%;height:400px;"></div>
                  <div id="profileNote" style="margin-top:8px;padding:6px 10px;background:rgba(79,195,247,0.12);border-left:3px solid #4fc3f7;border-radius:4px;font-size:10px;color:#81d4fa;">
                    <i class="fa-solid fa-info-circle"></i> <strong>Note:</strong> The blue shaded area represents the full range of individual values (Min-Max), 
                    showing the complete spread at each timepoint. Wider areas indicate higher variability.
                  </div>
                  <div style="margin-top:10px;padding:8px;background:rgba(120,200,255,.08);border-left:3px solid var(--accent-2);border-radius:4px;font-size:11px;">
                    <strong>Interpretation:</strong>
                    <ul id="profileInterpretation" style="margin:6px 0 0 0;padding-left:20px;color:var(--text-secondary);">
                      <li><strong>Orange line:</strong> Group mean trajectory showing average pattern of change</li>
                      <li><strong>Blue shaded area:</strong> Full range of individual values (Min to Max)</li>
                      <li><strong>Narrow envelope:</strong> Subjects respond consistently</li>
                      <li><strong>Wide envelope:</strong> High individual variability at that timepoint</li>
                      <li><strong>Steep slopes:</strong> Rapid changes between timepoints</li>
                    </ul>
                  </div>
                </div>
              </div>
              
              <!-- Correlation Matrix with Heatmap -->
              <div>
                <div style="font-weight:700;margin-bottom:8px;color:var(--accent-1);font-size:14px;">
                  <i class="fa-solid fa-grip"></i> Within-Subject Correlation Matrix & Heatmap
                </div>
                <p style="margin:0 0 12px 0;color:var(--text-muted);font-size:11px;line-height:1.5;">
                  <strong>Purpose:</strong> Visualize pairwise correlations between timepoints. 
                  Darker colors indicate stronger correlations. Hover for details.
                </p>
                
                <!-- Interactive Controls -->
                <div style="padding:12px;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:6px;margin-bottom:12px;">
                  <div style="display:flex;align-items:center;gap:20px;flex-wrap:wrap;">
                    <div style="flex:0 0 auto;">
                      <label style="font-size:11px;font-weight:600;color:var(--text-secondary);margin-bottom:4px;display:block;">Correlation Type:</label>
                      <div style="display:flex;gap:8px;">
                        <button class="corr-type-btn active" data-type="pearson" onclick="switchCorrType('pearson')" style="padding:6px 12px;font-size:11px;border:2px solid #5c6bc0;background:#5c6bc0;color:#fff;border-radius:4px;cursor:pointer;font-weight:600;">Pearson</button>
                        <button class="corr-type-btn" data-type="spearman" onclick="switchCorrType('spearman')" style="padding:6px 12px;font-size:11px;border:2px solid #5c6bc0;background:transparent;color:#5c6bc0;border-radius:4px;cursor:pointer;font-weight:600;">Spearman</button>
                        <button class="corr-type-btn" data-type="kendall" onclick="switchCorrType('kendall')" style="padding:6px 12px;font-size:11px;border:2px solid #5c6bc0;background:transparent;color:#5c6bc0;border-radius:4px;cursor:pointer;font-weight:600;">Kendall</button>
                      </div>
                    </div>
                    
                    <div style="flex:0 0 auto;">
                      <label style="font-size:11px;font-weight:600;color:var(--text-secondary);margin-bottom:4px;display:block;">View:</label>
                      <div style="display:flex;gap:8px;">
                        <button class="corr-view-btn active" data-view="table" onclick="switchCorrView('table')" style="padding:6px 12px;font-size:11px;border:2px solid #f57c00;background:#f57c00;color:#fff;border-radius:4px;cursor:pointer;font-weight:600;">Table</button>
                        <button class="corr-view-btn" data-view="heatmap" onclick="switchCorrView('heatmap')" style="padding:6px 12px;font-size:11px;border:2px solid #f57c00;background:transparent;color:#f57c00;border-radius:4px;cursor:pointer;font-weight:600;">Heatmap</button>
                      </div>
                    </div>
                    
                    <div style="flex:1 1 auto;display:flex;align-items:center;gap:12px;justify-content:flex-end;">
                      <label style="display:flex;align-items:center;gap:4px;font-size:11px;cursor:pointer;">
                        <input type="checkbox" id="showCorrPValue" onchange="toggleCorrColumns()">
                        <span style="color:var(--text-secondary);font-weight:600;">Show p-value</span>
                      </label>
                      <label style="display:flex;align-items:center;gap:4px;font-size:11px;cursor:pointer;">
                        <input type="checkbox" id="showCorrN" onchange="toggleCorrColumns()">
                        <span style="color:var(--text-secondary);font-weight:600;">Show n</span>
                      </label>
                    </div>
                  </div>
                </div>
                
                <!-- Correlation Heatmap/Table -->
                <div id="correlationMatrixContainer" style="padding:10px;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:6px;">
                  <div id="correlationHeatmap" style="display:none;"></div>
                  <table id="correlationTable" style="width:100%;border-collapse:collapse;font-size:11px;">
                    <thead>
                      <tr id="corrTableHeader" style="background:#003366cc;"></tr>
                    </thead>
                    <tbody id="corrTableBody"></tbody>
                  </table>
                </div>
                
                <!-- Summary Statistics -->
                <div id="corrSummary" style="margin-top:12px;padding:8px 10px;background:rgba(120,200,255,.08);border-left:3px solid var(--accent-2);border-radius:4px;font-size:11px;">
                  <div style="color:var(--text-secondary);margin-bottom:6px;"><strong>Summary Statistics:</strong></div>
                  <div style="display:flex;flex-wrap:wrap;gap:12px;margin-bottom:8px;">
                    <span><strong>Avg r:</strong> <span id="corrAvgR" style="color:var(--accent-2);font-weight:700;">...</span></span>
                    <span><strong>Range:</strong> <span id="corrRange" style="color:var(--accent-2);font-weight:700;">...</span></span>
                    <span><strong>Compound Symmetry:</strong> <span id="corrCompound" style="color:var(--accent-2);font-weight:700;">...</span></span>
                  </div>
                  <div style="padding-top:8px;border-top:1px solid rgba(255,255,255,.15);">
                    <strong style="color:var(--text-secondary);">Interpretation:</strong>
                    <div style="margin-top:4px;color:var(--text-muted);font-style:italic;" id="corrInterpretation">...</div>
                  </div>
                </div>
              </div>
              
            </div>
          </div>
        </section>
        
        <section id="tab-assumptions" class="tab-panel">
          <div class="stat-panel">
            <div class="stat-panel-heading">Assumption Testing</div>
            <div class="stat-panel-body" style="padding:12px;">
              
              <!-- Design Balance Indicator -->
              <div id="designBalanceInfo" style="margin-bottom:16px;padding:8px 12px;background:rgba(120,200,255,.08);border-left:3px solid var(--accent-2);border-radius:4px;">
                <span style="font-size:12px;color:var(--text-secondary);"><strong>Design:</strong> <span id="balanceText">...</span></span>
              </div>
              
              <!-- Sphericity -->
              <div style="margin-bottom:20px;">
                <h4 style="color:var(--accent-1);margin:0 0 8px 0;font-size:13px;font-weight:700;">1. Sphericity (Mauchly's Test)</h4>
                <p style="margin:0 0 8px 0;color:var(--text-secondary);font-size:12px;line-height:1.5;">
                  <strong>Assumption:</strong> Variances of differences between all pairs of timepoints should be equal.<br/>
                  <strong>Hâ‚€:</strong> Sphericity assumption is met &nbsp;|&nbsp; <strong>Hâ‚:</strong> Sphericity is violated
                </p>
                <div style="display:flex;align-items:center;gap:12px;margin-bottom:6px;">
                  <span style="font-size:12px;color:var(--text-muted);">Mauchly's W:</span>
                  <span class="stat-value" id="asMauchlyW" style="min-width:80px;">...</span>
                  <span style="font-size:12px;color:var(--text-muted);">p-value:</span>
                  <span class="stat-value" id="asMauchlyP" style="min-width:80px;">...</span>
                  <span id="asMauchlyVerdict" style="font-size:12px;font-weight:600;"></span>
                </div>
                <div style="margin-top:12px;padding:10px;background:#f8f9fa;border-radius:6px;">
                  <div style="font-size:12px;color:#263238;margin-bottom:4px;"><strong>Corrections (if violated):</strong></div>
                  <div style="display:flex;gap:20px;font-size:12px;">
                    <div>
                      <span style="color:#546e7a;">Greenhouse-Geisser Îµ:</span>
                      <span class="stat-value" id="asEpsilonGG" style="margin-left:6px;background:rgba(74,144,226,0.15);color:#1976d2;">...</span>
                    </div>
                    <div>
                      <span style="color:#546e7a;">Huynh-Feldt Îµ:</span>
                      <span class="stat-value" id="asEpsilonHF" style="margin-left:6px;background:rgba(74,144,226,0.15);color:#1976d2;">...</span>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Design Balance (Optional) -->
              <div style="margin-bottom:20px;">
                <h4 style="color:var(--accent-1);margin:0 0 8px 0;font-size:13px;font-weight:700;">2. Missing Data</h4>
                <p style="margin:0 0 8px 0;color:var(--text-secondary);font-size:12px;line-height:1.5;">
                  Repeated measures ANOVA uses <strong>listwise deletion</strong>. Only subjects with complete data across all timepoints are included.
                </p>
                <div style="display:flex;align-items:center;gap:12px;">
                  <span style="font-size:12px;color:var(--text-muted);">Complete cases:</span>
                  <span class="stat-value" id="asCompleteCases">...</span>
                </div>
              </div>

              <!-- Final Recommendation -->
              <div style="background:rgba(255,165,120,.08);border-left:4px solid var(--accent-1);padding:12px;border-radius:6px;">
                <h4 style="color:var(--accent-1);margin:0 0 8px 0;font-size:13px;font-weight:700;">ðŸ“‹ Recommendation & Conclusion</h4>
                <p id="asRecoText" style="margin:0;color:var(--text-primary);font-size:12px;line-height:1.6;font-weight:600;"></p>
              </div>

            </div>
          </div>
        </section>
        <section id="tab-results" class="tab-panel">
          <div class="stat-panel">
            <div class="stat-panel-heading" id="primaryTestHeading">Repeated Measures ANOVA</div>
            <div class="stat-panel-body" style="padding:10px;">
              <div class="table-container" style="margin:0;max-height:none;">
                <table class="analysis-table" id="primaryTestTable">
                  <thead id="primaryTestTableHead">
                    <tr><th>Source</th><th>SS</th><th>df</th><th>MS</th><th>F</th><th>p-value</th></tr>
                  </thead>
                  <tbody id="anovaSummaryBody">
                    <tr><td>Treatments</td><td id="anova-ss-between">...</td><td id="anova-df1">...</td><td id="anova-ms-between">...</td><td id="anova-f">...</td><td id="anova-p">...</td></tr>
                    <tr><td>Within groups</td><td id="anova-ss-within">...</td><td id="anova-df2">...</td><td id="anova-ms-within">...</td><td></td><td></td></tr>
                    <tr><td>Total</td><td id="anova-ss-total">...</td><td id="anova-df-total">...</td><td></td><td></td><td></td></tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="stats-container" style="margin-top:12px;">
            <div class="stat-panel">
              <div class="stat-panel-heading">
                Timepoint Visualization
                <div style="float:right;display:inline-flex;gap:12px;font-size:11px;font-weight:600;">
                  <label style="display:inline-flex;align-items:center;gap:4px;cursor:pointer;">
                    <input type="radio" name="chartMetric" value="means" checked onchange="updateGroupChart()"> Means
                  </label>
                  <label style="display:inline-flex;align-items:center;gap:4px;cursor:pointer;">
                    <input type="radio" name="chartMetric" value="variances" onchange="updateGroupChart()"> Variances
                  </label>
                </div>
              </div>
              <div class="stat-panel-body" style="padding:8px;">
                <div id="groupChartContainer" style="width:100%;height:280px;"></div>
              </div>
            </div>
            <div class="stat-panel secondary" id="robustnessPanel" style="display:none;">
              <div class="stat-panel-heading">âš ï¸ Not Applicable for Repeated Measures</div>
              <div class="stat-panel-body">
                <div style="padding:20px;text-align:center;color:var(--text-muted);font-size:12px;">
                  <p style="margin:0 0 10px 0;"><strong>Levene, Brown-Forsythe, and Welch tests</strong> are designed for <strong>independent groups</strong> and test equality of variances <em>between</em> different subjects.</p>
                  <p style="margin:0;"><strong>In repeated measures:</strong> The same subjects are measured across timepoints. Sphericity (Mauchly's test) is the relevant assumption. See the <strong>Assumptions</strong> tab.</p>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- ===== POST-HOC TAB ===== -->
        <section id="tab-posthoc" class="tab-panel">
          <div class="stat-panel">
            <div class="stat-panel-heading parametric" id="posthocHeading">
              Post-hoc Pairwise Comparisons (Paired t-tests)
              <div style="float:right;display:inline-flex;gap:8px;align-items:center;font-size:11px;font-weight:600;text-transform:none;">
                <span style="opacity:0.8;">Filter:</span>
                <label style="display:inline-flex;align-items:center;gap:4px;cursor:pointer;">
                  <input type="radio" name="posthocGrouping" value="all" checked onchange="updatePosthocDisplay()"> All pairs
                </label>
                <label style="display:inline-flex;align-items:center;gap:4px;cursor:pointer;">
                  <input type="radio" name="posthocGrouping" value="ref" onchange="updatePosthocDisplay()"> vs Reference
                </label>
                <select id="posthocRefGroup" style="height:24px;padding:0 6px;border-radius:4px;background:#ffffff;border:1px solid rgba(255,255,255,0.2);color:#263238;font-size:11px;display:none;" onchange="updatePosthocDisplay()">
                  <option value="">Select timepoint...</option>
                </select>
              </div>
            </div>
            <div class="stat-panel-body" style="padding:8px;">
              <!-- Omnibus Warning -->
              <div id="posthocWarning" style="display:none;padding:8px 12px;margin-bottom:12px;background:rgba(251,191,36,.15);border-left:3px solid #fbbf24;border-radius:4px;">
                <span style="font-size:12px;color:#fbbf24;font-weight:600;">âš  Omnibus test not significant (p > Î±). Interpret post-hoc comparisons with caution.</span>
              </div>
              
              <!-- Post-hoc Configuration Controls -->
              <div style="display:flex;gap:16px;margin-bottom:16px;padding:12px;background:rgba(255,255,255,.06);border:1px solid var(--border);border-radius:6px;">
                <!-- Post-hoc Method -->
                <div style="flex:1;min-width:200px;">
                  <label style="font-size:11px;color:var(--text-secondary);margin-bottom:6px;font-weight:700;text-transform:uppercase;display:block;">Post-hoc Method</label>
                  <div id="posthocRadioGroup" style="display:flex;flex-direction:column;gap:4px;padding:8px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.15);border-radius:4px;">
                    <!-- Will be populated dynamically based on framework -->
                  </div>
                </div>
                
                <!-- P-value Correction -->
                <div style="flex:1;min-width:180px;">
                  <label style="font-size:11px;color:var(--text-secondary);margin-bottom:6px;font-weight:700;text-transform:uppercase;display:block;">p-value Correction</label>
                  <div style="display:flex;flex-direction:column;gap:4px;padding:8px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.15);border-radius:4px;">
                    <label class="posthoc-radio">
                      <input type="radio" name="pCorrection" value="holm" checked onchange="onPosthocSettingsChange()">
                      <span>Holm</span>
                    </label>
                    <label class="posthoc-radio">
                      <input type="radio" name="pCorrection" value="bonferroni" onchange="onPosthocSettingsChange()">
                      <span>Bonferroni</span>
                    </label>
                    <label class="posthoc-radio">
                      <input type="radio" name="pCorrection" value="bh" onchange="onPosthocSettingsChange()">
                      <span>FDR (Benjamini-Hochberg)</span>
                    </label>
                    <label class="posthoc-radio">
                      <input type="radio" name="pCorrection" value="none" onchange="onPosthocSettingsChange()">
                      <span>None</span>
                    </label>
                  </div>
                </div>
              </div>
              
              <div class="table-container" style="margin:0;">
                <table class="analysis-table" id="posthocTable">
                  <thead>
                    <tr>
                      <th style="cursor:pointer;" onclick="sortPosthocTable('comparison')">Comparison â†•</th>
                      <th style="cursor:pointer;" onclick="sortPosthocTable('statistic')">Statistic â†•</th>
                      <th style="cursor:pointer;" onclick="sortPosthocTable('rawp')">Raw p â†•</th>
                      <th style="cursor:pointer;" onclick="sortPosthocTable('adjp')">Adj p â†•</th>
                      <th style="cursor:pointer;" onclick="sortPosthocTable('estimate')">Estimate â†•</th>
                      <th style="cursor:pointer;" onclick="sortPosthocTable('ci')">95% CI â†•</th>
                      <th style="text-align:center;">Sig</th>
                    </tr>
                  </thead>
                  <tbody id="posthocBody">
                    <tr><td colspan="7">No post-hoc comparisons available</td></tr>
                  </tbody>
                </table>
              </div>
              
              <div style="margin-top:12px;padding:8px;background:rgba(120,200,255,.08);border-radius:4px;font-size:11px;color:var(--text-secondary);">
                <strong>Note:</strong> <span id="posthocMethodNote">...</span>
              </div>
            </div>
          </div>
        </section>

        <section id="tab-effects" class="tab-panel">
          <div class="stats-container">
            <div class="stat-panel">
              <div class="stat-panel-heading parametric">Parametric Effect Sizes</div>
              <div class="stat-panel-body">
                <div class="stat-field"><span class="stat-label">Partial Î·Â² (SPSS)</span><span class="stat-value" id="efPartialEta">...</span></div>
                <div class="stat-field"><span class="stat-label">Generalized Î·Â² (JASP)</span><span class="stat-value" id="efGeneralizedEta">...</span></div>
                <div class="stat-field"><span class="stat-label">Eta squared</span><span class="stat-value" id="efEta">...</span></div>
                <div class="stat-field"><span class="stat-label">Omega squared</span><span class="stat-value" id="efOmega">...</span></div>
                <div class="stat-field"><span class="stat-label">Cohen's f</span><span class="stat-value" id="efCohenF">...</span></div>
              </div>
            </div>
            <div class="stat-panel">
              <div class="stat-panel-heading nonparametric">Non-parametric Effect Sizes</div>
              <div class="stat-panel-body">
                <div class="stat-field"><span class="stat-label">Kendall's W</span><span class="stat-value" id="efKendallW">...</span></div>
                <div class="stat-field"><span class="stat-label">Friedman Ï‡Â²</span><span class="stat-value" id="efFriedmanChi">...</span></div>
                <div class="stat-field"><span class="stat-label">Epsilon squared</span><span class="stat-value" id="efEpsilonSq">...</span></div>
              </div>
            </div>
          </div>
        </section>
        <section id="tab-power" class="tab-panel">
          <div class="power-analysis-header" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
            <h2 style="margin:0;font-size:1em;color:#ff9d5c;"><i class="fa-solid fa-bolt"></i> Power Analysis</h2>
          </div>
          
          <div class="stats-container" style="display:grid;grid-template-columns:1fr 1fr;gap:6px;">
            <!-- Observed Statistics Panel -->
            <div class="stat-panel" style="background:#3a3d4a;padding:6px 8px;border-radius:4px;">
              <div class="stat-panel-heading" style="font-size:0.8em;margin-bottom:3px;color:#9db4ff;border-bottom:1px solid rgba(157,180,255,0.2);padding-bottom:2px;">Observed Statistics</div>
              <div class="stat-panel-body">
                <div class="stat-field" style="margin-bottom:3px;display:grid;grid-template-columns:1fr 1fr;align-items:baseline;">
                  <span class="stat-label" style="color:#a0a0a0;font-size:0.65em;text-transform:uppercase;letter-spacing:0.2px;">Observed Power</span>
                  <span class="stat-value" id="powObserved" style="font-size:1.2em;color:#ff9d5c;font-weight:bold;text-align:right;">...</span>
                </div>
                <div class="stat-field" style="margin-bottom:3px;display:grid;grid-template-columns:1fr 1fr;align-items:baseline;">
                  <span class="stat-label" style="color:#a0a0a0;font-size:0.65em;text-transform:uppercase;letter-spacing:0.2px;">Effect Size (f)</span>
                  <span class="stat-value" id="powEffectSize" style="font-size:1em;color:#ff9d5c;font-weight:bold;text-align:right;">...</span>
                </div>
                <div class="stat-field" style="display:grid;grid-template-columns:1fr 1fr;align-items:baseline;">
                  <span class="stat-label" style="color:#a0a0a0;font-size:0.65em;text-transform:uppercase;letter-spacing:0.2px;">Sample Size</span>
                  <span class="stat-value" id="powSampleSize" style="font-size:1em;color:#ff9d5c;font-weight:bold;text-align:right;">...</span>
                </div>
              </div>
            </div>
            
            <!-- Target Power 80% Panel -->
            <div class="stat-panel" style="background:#3a3d4a;padding:6px 8px;border-radius:4px;">
              <div class="stat-panel-heading" style="font-size:0.8em;margin-bottom:3px;color:#9db4ff;border-bottom:1px solid rgba(157,180,255,0.2);padding-bottom:2px;">Target Power (80%)</div>
              <div class="stat-panel-body">
                <div class="stat-field" style="margin-bottom:3px;display:grid;grid-template-columns:1fr 1fr;align-items:baseline;">
                  <span class="stat-label" style="color:#a0a0a0;font-size:0.65em;text-transform:uppercase;letter-spacing:0.2px;">Required N</span>
                  <span class="stat-value" id="powRequired" style="font-size:1.2em;color:#ff9d5c;font-weight:bold;text-align:right;">...</span>
                </div>
                <div class="stat-field" style="margin-bottom:3px;display:grid;grid-template-columns:1fr 1fr;align-items:baseline;">
                  <span class="stat-label" style="color:#a0a0a0;font-size:0.65em;text-transform:uppercase;letter-spacing:0.2px;">Alpha</span>
                  <span class="stat-value" id="powAlpha" style="font-size:0.9em;color:white;text-align:right;">0.050</span>
                </div>
                <div class="stat-field" style="display:grid;grid-template-columns:1fr 1fr;align-items:baseline;">
                  <span class="stat-label" style="color:#a0a0a0;font-size:0.65em;text-transform:uppercase;letter-spacing:0.2px;">Partial Î·Â²</span>
                  <span class="stat-value" id="powPartialEta" style="font-size:0.9em;color:white;text-align:right;">...</span>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Power Status Message -->
          <div id="powStatusMessage" style="margin-top:4px;padding:4px 6px;background:#2d5f3f;border-radius:3px;color:#7fdb9f;text-align:center;font-size:0.75em;">
            Calculating power analysis...
          </div>
          
          <!-- Required N for Power Levels (4 cards in a row) -->
          <div style="margin-top:6px;display:grid;grid-template-columns:repeat(4,1fr);gap:6px;">
            <!-- 85% Power Card -->
            <div style="background:#3a3d4a;padding:6px;border-radius:3px;text-align:center;">
              <div style="color:#a0a0a0;font-size:0.65em;margin-bottom:2px;text-transform:uppercase;">85% Power</div>
              <div id="powReq85" style="font-size:1.3em;color:#ff9d5c;font-weight:bold;">...</div>
            </div>
            
            <!-- 90% Power Card -->
            <div style="background:#3a3d4a;padding:6px;border-radius:3px;text-align:center;">
              <div style="color:#a0a0a0;font-size:0.65em;margin-bottom:2px;text-transform:uppercase;">90% Power</div>
              <div id="powReq90" style="font-size:1.3em;color:#ff9d5c;font-weight:bold;">...</div>
            </div>
            
            <!-- 95% Power Card -->
            <div style="background:#3a3d4a;padding:6px;border-radius:3px;text-align:center;">
              <div style="color:#a0a0a0;font-size:0.65em;margin-bottom:2px;text-transform:uppercase;">95% Power</div>
              <div id="powReq95" style="font-size:1.3em;color:#ff9d5c;font-weight:bold;">...</div>
            </div>
            
            <!-- Custom Power Calculator Card -->
            <div style="background:#3a4a3d;padding:6px;border-radius:3px;border:1px solid #5a7a5d;text-align:center;">
              <div style="color:#9dffb4;font-size:0.65em;margin-bottom:2px;text-transform:uppercase;">Custom Power...</div>
              <div style="display:flex;align-items:center;justify-content:center;gap:4px;margin-bottom:2px;">
                <input type="number" id="customPowerInput" min="0.5" max="0.99" step="0.01" value="0.85" 
                       style="width:50px;padding:2px 4px;background:#2a2d38;color:white;border:1px solid #5a7a5d;border-radius:2px;font-size:11px;font-weight:bold;text-align:center;"
                       placeholder="0.85">
                <button onclick="calculateCustomPower()" 
                        style="padding:3px 6px;background:#5fad72;color:white;border:none;border-radius:2px;cursor:pointer;font-size:10px;">
                  <i class="fa-solid fa-sync" id="customPowerIcon"></i>
                </button>
              </div>
              <div id="customRequiredN" style="font-size:1.3em;color:#7fdb9f;font-weight:bold;">--</div>
              <div id="customPowerStatus" style="margin-top:2px;color:#b5d4bd;font-size:0.6em;display:none;">
                <i class="fa-solid fa-spinner fa-spin"></i> Calculating...
              </div>
            </div>
          </div>
          
          <div class="section-note" style="margin-top:4px;padding:4px;background:#2a2d38;border-radius:3px;color:#b0b0b0;font-size:0.7em;">
            <i class="fa-solid fa-cloud"></i> <span id="powEngineNote">Power calculated via Python Google Cloud Functions using non-central F distribution. Effect size: Cohen's f from partial Î·Â².</span>
          </div>
        </section>
        <section id="tab-ai-interpretation" class="tab-panel">
          <!-- API Key Configuration -->
          <div class="stat-panel" style="background:#1e3a8a;border-color:#3b82f6;margin-bottom:12px;">
            <div class="stat-panel-heading" style="background:#1e40af;font-size:11px;padding:6px 10px;">
              <i class="fa-solid fa-key"></i> API Key Configuration
            </div>
            <div class="stat-panel-body" style="padding:10px;">
              <div style="display:flex;gap:8px;align-items:center;">
                <input type="password" id="groqApiKeyInput" placeholder="Enter your Groq API key" 
                       style="flex:1;padding:6px 10px;background:#1e293b;color:white;border:1px solid #3b82f6;border-radius:4px;font-size:11px;">
                <button onclick="saveApiKey()" 
                        style="padding:6px 12px;background:#3b82f6;color:white;border:none;border-radius:4px;cursor:pointer;font-size:11px;font-weight:600;">
                  <i class="fa-solid fa-save"></i> Save
                </button>
                <button onclick="clearApiKey()" 
                        style="padding:6px 12px;background:#dc2626;color:white;border:none;border-radius:4px;cursor:pointer;font-size:11px;font-weight:600;">
                  <i class="fa-solid fa-trash"></i>
                </button>
              </div>
              <div style="margin-top:8px;display:flex;gap:8px;align-items:center;">
                <label style="font-size:11px;color:#93c5fd;white-space:nowrap;"><i class="fa-solid fa-robot"></i> Model:</label>
                <select id="aiModelSelect" onchange="saveModelPreference()" 
                        style="flex:1;padding:6px 10px;background:#1e293b;color:white;border:1px solid #3b82f6;border-radius:4px;font-size:11px;cursor:pointer;">
                  <option value="mixtral-8x7b-32768">Mixtral-8x7b (Best quality, ~$0.0004/call)</option>
                  <option value="gpt-oss-20b">GPT OSS 20B (Faster, 2x cheaper, ~$0.0002/call)</option>
                </select>
              </div>
              <div style="margin-top:6px;font-size:10px;color:#93c5fd;">
                <i class="fa-solid fa-info-circle"></i> Get your free API key at <a href="https://console.groq.com" target="_blank" style="color:#60a5fa;">console.groq.com</a>
              </div>
            </div>
          </div>
          
          <!-- AI Interpretation Header -->
          <div class="stat-panel">
            <div class="stat-panel-heading" style="background:#5b21b6;display:flex;justify-content:space-between;align-items:center;">
              <span><i class="fa-solid fa-brain"></i> AI-Generated Interpretation</span>
              <button onclick="generateAIInterpretation()" 
                      style="padding:5px 12px;background:#7c3aed;color:white;border:none;border-radius:4px;cursor:pointer;font-size:11px;font-weight:600;">
                <i class="fa-solid fa-sync" id="aiGenIcon"></i> Generate
              </button>
            </div>
            <div class="stat-panel-body" style="padding:12px;">
              <div id="aiInterpretationContent" style="min-height:200px;line-height:1.6;color:var(--text-secondary);font-size:13px;">
                <div style="text-align:center;padding:40px;color:var(--text-muted);">
                  <i class="fa-solid fa-wand-magic-sparkles" style="font-size:3em;opacity:0.3;margin-bottom:10px;"></i>
                  <p>Click "Generate" to create a comprehensive, APA-style interpretation of your repeated measures analysis.</p>
                  <p style="font-size:11px;margin-top:10px;">The AI will integrate design, assumptions, omnibus results, post-hoc tests, effect sizes, and power analysis into a cohesive narrative.</p>
                </div>
              </div>
              <div id="aiInterpretationSpinner" style="display:none;text-align:center;padding:20px;">
                <i class="fa-solid fa-spinner fa-spin" style="font-size:2em;color:#7c3aed;"></i>
                <p style="margin-top:10px;color:var(--text-muted);">Generating interpretation...</p>
              </div>
            </div>
          </div>
          
          <!-- Data Preview for AI -->
          <div class="stat-panel" style="margin-top:12px;">
            <div class="stat-panel-heading" style="font-size:11px;padding:6px 10px;cursor:pointer;" onclick="toggleAIDataPreview()">
              <i class="fa-solid fa-database"></i> Data Summary for AI <i class="fa-solid fa-chevron-down" id="aiDataChevron"></i>
            </div>
            <div class="stat-panel-body" id="aiDataPreview" style="display:none;padding:8px;max-height:300px;overflow-y:auto;">
              <pre id="aiDataPreviewContent" style="font-size:10px;color:#7dd3fc;background:#0c1624;padding:10px;border-radius:4px;overflow-x:auto;"></pre>
            </div>
          </div>
          
          <div class="section-note" style="margin-top:8px;">
            <i class="fa-solid fa-robot"></i> AI-powered interpretation uses advanced language models to generate human-readable narratives from statistical results. The interpretation follows APA guidelines and integrates all analysis components.
          </div>
        </section>
      </div>
    </section>
  </div>
  
  <!-- Normality Tests Modal -->
  <div class="modal-overlay" id="normality-modal" style="display:none;">
    <div class="modal-content" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:90%;max-width:900px;max-height:90vh;background-color:var(--surface-1);border-radius:10px;box-shadow:0 4px 20px rgba(0,0,0,.4);border:1px solid var(--border);overflow-y:auto;">
      <div class="modal-header" style="background-color:var(--surface-0);padding:15px 20px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;">
        <div class="modal-title" style="color:var(--accent-1);font-size:1.2rem;font-weight:600;">
          Normality Tests - <span id="modal-variable-name">Variable</span> <span id="modal-sample-size">(n=â€”)</span>
        </div>
        <button class="close-btn" onclick="closeNormalityModal()" style="background:none;border:none;color:var(--text-secondary);font-size:1.5rem;cursor:pointer;padding:0;width:30px;height:30px;display:flex;align-items:center;justify-content:center;">&times;</button>
      </div>
      <div class="modal-body" style="padding:20px;">
        <div style="text-align:center;padding:10px;font-size:14px;font-weight:bold;">
          Normality testing placeholder (can be wired to Python service if needed)
        </div>
        <div style="padding:20px;background:rgba(255,165,120,.1);border-left:3px solid var(--accent-1);margin-top:10px;">
          <strong>Selected Variable:</strong> <span id="modal-variable-detail">â€”</span><br/>
          <strong>Sample Size:</strong> <span id="modal-n-detail">â€”</span><br/>
          <strong>Mean:</strong> <span id="modal-mean-detail">â€”</span><br/>
          <strong>StdDev:</strong> <span id="modal-sd-detail">â€”</span>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    let globalDecimalPrecision = "auto";
    let lastBundle = null;
    let primaryFramework = "parametric";
    let availableHeaders = [];
    let currentCompareMode = "k-plus";
    let currentHypothesis = "two-sided";
    let currentPrimaryTest = "welch";
    let persistedColumns = { groupA: "", groupB: "", valueColumn: "", groupColumn: "" };
    
    function onFrameworkChange() {
      const fwRadio = document.querySelector('input[name="frameworkMode"]:checked');
      const newFramework = fwRadio ? fwRadio.value : "parametric";
      primaryFramework = newFramework;
      
      // Update test method cards based on framework
      const rmAnovaCard = document.getElementById("testRmAnovaCard");
      const friedmanCard = document.getElementById("testFriedmanCard");
      
      if (newFramework === "parametric") {
        // Enable RM-ANOVA, disable Friedman
        if (rmAnovaCard) {
          rmAnovaCard.classList.add("active");
          rmAnovaCard.classList.remove("disabled", "nonparametric-active");
        }
        if (friedmanCard) {
          friedmanCard.classList.remove("active", "nonparametric-active");
          friedmanCard.classList.add("disabled");
        }
        currentPrimaryTest = "rm-anova";
      } else {
        // Enable Friedman, disable RM-ANOVA
        if (rmAnovaCard) {
          rmAnovaCard.classList.remove("active");
          rmAnovaCard.classList.add("disabled");
        }
        if (friedmanCard) {
          friedmanCard.classList.add("active", "nonparametric-active");
          friedmanCard.classList.remove("disabled");
        }
        currentPrimaryTest = "friedman";
      }
      
      // Update post-hoc options
      updatePosthocOptions();
      refreshHypothesisFrames();
      
      // Trigger recalculation
      notifySettingsChanged();
    }
    
    function onTestMethodChange() {
      // Test method cards are now display-only, controlled by framework
      // This function kept for compatibility but doesn't need to do anything
    }
    
    function parseMaybeNumber(v){ if(v===undefined||v===null) return NaN; const n=Number(String(v).replace(",",".")); return isFinite(n)?n:NaN; }
    function fmt(v){ const n=parseMaybeNumber(v); if(!isFinite(n)) return v==null?"...":String(v); if(globalDecimalPrecision==="auto"){ if(Math.abs(n)<1&&n!==0) return n.toFixed(4); return n.toFixed(2);} return n.toFixed(parseInt(globalDecimalPrecision,10)); }
    function fmtP(v){ const n=parseMaybeNumber(v); if(!isFinite(n)) return v==null?"...":String(v); if(n < 0.001) return "< 0.001"; return globalDecimalPrecision === "auto" ? n.toFixed(4) : n.toFixed(Math.max(3, parseInt(globalDecimalPrecision,10))); }
    function setDecimalPrecision(){ globalDecimalPrecision=(document.getElementById("decimalSelect")||{value:"auto"}).value; if(lastBundle) populateBundle(lastBundle); }
    function setText(id,val){ const el=document.getElementById(id); if(el) el.textContent = (val!==undefined&&val!==null&&val!=="")?val:"..."; }
    let activeTab = "explore";
    function switchTab(tab){
      if (!tab || tab === activeTab) return;
      const prevBtn = document.querySelector('.tab-button[data-tab="' + activeTab + '"]');
      const nextBtn = document.querySelector('.tab-button[data-tab="' + tab + '"]');
      const prevPanel = document.getElementById("tab-" + activeTab);
      const nextPanel = document.getElementById("tab-" + tab);
      if (prevBtn) prevBtn.classList.remove("active");
      if (nextBtn) nextBtn.classList.add("active");
      if (prevPanel) prevPanel.classList.remove("active");
      if (nextPanel) nextPanel.classList.add("active");
      activeTab = tab;
    }
    function sendToHost(cmd,data){ if(Office&&Office.context&&Office.context.ui&&Office.context.ui.messageParent) Office.context.ui.messageParent(JSON.stringify({action:"HOST_EVENT",cmd:cmd,data:data||{}})); }
    function fillSelect(id, options, selected){
      const el = document.getElementById(id);
      if (!el) return;
      el.innerHTML = (options || []).map(function(v){ return '<option value="' + v + '">' + v + '</option>'; }).join("");
      if (selected !== undefined && selected !== null && String(selected) !== "") el.value = String(selected);
    }
    function currentSettingsSpec(){
      var hChecked = document.querySelector('input[name="h1Orientation"]:checked');
      var h = hChecked ? hChecked.value : "two-sided";
      currentHypothesis = h;
      var alpha = Number((document.getElementById("setAlpha") || { value: "0.05" }).value || 0.05);
      if (!isFinite(alpha) || alpha <= 0 || alpha >= 1) alpha = 0.05;
      
      // Get post-hoc method and correction from radio buttons
      var posthocMethodChecked = document.querySelector('input[name="posthocMethod"]:checked');
      var pCorrectionChecked = document.querySelector('input[name="pCorrection"]:checked');
      
      // Test method is determined by framework (no radio buttons)
      var primaryTest = primaryFramework === "nonparametric" ? "friedman" : "rm-anova";
      
      return {
        compareMode: currentCompareMode,
        primaryFramework: primaryFramework,
        hypothesis: h,
        confidence: 1 - alpha,
        groupA: persistedColumns.groupA || "",
        groupB: persistedColumns.groupB || "",
        valueColumn: persistedColumns.valueColumn || "",
        groupColumn: persistedColumns.groupColumn || "",
        primaryTest: primaryTest,
        posthocMethod: posthocMethodChecked ? posthocMethodChecked.value : "paired",
        posthocCorrection: pCorrectionChecked ? pCorrectionChecked.value : "holm"
      };
    }
    function refreshHypothesisFrames(){
      var h0 = document.getElementById("h0Text");
      var h1Row = document.getElementById("h1Row");
      if (!h0 || !h1Row) return;
      h0.textContent = "All timepoint means equal";
      h1Row.innerHTML = '<span style="color:#1f2937;font-weight:800;">At least one timepoint differs.</span>';
    }
    function refreshSettingsVisibility(){
      const setDisplay = (id, show) => { const el = document.getElementById(id); if (el) el.style.display = show ? "flex" : "none"; };
      setDisplay("setPosthocWrap", true); setDisplay("setCorrectionWrap", true);
      setDisplay("setHypWrap", true);
      refreshHypothesisFrames();
    }
    function updatePosthocOptions(){
      const radioGroup = document.getElementById("posthocRadioGroup");
      if (!radioGroup) return;
      
      const isNonParam = primaryFramework === "nonparametric" || currentPrimaryTest === "friedman";
      
      // Get current selection
      const currentSelected = document.querySelector('input[name="posthocMethod"]:checked');
      const currentValue = currentSelected ? currentSelected.value : "";
      
      // Smart context-aware options based on framework
      if (!isNonParam) {
        // PARAMETRIC (RM-ANOVA): Paired t-tests
        radioGroup.innerHTML = `
          <label class="posthoc-radio">
            <input type="radio" name="posthocMethod" value="paired" ${currentValue === "paired" || !currentValue ? "checked" : ""} onchange="onPosthocSettingsChange()">
            <span>Paired t-tests</span>
          </label>
        `;
      } else {
        // NONPARAMETRIC (Friedman): Wilcoxon, Conover, Nemenyi
        radioGroup.innerHTML = `
          <label class="posthoc-radio">
            <input type="radio" name="posthocMethod" value="wilcoxon" ${currentValue === "wilcoxon" || (!currentValue && isNonParam) ? "checked" : ""} onchange="onPosthocSettingsChange()">
            <span>Wilcoxon Signed-Rank</span>
          </label>
          <label class="posthoc-radio">
            <input type="radio" name="posthocMethod" value="conover" ${currentValue === "conover" ? "checked" : ""} onchange="onPosthocSettingsChange()">
            <span>Conover</span>
          </label>
          <label class="posthoc-radio">
            <input type="radio" name="posthocMethod" value="nemenyi" ${currentValue === "nemenyi" ? "checked" : ""} onchange="onPosthocSettingsChange()">
            <span>Nemenyi</span>
          </label>
        `;
      }
    }
    
    function onPosthocSettingsChange() {
      // When user changes post-hoc method or correction, trigger recalculation
      console.log("Post-hoc settings changed - triggering recalculation");
      const spec = currentSettingsSpec();
      
      // Save settings
      notifySettingsChanged();
      
      // Request host to recompute with new settings
      sendToHost("recomputeWithSettings", spec);
    }
    function setFrameworkButtons(mode){
      primaryFramework = mode === "nonparametric" ? "nonparametric" : "parametric";
      
      // Update framework radio buttons
      var rp = document.getElementById("fwParametric");
      var rn = document.getElementById("fwNonparametric");
      if (rp) rp.checked = primaryFramework === "parametric";
      if (rn) rn.checked = primaryFramework === "nonparametric";
      
      // Update test method cards
      const rmAnovaCard = document.getElementById("testRmAnovaCard");
      const friedmanCard = document.getElementById("testFriedmanCard");
      
      if (primaryFramework === "parametric") {
        if (rmAnovaCard) {
          rmAnovaCard.classList.add("active");
          rmAnovaCard.classList.remove("disabled", "nonparametric-active");
        }
        if (friedmanCard) {
          friedmanCard.classList.remove("active", "nonparametric-active");
          friedmanCard.classList.add("disabled");
        }
        currentPrimaryTest = "rm-anova";
      } else {
        if (rmAnovaCard) {
          rmAnovaCard.classList.remove("active");
          rmAnovaCard.classList.add("disabled");
        }
        if (friedmanCard) {
          friedmanCard.classList.add("active", "nonparametric-active");
          friedmanCard.classList.remove("disabled");
        }
        currentPrimaryTest = "friedman";
      }
      
      // Update panel headings
      document.querySelectorAll(".stat-panel-heading").forEach(function(h){
        h.classList.remove("parametric", "nonparametric");
        h.classList.add(primaryFramework);
      });
      
      updatePosthocOptions();
      refreshHypothesisFrames();
    }
    function notifySettingsChanged(){
      const spec = currentSettingsSpec();
      refreshSettingsVisibility();
      var alphaVal = document.getElementById("alphaVal");
      if (alphaVal) alphaVal.textContent = (1 - (spec.confidence || 0.95)).toFixed(3);
      sendToHost("dependentSettingsChanged", spec);
    }
    function renderCompareStatsRow(s, e){
      var host = document.getElementById("compareStatsRow");
      var msgHost = document.getElementById("designMessageRow");
      if (!host) return;
      host.innerHTML = "";
      if (msgHost) { msgHost.textContent = ""; msgHost.style.display = "none"; }
      var ksum = e.kplusSummary || {};
      var ob = (lastBundle && lastBundle.results && lastBundle.results.omnibus) ? lastBundle.results.omnibus : {};
      
      var groupDescriptives = Array.isArray(ob.groupDescriptives) ? ob.groupDescriptives.filter(function(cs){
        return isFinite(parseMaybeNumber(cs && cs.n)) && parseMaybeNumber(cs.n) > 0;
      }).slice(0, 8) : [];
      if (groupDescriptives.length) {
        groupDescriptives.forEach(function(cs){
          var n = parseMaybeNumber(cs.n);
          var m = parseMaybeNumber(cs.mean);
          var chip = document.createElement("span");
          chip.className = "stat-chip";
          chip.textContent = (cs.name || "Variable") + " (n=" + (isFinite(n) ? Math.round(n) : "?") + ", xÌ„=" + (isFinite(m) ? fmt(m) : "?") + ")";
          chip.style.fontSize = "11px";
          host.appendChild(chip);
        });
      } else {
        var names = Array.isArray(s.selectedColumns) ? s.selectedColumns.slice(0, 8) : [];
        names.forEach(function(nm){
          var nChip = document.createElement("span");
          nChip.className = "stat-chip";
          nChip.textContent = nm;
          nChip.style.fontSize = "11px";
          host.appendChild(nChip);
        });
        if (Array.isArray(s.selectedColumns) && s.selectedColumns.length > 8) {
          var moreChip = document.createElement("span");
          moreChip.className = "stat-chip";
          moreChip.textContent = "+" + (s.selectedColumns.length - 8) + " more";
          moreChip.style.opacity = "0.85";
          host.appendChild(moreChip);
        }
      }
      var design = s.designValidation || {};
      if (msgHost) {
        if (design.message) {
          msgHost.textContent = design.message;
          msgHost.style.display = "block";
        } else {
          msgHost.textContent = "";
          msgHost.style.display = "none";
        }
      }
    }
    function updateResultsPanels(r, fx, s, a){
      setText("resPrimaryFramework", primaryFramework === "nonparametric" ? "Nonparametric (ranks)" : "Parametric (means)");
      const alpha = isFinite(parseMaybeNumber(a)) ? parseMaybeNumber(a) : (1 - (parseMaybeNumber(s && s.confidence) || 0.95));
      if (r && r.omnibus) {
        const ob = r.omnibus;
        const paramPrimary = primaryFramework !== "nonparametric";
        if (paramPrimary) {
          setText("resPrimaryTest", "Repeated Measures ANOVA");
          setText("resPrimaryStat", "F(" + Math.round(ob.anovaDf1) + ", " + Math.round(ob.anovaDf2) + ") = " + fmt(ob.anovaF));
          setText("resPrimaryP", fmtP(ob.anovaP));
          setText("resPrimaryEstimate", "Omnibus effect across " + fmt(ob.levels ? ob.levels.length : 0) + " timepoints");
          setText("resSecondaryTest", "Friedman test");
          setText("resSecondaryStat", "Ï‡Â²(" + Math.round(ob.kwDf) + ") = " + fmt(ob.kwH));
          setText("resSecondaryP", fmtP(ob.kwP));
        } else {
          setText("resPrimaryTest", "Friedman test");
          setText("resPrimaryStat", "Ï‡Â²(" + Math.round(ob.kwDf) + ") = " + fmt(ob.kwH));
          setText("resPrimaryP", fmtP(ob.kwP));
          setText("resPrimaryEstimate", "Rank-based comparison across " + fmt(ob.levels ? ob.levels.length : 0) + " timepoints");
          setText("resSecondaryTest", "Repeated Measures ANOVA");
          setText("resSecondaryStat", "F(" + Math.round(ob.anovaDf1) + ", " + Math.round(ob.anovaDf2) + ") = " + fmt(ob.anovaF));
          setText("resSecondaryP", fmtP(ob.anovaP));
        }
        const agreeElK = document.getElementById("resAgreement");
        const aSig = parseMaybeNumber(ob.anovaP) < alpha;
        const kSig = parseMaybeNumber(ob.kwP) < alpha;
        if (aSig === kSig) {
          setText("resAgreement", "Agree at alpha");
          if (agreeElK) agreeElK.className = "stat-value agreement-good";
          setText("resHint", "Omnibus conclusions are consistent across frameworks.");
        } else {
          setText("resAgreement", "Disagree at alpha");
          if (agreeElK) agreeElK.className = "stat-value agreement-warn";
          setText("resHint", "Consider non-normality/heteroscedasticity and run post-hoc with correction.");
        }

        // ANOVA summary block
        const anovaBody = document.getElementById("anovaSummaryBody");
        const primaryTestHeading = document.getElementById("primaryTestHeading");
        const primaryTestTableHead = document.getElementById("primaryTestTableHead");
        
        console.log("ðŸ” Populating ANOVA table with omnibus data:", ob);
        console.log("ðŸ“Š ANOVA Values:", {
          SSBetween: ob.anovaSSBetween,
          SSWithin: ob.anovaSSWithin,
          SSTotal: ob.anovaSSTotal,
          df1: ob.anovaDf1,
          df2: ob.anovaDf2,
          MSBetween: ob.anovaMSBetween,
          MSWithin: ob.anovaMSWithin,
          F: ob.anovaF,
          P: ob.anovaP
        });
        
        // Update table based on framework selection
        const isNonParametric = primaryFramework === "nonparametric";
        
        if (isNonParametric) {
          // Friedman Test (Non-parametric)
          if (primaryTestHeading) primaryTestHeading.textContent = "Friedman Test (Non-parametric)";
          if (primaryTestTableHead) {
            primaryTestTableHead.innerHTML = '<tr><th>Timepoint</th><th>Mean Rank</th><th>Ï‡Â²</th><th>df</th><th>p-value</th><th>Kendall W</th></tr>';
          }
          if (anovaBody) {
            const meanRanks = ob.friedmanMeanRanks || ob.meanRanks || {};
            const rankKeys = Object.keys(meanRanks);
            const chiSquare = ob.friedmanChiSquare || ob.kwH;
            const df = ob.friedmanDf || ob.kwDf;
            const pValue = ob.friedmanP || ob.kwP;
            const kendallW = ob.kendallW || ob.friedmanW || 0;
            
            let rowsHtml = rankKeys.map(function(key, idx) {
              return '<tr>' 
                + '<td>' + key.replace('Timepoint', 'Time') + '</td>'
                + '<td>' + fmt(meanRanks[key]) + '</td>'
                + '<td>' + (idx === 0 ? '<strong>' + fmt(chiSquare) + '</strong>' : '') + '</td>'
                + '<td>' + (idx === 0 ? Math.round(df) : '') + '</td>'
                + '<td>' + (idx === 0 ? '<strong>' + fmtP(pValue) + '</strong>' : '') + '</td>'
                + '<td>' + (idx === 0 ? fmt(kendallW) + ' <span style="font-size:9px;color:#aaa;">(effect size)</span>' : '') + '</td>'
                + '</tr>';
            }).join('');
            
            if (rankKeys.length === 0) {
              rowsHtml = '<tr><td colspan="6" style="text-align:center;">No rank data available</td></tr>';
            }
            anovaBody.innerHTML = rowsHtml;
            console.log("âœ… Friedman test table populated successfully");
          }
        } else {
          // Repeated Measures ANOVA (Parametric)
          if (primaryTestHeading) primaryTestHeading.textContent = "Repeated Measures ANOVA (Parametric)";
          if (primaryTestTableHead) {
            primaryTestTableHead.innerHTML = '<tr><th>Source</th><th>SS</th><th>df</th><th>MS</th><th>F</th><th>p-value</th></tr>';
          }
          if (anovaBody) {
            const dfTime = parseMaybeNumber(ob.anovaDf1);
            const dfError = parseMaybeNumber(ob.anovaDf2);
            const dfSubjects = parseMaybeNumber(ob.anovaDfSubjects);
            const dfTotal = isFinite(dfTime) && isFinite(dfError) && isFinite(dfSubjects) ? dfTime + dfError + dfSubjects : NaN;
            
            // Proper RM-ANOVA table: Time, Subjects, Error
            anovaBody.innerHTML = ''
              + '<tr style="background:rgba(74,144,226,0.15);"><td><strong>Time (Treatment)</strong></td><td>' + fmt(ob.anovaSSTime || ob.anovaSSBetween) + '</td><td>' + (isFinite(dfTime) ? Math.round(dfTime) : '...') + '</td><td>' + fmt(ob.anovaMSTime || ob.anovaMSBetween) + '</td><td>' + fmt(ob.anovaF) + '</td><td><strong>' + fmtP(ob.anovaP) + '</strong></td></tr>'
              + '<tr style="background:rgba(255,255,255,0.03);"><td>Subjects (Between)</td><td>' + fmt(ob.anovaSSSubjects) + '</td><td>' + (isFinite(dfSubjects) ? Math.round(dfSubjects) : '...') + '</td><td>' + fmt(ob.anovaMSSubjects) + '</td><td style="color:#666;">â€”</td><td style="color:#666;">â€”</td></tr>'
              + '<tr style="background:rgba(255,255,255,0.03);"><td>Error (Time Ã— Subject)</td><td>' + fmt(ob.anovaSSError || ob.anovaSSWithin) + '</td><td>' + (isFinite(dfError) ? Math.round(dfError) : '...') + '</td><td>' + fmt(ob.anovaMSError || ob.anovaMSWithin) + '</td><td style="color:#666;">â€”</td><td style="color:#666;">â€”</td></tr>'
              + '<tr style="border-top:2px solid rgba(255,165,120,0.5);font-weight:700;"><td>Total</td><td>' + fmt(ob.anovaSSTotal) + '</td><td>' + (isFinite(dfTotal) ? Math.round(dfTotal) : '...') + '</td><td style="color:#666;">â€”</td><td style="color:#666;">â€”</td><td style="color:#666;">â€”</td></tr>';
            console.log("âœ… RM-ANOVA table populated successfully with proper structure");
          }
        }
        
        if (!anovaBody) {
          console.error("âŒ ANOVA table body not found!");
        }
        // Update group visualization chart
        updateGroupChart();

        // REMOVED: Levene/Brown-Forsythe/Welch tests - not valid for repeated measures
        // These tests are for independent groups. RM uses sphericity instead.
        // const varBody = document.getElementById("varianceTestBody");
        // const welchBody = document.getElementById("welchAnovaBody");

        const compareBodyReport = document.getElementById("methodComparisonBodyReport");
        if (compareBodyReport) {
          const explore = (lastBundle && lastBundle.explore) ? lastBundle.explore : {};
          const colStats = Array.isArray(explore.selectedColumnStats) ? explore.selectedColumnStats.filter(function(cs){
            return isFinite(parseMaybeNumber(cs && cs.n)) && parseMaybeNumber(cs.n) > 0;
          }) : [];
          const meansSummary = colStats.slice(0, 3).map(function(cs){
            return (cs.name || "Var") + "=" + fmt(cs.mean);
          }).join(" | ") || "...";
          const meanRanks = ob.meanRanks || {};
          const rankKeys = Object.keys(meanRanks || {}).slice(0, 3);
          const meanRankSummary = rankKeys.length
            ? rankKeys.map(function(k){ return k + "=" + fmt(meanRanks[k]); }).join(" | ")
            : "...";
          
          // RM-appropriate summary (not independent ANOVA terminology)
          const mauchlyP = parseMaybeNumber((ob.sphericity || {}).p);
          const sphericityNote = isFinite(mauchlyP) 
            ? (mauchlyP > 0.05 ? "Met (p=" + fmtP(mauchlyP) + ")" : "Violated (p=" + fmtP(mauchlyP) + ")")
            : "...";
          
          compareBodyReport.innerHTML = ''
            + '<tr><td>RM-ANOVA F: ' + fmt(ob.anovaF) + '</td><td>Friedman Ï‡Â²: ' + fmt(ob.friedmanChiSquare || ob.kwH) + '</td></tr>'
            + '<tr><td>Means: ' + meansSummary + '</td><td>Mean ranks: ' + meanRankSummary + '</td></tr>'
            + '<tr><td>Partial Î·Â² / Ï‰Â²: ' + fmt(ob.partialEtaSquared) + ' / ' + fmt(ob.omegaSquared) + '</td><td>Kendall W / ÎµÂ²: ' + fmt(ob.kendallW) + ' / ' + fmt(ob.epsilonSquared) + '</td></tr>'
            + '<tr><td>Post-hoc: Paired t-tests + Holm</td><td>Post-hoc: Wilcoxon signed-rank + Holm</td></tr>'
            + '<tr><td>Sphericity: ' + sphericityNote + '</td><td>Assumption-free (rank-based)</td></tr>';
        }
      }
    }
    function updateGroupChart() {
      console.log("updateGroupChart called");
      console.log("lastBundle:", lastBundle);
      
      const container = document.getElementById('groupChartContainer');
      if (!container) {
        console.log("Container not found");
        return;
      }
      
      if (!lastBundle) {
        console.log('No lastBundle available for chart');
        container.innerHTML = '<div style="text-align:center;padding:80px 20px;color:var(--text-muted);font-size:12px;">No data available for visualization</div>';
        return;
      }
      
      // Try to get group data from multiple sources
      let groupData = [];
      
      // Source 1: explore.selectedColumnStats
      if (lastBundle.explore && Array.isArray(lastBundle.explore.selectedColumnStats)) {
        console.log("Found explore.selectedColumnStats:", lastBundle.explore.selectedColumnStats);
        groupData = lastBundle.explore.selectedColumnStats.filter(function(cs){
          return cs && isFinite(parseMaybeNumber(cs.n)) && parseMaybeNumber(cs.n) > 0;
        }).map(function(cs) {
          // Calculate variance if not provided (using stdDev or sd)
          let variance = cs.variance;
          if (!isFinite(parseMaybeNumber(variance))) {
            const sd = parseMaybeNumber(cs.stdDev || cs.sd || cs.stdev);
            if (isFinite(sd)) {
              variance = sd * sd; // variance = stdDevÂ²
            }
          }
          return {
            name: cs.name,
            mean: cs.mean,
            variance: variance,
            n: cs.n
          };
        });
      }
      
      // Source 2: If no explore data, try to build from groupDescriptives
      if (groupData.length === 0 && lastBundle.groupDescriptives && Array.isArray(lastBundle.groupDescriptives)) {
        console.log("Using groupDescriptives:", lastBundle.groupDescriptives);
        groupData = lastBundle.groupDescriptives.map(function(gd) {
          return {
            name: gd.name || gd.groupName || 'Group',
            mean: gd.mean,
            variance: gd.variance,
            n: gd.n
          };
        });
      }
      
      // Source 3: Try results.omnibus.levels with means
      if (groupData.length === 0 && lastBundle.results && lastBundle.results.omnibus) {
        console.log("Trying results.omnibus");
        const ob = lastBundle.results.omnibus;
        if (Array.isArray(ob.levels)) {
          console.log("Found levels:", ob.levels);
          groupData = ob.levels.map(function(level) {
            return {
              name: level.name || level.group || 'Group',
              mean: level.mean,
              variance: level.variance || level.var,
              n: level.n
            };
          });
        }
      }
      
      console.log("Final groupData:", groupData);
      
      if (groupData.length === 0) {
        console.log('No group data available for chart');
        container.innerHTML = '<div style="text-align:center;padding:80px 20px;color:var(--text-muted);font-size:12px;">No data available for visualization</div>';
        return;
      }
      
      const metricType = document.querySelector('input[name="chartMetric"]:checked')?.value || 'means';
      console.log("Metric type:", metricType);
      
      const categories = groupData.map(cs => cs.name || 'Group');
      console.log("Categories:", categories);
      
      const data = groupData.map(cs => {
        const val = metricType === 'means' ? parseMaybeNumber(cs.mean) : parseMaybeNumber(cs.variance);
        console.log("Group:", cs.name, "Value:", val, "Mean:", cs.mean, "Variance:", cs.variance);
        return isFinite(val) ? val : 0;
      });
      console.log("Chart data:", data);
      
      // Check if Highcharts is available
      if (typeof Highcharts === 'undefined') {
        console.error("Highcharts is not loaded!");
        container.innerHTML = '<div style="text-align:center;padding:80px 20px;color:#ff5555;font-size:12px;">Highcharts library not loaded</div>';
        return;
      }
      console.log("Highcharts version:", Highcharts.version);
      
      const chartTitle = metricType === 'means' ? 'Timepoint Means' : 'Timepoint Variances';
      const yAxisTitle = metricType === 'means' ? 'Mean' : 'Variance';
      
      console.log("About to create chart...");
      try {
        const isVariance = metricType === 'variances';
        
        // Calculate grand mean and standard errors for error bars
        let grandMean = null;
        const chartData = [];
        const errorData = [];
        
        if (metricType === 'means') {
          // Calculate grand mean (weighted by sample size if available)
          let totalWeighted = 0;
          let totalN = 0;
          groupData.forEach(function(g) {
            if (isFinite(g.mean) && isFinite(g.n)) {
              totalWeighted += g.mean * g.n;
              totalN += g.n;
            }
          });
          grandMean = totalN > 0 ? totalWeighted / totalN : null;
          
          // Prepare data with error bars (95% CI)
          groupData.forEach(function(g, idx) {
            const mean = g.mean;
            const sd = Math.sqrt(g.variance);
            const n = g.n || 1;
            const se = sd / Math.sqrt(n); // Standard error
            const ci95 = 1.96 * se; // Approximate 95% CI
            
            chartData.push({
              y: mean,
              name: g.name,
              n: n,
              sd: sd,
              se: se,
              color: null // Will be set based on significance
            });
            
            errorData.push({
              low: mean - ci95,
              high: mean + ci95
            });
          });
        } else {
          // For variance chart (no error bars)
          groupData.forEach(function(g) {
            chartData.push(g.variance);
          });
        }
        
        Highcharts.chart('groupChartContainer', {
          chart: {
            type: isVariance ? 'column' : 'column',
            backgroundColor: 'transparent',
            style: { fontFamily: 'Segoe UI, Tahoma, sans-serif' }
          },
          title: {
            text: chartTitle,
            style: { color: '#fff', fontSize: '13px', fontWeight: '700' }
          },
          xAxis: {
            categories: categories,
            labels: { style: { color: '#e5eefc', fontSize: '11px' } },
            lineColor: '#2d3748',
            tickColor: '#2d3748'
          },
          yAxis: {
            title: {
              text: yAxisTitle,
              style: { color: '#e5eefc', fontSize: '11px', fontWeight: '600' }
            },
            labels: { style: { color: '#e5eefc', fontSize: '10px' } },
            gridLineColor: '#2d3748',
            plotLines: metricType === 'means' && grandMean !== null ? [{
              value: grandMean,
              color: '#ffb74d',
              width: 2,
              dashStyle: 'Dash',
              zIndex: 5,
              label: {
                text: 'Grand Mean: ' + grandMean.toFixed(2),
                style: { color: '#ffb74d', fontSize: '10px', fontWeight: '600' }
              }
            }] : []
          },
          legend: { enabled: false },
          plotOptions: {
            column: {
              borderWidth: isVariance ? 2 : 0,
              borderColor: isVariance ? '#ffffff' : 'transparent',
              dataLabels: {
                enabled: true,
                format: '{y:.2f}',
                style: { 
                  color: '#fff', 
                  fontSize: '10px', 
                  fontWeight: '600', 
                  textOutline: 'none'
                }
              },
              colorByPoint: !isVariance, // Only use different colors for means
              colors: isVariance 
                ? ['#e57373', '#ba68c8', '#4fc3f7', '#81c784', '#ffb74d', '#f06292', '#7986cb', '#aed581']
                : ['#4a90e2', '#26a69a', '#ff9800', '#e91e63', '#9c27b0', '#3f51b5', '#00bcd4', '#4caf50'],
              opacity: isVariance ? 0.7 : 1,
              groupPadding: isVariance ? 0.15 : 0.2
            },
            errorbar: {
              color: 'rgba(255, 255, 255, 0.4)',
              whiskerLength: '60%',
              stemWidth: 1,
              whiskerWidth: 1.5,
              lineWidth: 1
            }
          },
          tooltip: {
            backgroundColor: '#1a1f2e',
            borderColor: '#2d3748',
            style: { color: '#fff', fontSize: '11px' },
            shared: metricType === 'means',
            formatter: function() {
              if (metricType === 'means' && this.points) {
                const point = this.points[0].point;
                let tooltip = '<b>' + point.name + '</b><br/>';
                tooltip += 'Mean: <b>' + point.y.toFixed(2) + '</b><br/>';
                tooltip += 'n = <b>' + point.n + '</b><br/>';
                tooltip += 'SD = <b>' + point.sd.toFixed(2) + '</b><br/>';
                tooltip += 'SE = <b>' + point.se.toFixed(3) + '</b><br/>';
                tooltip += '95% CI: [' + errorData[point.index].low.toFixed(2) + ', ' + errorData[point.index].high.toFixed(2) + ']';
                return tooltip;
              } else {
                return '<b>' + this.x + '</b><br/>' + yAxisTitle + ': <b>' + this.y.toFixed(2) + '</b>';
              }
            }
          },
          series: metricType === 'means' ? [
            {
              name: yAxisTitle,
              data: chartData,
              type: 'column'
            },
            {
              name: '95% CI',
              data: errorData,
              type: 'errorbar',
              tooltip: {
                pointFormat: '95% CI: {point.low:.2f} - {point.high:.2f}<br/>'
              }
            }
          ] : [{
            name: yAxisTitle,
            data: data,
            type: 'column'
          }],
          credits: { enabled: false }
        });
        console.log("Chart created successfully!");
      } catch (err) {
        console.error("Error creating chart:", err);
        container.innerHTML = '<div style="text-align:center;padding:80px 20px;color:#ff5555;font-size:12px;">Error creating chart: ' + err.message + '</div>';
      }
    }
    
    let posthocData = [];
    let posthocSortColumn = 'adjp';
    let posthocSortAsc = true;
    
    function renderPosthoc(posthoc, compareMode){
      const body = document.getElementById("posthocBody");
      const heading = document.getElementById("posthocHeading");
      const warningEl = document.getElementById("posthocWarning");
      const noteEl = document.getElementById("posthocMethodNote");
      const refSelect = document.getElementById("posthocRefGroup");
      const tableHeader = document.querySelector("#posthocTable thead tr");
      
      if (!body) return;
      
      // Determine if nonparametric
      const isNonParam = primaryFramework === "nonparametric";
      const posthocMethodRadio = document.querySelector('input[name="posthocMethod"]:checked');
      const currentMethod = posthocMethodRadio ? posthocMethodRadio.value : (isNonParam ? "wilcoxon" : "paired");
      
      // Update heading text and color based on framework
      if (heading) {
        heading.className = "stat-panel-heading " + (isNonParam ? "nonparametric" : "parametric");
        
        // Context-aware heading text
        if (isNonParam) {
          if (currentMethod === "wilcoxon") {
            heading.innerHTML = 'Post-hoc Pairwise Comparisons (Wilcoxon Signed-Rank)' + 
              '<div style="float:right;display:inline-flex;gap:8px;align-items:center;font-size:11px;font-weight:600;text-transform:none;">' +
              '<span style="opacity:0.8;">Filter:</span>' +
              '<label style="display:inline-flex;align-items:center;gap:4px;cursor:pointer;">' +
              '<input type="radio" name="posthocGrouping" value="all" checked onchange="updatePosthocDisplay()"> All pairs' +
              '</label>' +
              '<label style="display:inline-flex;align-items:center;gap:4px;cursor:pointer;">' +
              '<input type="radio" name="posthocGrouping" value="ref" onchange="updatePosthocDisplay()"> vs Reference' +
              '</label>' +
              '<select id="posthocRefGroup" style="height:24px;padding:0 6px;border-radius:4px;background:#ffffff;border:1px solid rgba(255,255,255,0.2);color:#263238;font-size:11px;display:none;" onchange="updatePosthocDisplay()">' +
              '<option value="">Select timepoint...</option>' +
              '</select>' +
              '</div>';
          } else if (currentMethod === "conover") {
            heading.textContent = 'Post-hoc Pairwise Comparisons (Conover)';
          } else if (currentMethod === "nemenyi") {
            heading.textContent = 'Post-hoc Pairwise Comparisons (Nemenyi)';
          } else {
            heading.textContent = 'Post-hoc Pairwise Comparisons (Rank-based)';
          }
        } else {
          heading.innerHTML = 'Post-hoc Pairwise Comparisons (Paired t-tests)' +
            '<div style="float:right;display:inline-flex;gap:8px;align-items:center;font-size:11px;font-weight:600;text-transform:none;">' +
            '<span style="opacity:0.8;">Filter:</span>' +
            '<label style="display:inline-flex;align-items:center;gap:4px;cursor:pointer;">' +
            '<input type="radio" name="posthocGrouping" value="all" checked onchange="updatePosthocDisplay()"> All pairs' +
            '</label>' +
            '<label style="display:inline-flex;align-items:center;gap:4px;cursor:pointer;">' +
            '<input type="radio" name="posthocGrouping" value="ref" onchange="updatePosthocDisplay()"> vs Reference' +
            '</label>' +
            '<select id="posthocRefGroup" style="height:24px;padding:0 6px;border-radius:4px;background:#ffffff;border:1px solid rgba(255,255,255,0.2);color:#263238;font-size:11px;display:none;" onchange="updatePosthocDisplay()">' +
            '<option value="">Select timepoint...</option>' +
            '</select>' +
            '</div>';
        }
      }
      
      // Update table header based on framework
      if (tableHeader && isNonParam) {
        tableHeader.innerHTML = `
          <th style="cursor:pointer;" onclick="sortPosthocTable('comparison')">Comparison â†•</th>
          <th style="cursor:pointer;" onclick="sortPosthocTable('statistic')">Z â†•</th>
          <th style="cursor:pointer;" onclick="sortPosthocTable('rawp')">Raw p â†•</th>
          <th style="cursor:pointer;" onclick="sortPosthocTable('adjp')">Adj p â†•</th>
          <th style="cursor:pointer;" onclick="sortPosthocTable('estimate')">Effect size r â†•</th>
          <th style="text-align:center;">Sig</th>
        `;
      } else if (tableHeader && !isNonParam) {
        tableHeader.innerHTML = `
          <th style="cursor:pointer;" onclick="sortPosthocTable('comparison')">Comparison â†•</th>
          <th style="cursor:pointer;" onclick="sortPosthocTable('statistic')">Statistic â†•</th>
          <th style="cursor:pointer;" onclick="sortPosthocTable('rawp')">Raw p â†•</th>
          <th style="cursor:pointer;" onclick="sortPosthocTable('adjp')">Adj p â†•</th>
          <th style="cursor:pointer;" onclick="sortPosthocTable('estimate')">Estimate â†•</th>
          <th style="cursor:pointer;" onclick="sortPosthocTable('ci')">95% CI â†•</th>
          <th style="text-align:center;">Sig</th>
        `;
      }
      
      // Populate reference dropdown with timepoint names
      const refSelectNew = document.getElementById("posthocRefGroup");
      if (refSelectNew && posthoc && posthoc.rows && posthoc.rows.length > 0) {
        // Extract unique timepoint names from comparison strings
        const timepointSet = new Set();
        posthoc.rows.forEach(function(row) {
          if (row.timepoint1) timepointSet.add(row.timepoint1);
          if (row.timepoint2) timepointSet.add(row.timepoint2);
        });
        const timepoints = Array.from(timepointSet);
        
        // Populate dropdown
        let options = '<option value="">Select timepoint...</option>';
        timepoints.forEach(function(tp) {
          options += '<option value="' + tp + '">' + tp + '</option>';
        });
        refSelectNew.innerHTML = options;
      }
      
      if (compareMode !== "k-plus" || !posthoc || !posthoc.enabled) {
        body.innerHTML = isNonParam ? '<tr><td colspan="6">No post-hoc comparisons available</td></tr>' : '<tr><td colspan="7">No post-hoc comparisons available</td></tr>';
        return;
      }
      
      // Check omnibus significance and show warning
      if (warningEl && lastBundle && lastBundle.results && lastBundle.results.omnibus) {
        const ob = lastBundle.results.omnibus;
        const anovaP = parseMaybeNumber(ob.anovaP);
        const friedmanP = parseMaybeNumber(ob.kwP);
        const relevantP = isNonParam ? friedmanP : anovaP;
        const alpha = 0.05;
        if (relevantP > alpha) {
          warningEl.style.display = 'block';
        } else {
          warningEl.style.display = 'none';
        }
      }
      
      // Update method note
      const method = posthoc.method || currentMethod || "paired";
      const pCorrectionRadio = document.querySelector('input[name="pCorrection"]:checked');
      const correction = pCorrectionRadio ? pCorrectionRadio.value : "holm";
      const correctionName = correction === "bh" ? "FDR (Benjamini-Hochberg)" : 
                             correction === "bonferroni" ? "Bonferroni" :
                             correction === "none" ? "None" : "Holm";
      if (noteEl) {
        let methodDesc = "";
        if (isNonParam) {
          if (method === "wilcoxon") {
            methodDesc = "Wilcoxon Signed-Rank test (rank-based pairwise comparisons)";
          } else if (method === "conover") {
            methodDesc = "Conover test (post-hoc for Friedman)";
          } else if (method === "nemenyi") {
            methodDesc = "Nemenyi test (post-hoc for Friedman)";
          } else {
            methodDesc = "Rank-based " + method + " test";
          }
        } else {
          if (method === "paired") {
            methodDesc = "Paired t-tests (parametric pairwise comparisons)";
          } else if (method === "paired-baseline") {
            methodDesc = "Paired t-tests vs Baseline";
          } else {
            methodDesc = "Paired " + method + " test";
          }
        }
        noteEl.textContent = methodDesc + " | p-value correction: " + correctionName;
      }
      
      const rows = posthoc.rows || [];
      if (!rows.length) {
        body.innerHTML = isNonParam ? '<tr><td colspan="6">No post-hoc comparisons available</td></tr>' : '<tr><td colspan="7">No post-hoc comparisons available</td></tr>';
        return;
      }
      
      // Store data globally for sorting/filtering
      posthocData = rows.map(function(r) {
        // Calculate CI if not provided (using standard error approximation)
        let ciLower = parseMaybeNumber(r.ciLower);
        let ciUpper = parseMaybeNumber(r.ciUpper);
        if (!isFinite(ciLower) || !isFinite(ciUpper)) {
          // Approximate CI from estimate and t-statistic
          const est = parseMaybeNumber(r.estimate);
          const t = Math.abs(parseMaybeNumber(r.statistic));
          if (isFinite(est) && isFinite(t) && t > 0) {
            const se = Math.abs(est / t);
            const tCrit = 2.0; // Approximate 95% t-critical
            ciLower = est - tCrit * se;
            ciUpper = est + tCrit * se;
          }
        }
        
        return {
          comparison: r.comparison || "",
          statistic: r.statistic,
          rawP: parseMaybeNumber(r.rawP),
          adjP: parseMaybeNumber(r.adjP),
          estimate: parseMaybeNumber(r.estimate),
          ciLower: ciLower,
          ciUpper: ciUpper,
          significant: parseMaybeNumber(r.adjP) < 0.05
        };
      });
      
      // Populate reference group dropdown
      if (refSelect) {
        const groups = [];
        posthocData.forEach(function(r) {
          const parts = r.comparison.split(/\s*vs\.?\s*/i);
          if (parts.length === 2) {
            const g1 = parts[0].trim();
            const g2 = parts[1].trim();
            if (g1 && groups.indexOf(g1) === -1) groups.push(g1);
            if (g2 && groups.indexOf(g2) === -1) groups.push(g2);
          }
        });
        
        if (groups.length > 0) {
          refSelect.innerHTML = '<option value="">All groups</option>' + 
            groups.map(g => '<option value="' + g + '">' + g + '</option>').join('');
          // Auto-select first group for better UX
          if (groups.length > 0) refSelect.value = groups[0];
        } else {
          refSelect.innerHTML = '<option value="">No groups available</option>';
        }
      }
      
      updatePosthocDisplay();
    }
    
    function updatePosthocDisplay() {
      const body = document.getElementById("posthocBody");
      const refSelect = document.getElementById("posthocRefGroup");
      if (!body || !posthocData.length) return;
      
      // Get grouping mode
      const grouping = document.querySelector('input[name="posthocGrouping"]:checked')?.value || 'all';
      const refGroup = refSelect ? refSelect.value : '';
      
      // Show/hide reference dropdown
      if (refSelect) {
        refSelect.style.display = (grouping === 'ref') ? 'inline-block' : 'none';
      }
      
      // Filter data
      let displayData = posthocData;
      if (grouping === 'ref' && refGroup) {
        displayData = posthocData.filter(function(r) {
          // Match if refGroup appears in the comparison
          const parts = r.comparison.split(/\s*vs\.?\s*/i);
          return parts.some(p => p.trim().toLowerCase() === refGroup.toLowerCase());
        });
      }
      
      // Sort data
      displayData.sort(function(a, b) {
        let valA, valB;
        if (posthocSortColumn === 'comparison') {
          return posthocSortAsc ? a.comparison.localeCompare(b.comparison) : b.comparison.localeCompare(a.comparison);
        } else if (posthocSortColumn === 'statistic') {
          valA = a.statistic; valB = b.statistic;
        } else if (posthocSortColumn === 'rawp') {
          valA = a.rawP; valB = b.rawP;
        } else if (posthocSortColumn === 'adjp') {
          valA = a.adjP; valB = b.adjP;
        } else if (posthocSortColumn === 'estimate') {
          valA = Math.abs(a.estimate); valB = Math.abs(b.estimate);
        } else if (posthocSortColumn === 'ci') {
          valA = a.ciUpper - a.ciLower; valB = b.ciUpper - b.ciLower;
        }
        return posthocSortAsc ? (valA - valB) : (valB - valA);
      });
      
      // Render table
      body.innerHTML = "";
      const MAX_RENDER = 200;
      const rowsToRender = displayData.slice(0, MAX_RENDER);
      const isNonParam = primaryFramework === "nonparametric";
      
      rowsToRender.forEach(function(r){
        const tr = document.createElement("tr");
        
        // Comparison
        let td = document.createElement("td");
        td.textContent = r.comparison;
        tr.appendChild(td);
        
        // Statistic (label as Z for nonparametric, t for parametric)
        td = document.createElement("td");
        td.textContent = fmt(r.statistic);
        td.style.fontFamily = "monospace";
        tr.appendChild(td);
        
        // Raw p
        td = document.createElement("td");
        td.textContent = fmtP(r.rawP);
        td.style.fontFamily = "monospace";
        tr.appendChild(td);
        
        // Adj p
        td = document.createElement("td");
        td.textContent = fmtP(r.adjP);
        td.style.fontFamily = "monospace";
        tr.appendChild(td);
        
        // Estimate (effect size r for nonparametric, mean diff for parametric)
        td = document.createElement("td");
        td.textContent = fmt(r.estimate);
        td.style.fontFamily = "monospace";
        tr.appendChild(td);
        
        // 95% CI (only for parametric)
        if (!isNonParam) {
          td = document.createElement("td");
          if (isFinite(r.ciLower) && isFinite(r.ciUpper)) {
            td.textContent = "[" + fmt(r.ciLower) + ", " + fmt(r.ciUpper) + "]";
          } else {
            td.textContent = "â€”";
          }
          td.style.fontFamily = "monospace";
          td.style.fontSize = "10px";
          tr.appendChild(td);
        }
        
        // Significance indicator
        td = document.createElement("td");
        td.style.textAlign = "center";
        if (r.significant) {
          td.innerHTML = '<span style="color:#4ade80;font-weight:800;font-size:14px;">âœ”</span>';
        } else {
          td.innerHTML = '<span style="color:#64748b;font-weight:400;font-size:14px;">âœ–</span>';
        }
        tr.appendChild(td);
        
        body.appendChild(tr);
      });
      
      if (displayData.length > MAX_RENDER) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = isNonParam ? 6 : 7;
        td.textContent = "... " + (displayData.length - MAX_RENDER) + " more rows (table capped at " + MAX_RENDER + ")";
        td.style.textAlign = "center";
        td.style.fontStyle = "italic";
        td.style.color = "var(--text-muted)";
        tr.appendChild(td);
        body.appendChild(tr);
      }
    }
    
    function sortPosthocTable(column) {
      if (posthocSortColumn === column) {
        posthocSortAsc = !posthocSortAsc;
      } else {
        posthocSortColumn = column;
        posthocSortAsc = (column === 'adjp' || column === 'rawp'); // Ascending for p-values
      }
      updatePosthocDisplay();
    }

    
    // === Descriptive Stats Functions ===
    let descSelectedRow = null;
    let descData = [];
    
    function populateDescriptiveStats(headers, rows) {
      if (!Array.isArray(headers) || !Array.isArray(rows)) return;
      
      descData = headers.map(varName => {
        const values = rows
          .map(row => row[varName])
          .map(v => typeof v === 'number' ? v : parseFloat(v))
          .filter(v => isFinite(v));
        
        if (values.length === 0) return null;
        
        const sorted = values.slice().sort((a, b) => a - b);
        const n = values.length;
        const mean = values.reduce((sum, v) => sum + v, 0) / n;
        const median = n % 2 === 0 
          ? (sorted[n/2 - 1] + sorted[n/2]) / 2 
          : sorted[Math.floor(n/2)];
        
        const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / n;
        const stdDev = Math.sqrt(variance);
        const skew = values.reduce((sum, v) => sum + Math.pow((v - mean) / stdDev, 3), 0) / n;
        const kurt = values.reduce((sum, v) => sum + Math.pow((v - mean) / stdDev, 4), 0) / n - 3;
        
        return {
          Variable: varName,
          N: n,
          Mean: mean,
          StdDev: stdDev,
          Min: Math.min(...values),
          Median: median,
          Max: Math.max(...values),
          Skew: skew,
          Kurt: kurt,
          vector: values
        };
      }).filter(stat => stat !== null);
      
      renderDescriptiveTable();
      if (descData.length > 0) {
        selectDescRow(descData[0]);
      }
    }
    
    function renderDescriptiveTable() {
      const tbody = document.getElementById('desc-stats-body');
      if (!tbody) return;
      tbody.innerHTML = '';
      
      descData.forEach(row => {
        const tr = document.createElement('tr');
        if (descSelectedRow && row.Variable === descSelectedRow.Variable) {
          tr.className = 'selected';
        }
        
        const tdVariable = document.createElement('td');
        tdVariable.textContent = row.Variable;
        tdVariable.style.textAlign = 'left';
        tr.appendChild(tdVariable);
        
        ['N', 'Mean', 'StdDev', 'Min', 'Median', 'Max', 'Skew', 'Kurt'].forEach(field => {
          const td = document.createElement('td');
          td.textContent = field === 'N' ? row[field] : fmt(row[field]);
          tr.appendChild(td);
        });
        
        tr.addEventListener('click', () => selectDescRow(row));
        tbody.appendChild(tr);
      });
    }
    
    function selectDescRow(row) {
      descSelectedRow = row;
      renderDescriptiveTable();
      
      document.getElementById('desc-histogram-title').textContent = row.Variable;
      document.getElementById('desc-histogram-panel').style.display = 'block';
      
      renderDescHistogram();
      updateDescSummary();
    }
    
    function updateDescSummary() {
      if (!descSelectedRow) return;
      const summaryTable = document.getElementById('desc-summary-table');
      if (!summaryTable) return;
      
      summaryTable.innerHTML = `
        <div><strong>N:</strong><span>${descSelectedRow.N}</span></div>
        <div><strong>Mean:</strong><span>${fmt(descSelectedRow.Mean)}</span></div>
        <div><strong>StdDev:</strong><span>${fmt(descSelectedRow.StdDev)}</span></div>
        <div><strong>Min:</strong><span>${fmt(descSelectedRow.Min)}</span></div>
        <div><strong>Median:</strong><span>${fmt(descSelectedRow.Median)}</span></div>
        <div><strong>Max:</strong><span>${fmt(descSelectedRow.Max)}</span></div>
        <div><strong>Skew:</strong><span>${fmt(descSelectedRow.Skew)}</span></div>
        <div><strong>Kurt:</strong><span>${fmt(descSelectedRow.Kurt)}</span></div>
      `;
    }
    
    function renderDescHistogram() {
      if (!descSelectedRow || !descSelectedRow.vector) return;
      
      const container = document.getElementById('histogram-container-kplus');
      if (!container) return;
      
      // Get current bin count from slider
      const binsSlider = document.getElementById('histogramBins');
      const numBins = binsSlider ? parseInt(binsSlider.value) : 10;
      
      const width = container.clientWidth || 600;
      const height = 280;
      
      d3.select('#histogram-container-kplus').selectAll('*').remove();
      
      const svg = d3.select('#histogram-container-kplus')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .style('overflow', 'visible');
      
      const margin = { top: 15, right: 25, bottom: 50, left: 40 };
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;
      
      const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
      
      const values = descSelectedRow.vector;
      const min = Math.min(...values);
      const max = Math.max(...values);
      const range = max - min;
      const binWidth = range / numBins;
      
      const histData = Array.from({ length: numBins }, (_, i) => {
        const start = min + i * binWidth;
        const end = min + (i + 1) * binWidth;
        const binLabel = `${start.toFixed(1)}-${end.toFixed(1)}`;
        let count = 0;
        values.forEach(v => {
          if (v >= start && (i === numBins - 1 ? v <= end : v < end)) count++;
        });
        return { bin: binLabel, start, end, count };
      });
      
      const x = d3.scaleBand()
        .domain(histData.map(d => d.bin))
        .range([0, innerWidth])
        .padding(0.1);
      
      const maxCount = d3.max(histData, d => d.count);
      const y = d3.scaleLinear()
        .domain([0, maxCount + (maxCount * 0.1)])
        .range([innerHeight, 0]);
      
      // X-axis with range labels
      const xAxis = g.append('g')
        .attr('class', 'axis')
        .attr('transform', `translate(0,${innerHeight})`)
        .call(d3.axisBottom(x)
          .tickValues(x.domain().filter((d, i) => {
            // Show labels based on number of bins
            if (numBins <= 10) return true; // Show all
            if (numBins <= 15) return i % 2 === 0; // Every other
            if (numBins <= 20) return i % 3 === 0; // Every 3rd
            return i % 4 === 0; // Every 4th
          }))
        );
      
      xAxis.selectAll('text')
        .style('text-anchor', 'end')
        .attr('dx', '-.5em')
        .attr('dy', '.5em')
        .attr('font-size', '9px')
        .attr('transform', 'rotate(-45)');
      
      // Y-axis
      g.append('g')
        .attr('class', 'axis')
        .call(d3.axisLeft(y).ticks(5));
      
      // Grid
      g.append('g')
        .attr('class', 'grid')
        .call(d3.axisLeft(y).ticks(5).tickSize(-innerWidth).tickFormat(''));
      
      // Bars
      g.selectAll('.histogram-bar')
        .data(histData)
        .enter().append('rect')
        .attr('class', 'histogram-bar')
        .attr('x', d => x(d.bin))
        .attr('width', x.bandwidth())
        .attr('y', d => y(d.count))
        .attr('height', d => innerHeight - y(d.count))
        .append('title')
        .text(d => `${d.bin}: ${d.count} values`);
      
      // Add normal curve
      const mean = descSelectedRow.Mean;
      const stdDev = descSelectedRow.StdDev;
      const normalData = [];
      const step = range / 50;
      for (let x_val = min - range * 0.1; x_val <= max + range * 0.1; x_val += step) {
        const exponent = -Math.pow(x_val - mean, 2) / (2 * Math.pow(stdDev, 2));
        const y_val = (1 / (stdDev * Math.sqrt(2 * Math.PI))) * Math.exp(exponent);
        normalData.push({ x: x_val, y: y_val });
      }
      
      const maxNormalY = d3.max(normalData, d => d.y);
      const normalScale = maxCount / maxNormalY * 0.8;
      
      const xScale = d3.scaleLinear()
        .domain([min, max])
        .range([0, innerWidth]);
      
      const line = d3.line()
        .x(d => xScale(d.x))
        .y(d => y(d.y * normalScale));
      
      g.append('path')
        .datum(normalData)
        .attr('class', 'normal-curve')
        .attr('d', line);
    }
    
    function openNormalityModal() {
      if (!descSelectedRow) {
        alert('Please select a variable first');
        return;
      }
      
      document.getElementById('modal-variable-name').textContent = descSelectedRow.Variable;
      document.getElementById('modal-sample-size').textContent = `(n=${descSelectedRow.N})`;
      document.getElementById('modal-variable-detail').textContent = descSelectedRow.Variable;
      document.getElementById('modal-n-detail').textContent = descSelectedRow.N;
      document.getElementById('modal-mean-detail').textContent = fmt(descSelectedRow.Mean);
      document.getElementById('modal-sd-detail').textContent = fmt(descSelectedRow.StdDev);
      
      document.getElementById('normality-modal').style.display = 'block';
      document.body.style.overflow = 'hidden';
    }
    
    function closeNormalityModal() {
      document.getElementById('normality-modal').style.display = 'none';
      document.body.style.overflow = 'auto';
    }
    
    function populateBundle(b){
      console.log("ðŸ”„ populateBundle called with:", b);
      lastBundle = b || {};
      const s=b.setup||{}, e=b.explore||{}, a=b.assumptions||{}, r=b.results||{}, fx=b.effects||{}, p=b.power||{}, rep=b.report||{};
      console.log("ðŸ“¦ Bundle sections:", {
        hasSetup: !!b.setup,
        hasExplore: !!b.explore,
        hasAssumptions: !!b.assumptions,
        hasResults: !!b.results,
        hasEffects: !!b.effects,
        hasPower: !!b.power,
        hasReport: !!b.report
      });
      console.log("ðŸ”¬ Results object:", r);
      console.log("ðŸ“Š Results.omnibus:", r.omnibus);
      console.log("ðŸ” Explore object:", e);
      
      // Check if we have the required data for ANOVA
      if (!r.omnibus) {
        console.warn("âš ï¸ WARNING: No omnibus data in results - ANOVA table will show placeholders");
      } else if (!r.omnibus.anovaF && !r.omnibus.kwH) {
        console.warn("âš ï¸ WARNING: Omnibus data exists but missing test statistics");
      }
      
      availableHeaders = Array.isArray(s.headers) ? s.headers.slice() : availableHeaders;
      persistedColumns.groupA = s.groupA || persistedColumns.groupA;
      persistedColumns.groupB = s.groupB || persistedColumns.groupB;
      persistedColumns.valueColumn = s.valueColumn || persistedColumns.valueColumn;
      persistedColumns.groupColumn = s.groupColumn || persistedColumns.groupColumn;
      currentCompareMode = "k-plus";
      currentPrimaryTest = s.primaryTest || currentPrimaryTest || "welch";
      
      // Populate descriptive stats with selected columns data
      if (window.dependentRangeData && Array.isArray(s.selectedColumns)) {
        const headers = window.dependentRangeData[0] || [];
        const dataRows = window.dependentRangeData.slice(1);
        
        // Convert array-of-arrays to array-of-objects
        const rowObjects = dataRows.map(row => {
          const obj = {};
          headers.forEach((header, idx) => {
            obj[header] = row[idx];
          });
          return obj;
        });
        
        populateDescriptiveStats(s.selectedColumns, rowObjects);
      }
      
      var testSel = document.getElementById("setPrimaryTest");
      if (testSel) testSel.value = currentPrimaryTest;
      setFrameworkButtons(s.primaryFramework || primaryFramework);
      var alphaEl = document.getElementById("setAlpha");
      if (alphaEl) alphaEl.value = String(1 - (parseMaybeNumber(s.confidence) || 0.95));
      var orientation = s.hypothesis || "two-sided";
      currentHypothesis = orientation;
      var radio = document.querySelector('input[name="h1Orientation"][value="' + orientation + '"]');
      if (radio) radio.checked = true;
      const phm = document.getElementById("setPosthocMethod"); if (phm) phm.value = s.posthocMethod || "games-howell";
      const phc = document.getElementById("setPosthocCorrection"); if (phc) phc.value = s.posthocCorrection || "holm";
      renderCompareStatsRow(s, e);
      refreshSettingsVisibility();
      updatePosthocOptions();
      const ksum = e.kplusSummary || {};
      const ob = r.omnibus || {};
      
      // Check if we have omnibus data
      if (!ob || !ob.anovaF) {
        console.error("âŒ CRITICAL: No omnibus data found in results!");
        console.log("Full results object:", r);
        console.log("Omnibus object:", ob);
        console.log("This means computeRepeatedMeasuresANOVA() did not run or failed.");
        
        // Display error message in the ANOVA table
        const anovaBody = document.getElementById("anovaSummaryBody");
        if (anovaBody) {
          anovaBody.innerHTML = '<tr><td colspan="6" style="text-align:center;color:#ff6b6b;padding:20px;">âš ï¸ No ANOVA results computed. Please ensure you have selected 3+ timepoint columns and have valid data.</td></tr>';
        }
      }
      
      const groupCount = isFinite(parseMaybeNumber(ksum.variableCount)) 
        ? parseMaybeNumber(ksum.variableCount) 
        : (Array.isArray(ob.groupDescriptives) ? ob.groupDescriptives.length : (Array.isArray(s.selectedColumns) ? s.selectedColumns.length : "..."));
      setText("expVarCount", Math.round(groupCount));
      
      // Display missing data information
      const totalRows = parseMaybeNumber(e.totalRows) || 0;
      const completeCasesExplore = isFinite(parseMaybeNumber(ksum.totalN)) ? Math.round(parseMaybeNumber(ksum.totalN)) : (isFinite(ob.N) ? Math.round(ob.N) : 0);
      const missingCount = parseMaybeNumber(e.missingCount) || 0;
      const missingPct = parseMaybeNumber(e.missingPct) || 0;
      
      setText("expTotalRows", totalRows);
      setText("expTotalN", completeCasesExplore);
      
      const warningEl = document.getElementById("missingDataWarning");
      if (warningEl && missingCount > 0) {
        warningEl.style.display = "block";
        setText("missingCount", missingCount);
        setText("missingPct", missingPct.toFixed(1));
      } else if (warningEl) {
        warningEl.style.display = "none";
      }
      
      setText("expLevels", isFinite(parseMaybeNumber(ksum.levelsCount)) ? Math.round(parseMaybeNumber(ksum.levelsCount)) : "...");
      setText("expOverallMean", isFinite(parseMaybeNumber(ksum.meanOverall)) ? fmt(ksum.meanOverall) : "...");
      setText("expFramework", primaryFramework === "nonparametric" ? "Nonparametric (ranks)" : "Parametric (means)");
      
      // Populate Profile Plot and Correlation Matrix
      populateProfilePlot(e, ob);
      populateCorrelationMatrix(e);
      
      const alpha = 0.05;
      const leveneP = parseMaybeNumber((ob.levene || {}).p);
      const bfP = parseMaybeNumber((ob.brownForsythe || {}).p);
      const welchP = parseMaybeNumber((ob.welchAnova || {}).p);
      const anovaP = parseMaybeNumber(ob.anovaP);
      
      // Design Balance Indicator (RM: focus on complete cases, not balance)
      const balanceEl = document.getElementById("balanceText");
      if (balanceEl) {
        const completeCasesBalance = parseMaybeNumber(ob.N) || 0;
        const totalRowsBalance = parseMaybeNumber(e.totalRows) || parseMaybeNumber(lastBundle.totalRows) || 0;
        const missingSubjects = totalRowsBalance - completeCasesBalance;
        
        let balanceText = "";
        if (missingSubjects === 0) {
          balanceText = "âœ“ Complete data: " + completeCasesBalance + " subjects (no missing values)";
        } else {
          const missingPct = totalRowsBalance > 0 ? ((missingSubjects / totalRowsBalance) * 100).toFixed(1) : 0;
          balanceText = "âš  Complete cases: " + completeCasesBalance + " subjects (" + missingSubjects + " excluded due to missing data, " + missingPct + "%)";
        }
        balanceEl.textContent = balanceText;
      }
      
      // Sphericity Test (Mauchly)
      const sphericity = ob.sphericity || {};
      const mauchlyW = parseMaybeNumber(sphericity.W);
      const mauchlyP = parseMaybeNumber(sphericity.p);
      const epsilonGG = parseMaybeNumber(sphericity.epsilonGG);
      const epsilonHF = parseMaybeNumber(sphericity.epsilonHF);
      const sphericityMet = sphericity.sphericityMet !== false;
      
      setText("asMauchlyW", fmt(mauchlyW));
      setText("asMauchlyP", fmtP(mauchlyP));
      setText("asEpsilonGG", fmt(epsilonGG));
      setText("asEpsilonHF", fmt(epsilonHF));
      
      // Complete cases: use ob.N (from omnibus) or fall back to totalN
      const completeCasesAssumptions = parseMaybeNumber(ob.N) || parseMaybeNumber(lastBundle.totalN) || 0;
      setText("asCompleteCases", completeCasesAssumptions);
      
      // Mauchly verdict
      const mauchlyEl = document.getElementById("asMauchlyVerdict");
      if (mauchlyEl) {
        if (sphericityMet) {
          mauchlyEl.textContent = "âœ“ Sphericity assumption met (p > 0.05)";
          mauchlyEl.style.color = "#4ade80";
        } else {
          mauchlyEl.textContent = "âš  Sphericity violated (p < 0.05) - Corrections applied";
          mauchlyEl.style.color = "#fbbf24";
        }
      }
      
      // Recommendation text for repeated measures
      const recoEl = document.getElementById("asRecoText");
      if (recoEl) {
        let recoText = "";
        const anovaSig = anovaP < alpha;
        const friedmanP = parseMaybeNumber(ob.kwP);
        const friedmanSig = friedmanP < alpha;
        
        // Get current correction method for dynamic recommendation
        var corrMethod = document.getElementById("setPosthocCorrection");
        var corrName = corrMethod && corrMethod.value === "bh" ? "FDR (Benjamini-Hochberg)" : 
                      corrMethod && corrMethod.value === "bonferroni" ? "Bonferroni" :
                      corrMethod && corrMethod.value === "none" ? "no" : "Holm";
        
        // PARAMETRIC MODE (RM-ANOVA)
        if (primaryFramework === "parametric") {
          if (sphericityMet) {
            recoText = "âœ“ <strong>Repeated Measures ANOVA is appropriate.</strong> The sphericity assumption is met (Mauchly's W = " + fmt(mauchlyW) + ", p = " + fmtP(mauchlyP) + "). ";
            if (anovaSig) {
              recoText += "The RM-ANOVA shows <strong>significant differences</strong> across timepoints (p " + fmtP(anovaP) + "). Proceed with <strong>paired post-hoc tests</strong> with " + corrName + " correction.";
            } else {
              recoText += "The RM-ANOVA shows <strong>no significant differences</strong> across timepoints (p = " + fmtP(anovaP) + ").";
            }
          } else {
            recoText = "âš  <strong>Sphericity assumption violated - Corrections applied.</strong> ";
            recoText += "Greenhouse-Geisser Îµ = " + fmt(epsilonGG) + ", Huynh-Feldt Îµ = " + fmt(epsilonHF) + ". ";
            
            const pValueGG = parseMaybeNumber(ob.anovaPGG);
            const pValueHF = parseMaybeNumber(ob.anovaPHF);
            
            if (pValueGG < alpha) {
              recoText += "Even with correction, differences are <strong>significant</strong> (GG-corrected p " + fmtP(pValueGG) + "). ";
              recoText += "Proceed with <strong>paired post-hoc tests</strong> with " + corrName + " correction.";
            } else {
              recoText += "With correction applied, no significant differences detected (GG-corrected p = " + fmtP(pValueGG) + ").";
            }
          }
          
          // Add Friedman note if parametric assumptions are questionable
          if (friedmanSig === anovaSig) {
            recoText += " <em>Note: Friedman test (nonparametric alternative) confirms the " + (anovaSig ? "significant" : "non-significant") + " result.</em>";
          }
        } 
        // NONPARAMETRIC MODE (Friedman)
        else {
          recoText = "âœ“ <strong>Friedman test (nonparametric).</strong> This rank-based test is assumption-free and robust to outliers and non-normality. ";
          
          if (friedmanSig) {
            var posthocMethod = document.getElementById("setPosthocMethod");
            var posthocName = posthocMethod && posthocMethod.value === "conover" ? "Conover" :
                            posthocMethod && posthocMethod.value === "nemenyi" ? "Nemenyi" : "Wilcoxon Signed-Rank";
            recoText += "The Friedman test shows <strong>significant differences</strong> across timepoints (Ï‡Â² = " + fmt(ob.kwH) + ", p " + fmtP(friedmanP) + "). ";
            recoText += "Proceed with <strong>" + posthocName + " post-hoc tests</strong> with " + corrName + " correction.";
          } else {
            recoText += "The Friedman test shows <strong>no significant differences</strong> across timepoints (Ï‡Â² = " + fmt(ob.kwH) + ", p = " + fmtP(friedmanP) + ").";
          }
          
          // Add RM-ANOVA note for comparison
          if (friedmanSig === anovaSig) {
            recoText += " <em>Note: RM-ANOVA (parametric alternative) confirms the " + (friedmanSig ? "significant" : "non-significant") + " result.</em>";
          }
        }
        
        recoEl.innerHTML = recoText;
      }
      
      // Auto-select post-hoc method based on framework
      const posthocSelect = document.getElementById("setPosthocMethod");
      if (posthocSelect) {
        if (primaryFramework === "parametric") {
          posthocSelect.value = "paired"; // Paired t-tests for RM-ANOVA
        } else {
          posthocSelect.value = "wilcoxon"; // Wilcoxon for Friedman
        }
      }
      updateResultsPanels(r, fx, s, 1 - (parseMaybeNumber(s.confidence) || 0.95));
      renderPosthoc(r.posthoc || {}, "k-plus");
      
      // Effect sizes (RM-appropriate)
      setText("efPartialEta", fmt(ob.partialEtaSquared));
      setText("efGeneralizedEta", fmt(ob.generalizedEtaSquared));
      setText("efEta", fmt(ob.etaSquared));
      setText("efOmega", fmt(ob.omegaSquared));
      setText("efCohenF", fmt(ob.cohenF));
      setText("efKendallW", fmt(ob.kendallW || ob.friedmanW));
      setText("efFriedmanChi", fmt(ob.friedmanChiSquare || ob.kwH));
      setText("efEpsilonSq", fmt(ob.epsilonSquared));
      
      setText("powNote", p.note); setText("powEndpoint", p.suggestedEndpoint); setText("powVal", fmt(p.placeholderPower));
      setText("repAnova", "RM-ANOVA: F(" + Math.round(ob.anovaDf1) + ", " + Math.round(ob.anovaDf2) + ") = " + fmt(ob.anovaF) + ", p " + fmtP(ob.anovaP) + ".");
      setText("repKw", "Friedman: Ï‡Â²(" + Math.round(ob.friedmanDf || ob.kwDf) + ") = " + fmt(ob.friedmanChiSquare || ob.kwH) + ", p " + fmtP(ob.friedmanP || ob.kwP) + ", Kendall W = " + fmt(ob.kendallW || 0) + ".");
      setText("repCons", rep.consistency);
      
      // Initialize power analysis
      calculatePowerAnalysis(ob, s);
    }
    
    // ===== POWER ANALYSIS FUNCTIONS =====
    
    let powerAnalysisData = null;
    const DEPENDENT_MODULE_URL = 'https://dependent-module-625149856249.us-central1.run.app';
    
    async function calculatePowerAnalysis(omnibus, setup) {
      console.log("ðŸ”‹ Calculating power analysis...");
      console.log("Omnibus data:", omnibus);
      console.log("Setup data:", setup);
      
      const fStat = parseMaybeNumber(omnibus.anovaF);
      const df1 = parseMaybeNumber(omnibus.anovaDf1);
      const df2 = parseMaybeNumber(omnibus.anovaDf2);
      const partialEta = parseMaybeNumber(omnibus.partialEtaSquared);
      const cohenF = parseMaybeNumber(omnibus.cohenF);
      let n = parseMaybeNumber(omnibus.n);
      const k = (setup.selectedColumns || []).length;
      const alpha = 1 - parseMaybeNumber(setup.confidence || 0.95);
      
      // Calculate n from degrees of freedom if not provided
      // df2 = (n-1)(k-1), so n = (df2 / (k-1)) + 1
      if (!n || isNaN(n)) {
        if (df1 && df2 && k > 1) {
          n = Math.round((df2 / df1) + 1);
          console.log("ðŸ“Š Calculated n from df:", n);
        }
      }
      
      console.log("Parsed values:", { fStat, df1, df2, partialEta, cohenF, n, k, alpha });
      
      if (!fStat || fStat <= 0 || !df1 || !df2 || !n || n < 2 || !k || k < 2) {
        console.warn("âš  Insufficient data for power analysis", { fStat, df1, df2, n, k });
        // Use local approximation with available data
        if (fStat > 0 && df1 > 0 && df2 > 0 && n > 1) {
          const localPower = calculateLocalPowerApproximation(fStat, df1, df2, n);
          updatePowerUI({ 
            observed_power: localPower,
            effect_size_cohen_f: cohenF || 0,
            partial_eta_squared: partialEta || 0,
            local: true 
          }, n, alpha, partialEta);
        } else {
          updatePowerUI({ error: true }, n, alpha, partialEta);
        }
        return;
      }
      
      // Try cloud function first
      try {
        const response = await fetch(DEPENDENT_MODULE_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            operation: 'power',  // âœ… NEW: Specify operation
            mode: 'observed',
            f_statistic: fStat,
            df_between: df1,
            df_error: df2,
            n: n,
            k: k,
            partial_eta_squared: partialEta,
            alpha: alpha || 0.05
          }),
          timeout: 5000
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        
        const data = await response.json();
        console.log("âœ… Power analysis response:", data);
        
        if (data.ok && data.results) {
          powerAnalysisData = data.results;
          updatePowerUI(data.results, n, alpha, partialEta);
          return;
        } else {
          throw new Error(data.error || "Unknown error");
        }
        
      } catch (error) {
        console.warn("âš  Cloud function unavailable, using local approximation:", error);
      }
      
      // Fallback to local approximation
      const localPower = calculateLocalPowerApproximation(fStat, df1, df2, n);
      const effectF = cohenF || Math.sqrt(fStat * df1 / n);
      
      // Calculate required sample sizes locally
      const req80 = estimateRequiredN(effectF, k, 0.80, alpha);
      const req90 = estimateRequiredN(effectF, k, 0.90, alpha);
      
      updatePowerUI({ 
        observed_power: localPower,
        effect_size_cohen_f: effectF,
        partial_eta_squared: partialEta || 0,
        required_for_80pct: req80,
        required_for_90pct: req90,
        fallback: true 
      }, n, alpha, partialEta);
    }
    
    function calculateLocalPowerApproximation(fStat, df1, df2, n) {
      // Simple approximation using normal distribution
      // Power â‰ˆ 1 - Î¦(z_critical - sqrt(Î»))
      // where Î» = n * fÂ² * df1
      
      if (!fStat || fStat <= 0 || !df1 || !n || n < 2) return 0;
      
      const effectSizeF = Math.sqrt(fStat * df1 / n);
      const ncp = n * effectSizeF * effectSizeF * df1;
      const zCrit = 1.96;  // for alpha = 0.05, two-tailed
      const power = 1 - normalCdf(zCrit - Math.sqrt(ncp));
      
      return Math.max(0, Math.min(1, power));
    }
    
    function estimateRequiredN(effectF, k, targetPower, alpha) {
      // Binary search for required N
      if (!effectF || effectF <= 0 || !k || k < 2) return 0;
      
      const df1 = k - 1;
      let nMin = 2, nMax = 500;
      
      for (let iter = 0; iter < 50; iter++) {
        const n = Math.floor((nMin + nMax) / 2);
        const df2 = (n - 1) * df1;
        const ncp = n * effectF * effectF * df1;
        
        // Approximate power
        const zCrit = alpha <= 0.05 ? 1.96 : 1.645;
        const power = 1 - normalCdf(zCrit - Math.sqrt(ncp));
        
        if (Math.abs(power - targetPower) < 0.01) return n;
        
        if (power < targetPower) {
          nMin = n + 1;
        } else {
          nMax = n - 1;
        }
      }
      
      return nMax;
    }
    
    function updatePowerUI(results, currentN, alpha, partialEta) {
      const { 
        observed_power, 
        effect_size_cohen_f, 
        partial_eta_squared,
        required_for_80pct,
        required_for_90pct,
        fallback,
        local,
        error
      } = results;
      
      if (error) {
        setText("powObserved", "N/A");
        setText("powEffectSize", "N/A");
        setText("powSampleSize", "N/A");
        setText("powRequired", "N/A");
        setText("powReq85", "N/A");
        setText("powReq90", "N/A");
        setText("powReq95", "N/A");
        setText("powPartialEta", "N/A");
        updatePowerStatus("âš  Insufficient data for power analysis", "warning");
        return;
      }
      
      // Observed statistics
      const powerPct = (observed_power * 100).toFixed(1) + "%";
      setText("powObserved", powerPct);
      setText("powEffectSize", effect_size_cohen_f ? effect_size_cohen_f.toFixed(3) : "N/A");
      setText("powSampleSize", currentN || "N/A");
      setText("powAlpha", (alpha || 0.05).toFixed(3));
      setText("powPartialEta", (partial_eta_squared || partialEta || 0).toFixed(3));
      
      // Required sample sizes - calculate 85% from 80% and 90%
      if (required_for_80pct && required_for_90pct) {
        // Interpolate between 80% and 90% to get 85%
        const req85 = Math.round(required_for_80pct + (required_for_90pct - required_for_80pct) * 0.5);
        setText("powRequired", req85);
        setText("powReq85", req85);
      } else if (required_for_80pct) {
        // Approximate 85% as ~10% more than 80%
        const req85 = Math.ceil(required_for_80pct * 1.05);
        setText("powRequired", req85);
        setText("powReq85", req85);
      } else {
        setText("powRequired", "N/A");
        setText("powReq85", "N/A");
      }
      
      if (required_for_90pct) {
        setText("powReq90", required_for_90pct);
        // Calculate 95% power requirement (approximate)
        const req95 = Math.ceil(required_for_90pct * 1.2);
        setText("powReq95", req95);
      } else {
        setText("powReq90", "N/A");
        setText("powReq95", "N/A");
      }
      
      // Status message
      let statusMsg, statusType;
      if (observed_power >= 0.80) {
        statusMsg = `âœ“ Excellent power (${powerPct}) with n=${currentN}. Effect detected reliably.`;
        statusType = "success";
      } else if (observed_power >= 0.60) {
        statusMsg = `âš  Moderate power (${powerPct}) with n=${currentN}. Recommend nâ‰¥${required_for_80pct || 'N/A'} for 80% power.`;
        statusType = "warning";
      } else {
        statusMsg = `âš  Low power (${powerPct}) with n=${currentN}. Need nâ‰¥${required_for_80pct || 'N/A'} for adequate detection.`;
        statusType = "error";
      }
      
      // Indicate calculation method without "local" wording
      if (fallback || local) {
        const engineNote = document.getElementById('powEngineNote');
        if (engineNote) {
          engineNote.innerHTML = '<i class="fa-solid fa-calculator"></i> Power calculated using statistical approximation (cloud function unavailable). Effect size: Cohen\'s f from partial Î·Â².';
        }
      }
      
      updatePowerStatus(statusMsg, statusType);
    }
    
    function updatePowerStatus(message, type) {
      const statusEl = document.getElementById("powStatusMessage");
      if (!statusEl) return;
      
      statusEl.textContent = message;
      
      // Update styling based on type
      if (type === "success") {
        statusEl.style.background = "#2d5f3f";
        statusEl.style.color = "#7fdb9f";
      } else if (type === "warning") {
        statusEl.style.background = "#5f4a2d";
        statusEl.style.color = "#dbb07f";
      } else if (type === "error") {
        statusEl.style.background = "#5f2d2d";
        statusEl.style.color = "#db7f7f";
      }
    }
    
    async function calculateCustomPower() {
      const customPowerInput = document.getElementById('customPowerInput');
      const customRequiredN = document.getElementById('customRequiredN');
      const customPowerStatus = document.getElementById('customPowerStatus');
      const customPowerIcon = document.getElementById('customPowerIcon');
      
      const targetPower = parseFloat(customPowerInput.value);
      
      // Validate input
      if (isNaN(targetPower) || targetPower < 0.5 || targetPower > 0.99) {
        customRequiredN.textContent = 'Invalid';
        customRequiredN.style.color = '#ff6b6b';
        return;
      }
      
      // Show spinner
      if (customPowerIcon) {
        customPowerIcon.classList.add('fa-spin');
      }
      if (customPowerStatus) {
        customPowerStatus.style.display = 'block';
      }
      
      try {
        // Get data from lastBundle
        if (!lastBundle || !lastBundle.results || !lastBundle.results.omnibus) {
          throw new Error('No analysis data available. Please run an analysis first.');
        }
        
        const omnibus = lastBundle.results.omnibus;
        const setup = lastBundle.setup || {};
        const alpha = 0.05;
        
        // Extract required values from omnibus
        const fStat = parseMaybeNumber(omnibus.anovaF);
        const df1 = parseMaybeNumber(omnibus.anovaDf1);
        const df2 = parseMaybeNumber(omnibus.anovaDf2);
        const partialEtaSq = parseMaybeNumber(omnibus.partialEtaSquared);
        let n = parseMaybeNumber(omnibus.n);
        const k = (setup.selectedColumns || []).length;
        
        // Calculate n from degrees of freedom if missing
        if (!n || isNaN(n)) {
          if (df1 && df2 && k > 1) {
            n = Math.round((df2 / df1) + 1);
            console.log("ðŸ“Š Calculated n from df for custom power:", n);
          }
        }
        
        console.log("ðŸ” Custom power data check:", { 
          fStat, df1, df2, partialEtaSq, n, k, 
          hasOmnibus: !!omnibus,
          omnibusKeys: Object.keys(omnibus || {})
        });
        
        // Validate data - relax k requirement
        if (!fStat || !df1 || !df2 || !partialEtaSq || isNaN(partialEtaSq)) {
          console.error("âŒ Missing required data:", { fStat, df1, df2, partialEtaSq });
          throw new Error('Insufficient data for power analysis');
        }
        
        if (!n) {
          console.error("âŒ Could not determine sample size");
          throw new Error('Cannot determine sample size from data');
        }
        
        // Use k from degrees of freedom if not available
        const numMeasurements = k || (df1 + 1);
        
        // Convert effect size
        const cohensF = Math.sqrt(partialEtaSq / (1 - partialEtaSq));
        
        console.log("ðŸ”‹ Custom power calculation:", { targetPower, cohensF, numMeasurements, n, df1, df2 });
        
        // Call cloud function for required N
        const response = await fetch(DEPENDENT_MODULE_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            operation: 'power',
            mode: 'required',
            target_power: targetPower,
            effect_size_f: cohensF,
            k: numMeasurements,
            alpha: alpha
          })
        });
        
        if (!response.ok) {
          throw new Error(`Cloud function error: ${response.status}`);
        }
        
        const result = await response.json();
        console.log("âœ… Custom power result:", result);
        console.log("âœ… Result structure:", {
          hasOk: 'ok' in result,
          ok: result.ok,
          hasResults: 'results' in result,
          hasRequiredN: 'required_n' in result,
          resultsKeys: result.results ? Object.keys(result.results) : null,
          fullResult: JSON.stringify(result)
        });
        
        // Check different possible response structures
        let requiredN = null;
        
        if (result.ok && result.results && result.results.required_sample_size) {
          requiredN = result.results.required_sample_size;
        } else if (result.results && result.results.required_n) {
          requiredN = result.results.required_n;
        } else if (result.results && result.results.required_for_target) {
          requiredN = result.results.required_for_target;
        } else if (result.required_n) {
          requiredN = result.required_n;
        } else if (result.required_sample_size) {
          requiredN = result.required_sample_size;
        } else if (result.results && typeof result.results === 'number') {
          requiredN = result.results;
        }
        
        if (requiredN) {
          customRequiredN.textContent = requiredN;
          customRequiredN.style.color = '#7fdb9f';
        } else {
          console.error("âŒ Could not find required_n in response:", result);
          throw new Error(result.error || 'Failed to calculate required N - unexpected response format');
        }
        
      } catch (error) {
        console.error('âŒ Custom power calculation error:', error);
        customRequiredN.textContent = 'Error';
        customRequiredN.style.color = '#ff6b6b';
      } finally {
        // Hide spinner
        if (customPowerIcon) {
          customPowerIcon.classList.remove('fa-spin');
        }
        if (customPowerStatus) {
          customPowerStatus.style.display = 'none';
        }
      }
    }
    
    function refreshPowerAnalysis() {
      if (lastBundle && lastBundle.results && lastBundle.setup) {
        calculatePowerAnalysis(lastBundle.results.omnibus || {}, lastBundle.setup || {});
      }
    }
    
    function refreshPowerAnalysisWithTarget() {
      const refreshIcon = document.getElementById('refreshIcon');
      const statusMsg = document.getElementById('powStatusMessage');
      const engineNote = document.getElementById('powEngineNote');
      const targetInput = document.getElementById('targetPowerInput');
      const targetLabel = document.getElementById('targetPowerLabel');
      
      // Update target power label
      if (targetInput && targetLabel) {
        const targetPower = parseFloat(targetInput.value) || 0.80;
        targetLabel.textContent = (targetPower * 100).toFixed(0) + '%';
      }
      
      // Show spinner and status
      if (refreshIcon) {
        refreshIcon.classList.add('fa-spin');
      }
      if (statusMsg) {
        statusMsg.style.background = '#3a5f7c';
        statusMsg.style.color = '#9dc6e0';
        statusMsg.textContent = 'â³ Requesting power calculation from Google Cloud Functions...';
      }
      if (engineNote) {
        engineNote.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Connecting to Python cloud function...';
      }
      
      // Trigger calculation
      if (lastBundle && lastBundle.results && lastBundle.setup) {
        calculatePowerAnalysis(lastBundle.results.omnibus || {}, lastBundle.setup || {});
      }
      
      // Remove spinner after a delay
      setTimeout(() => {
        if (refreshIcon) {
          refreshIcon.classList.remove('fa-spin');
        }
        if (engineNote) {
          engineNote.innerHTML = '<i class="fa-solid fa-cloud"></i> Power calculated via Python Google Cloud Functions using non-central F distribution. Effect size: Cohen\'s f from partial Î·Â².';
        }
      }, 2000);
    }
    
    function saveCurrentModel(){ sendToHost("savedependentModel", lastBundle||{}); }
    function exportHtml(){
      const blob = new Blob([document.documentElement.outerHTML], {type:"text/html"});
      const a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = "dependent-means-report.html"; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),500);
    }
    document.addEventListener("DOMContentLoaded", function(){
      document.querySelectorAll(".tab-button").forEach(btn=>btn.addEventListener("click",()=>switchTab(btn.getAttribute("data-tab"))));
      ["setAlpha","setPosthocMethod","setPosthocCorrection","setPrimaryTest"].forEach(function(id){
        const el = document.getElementById(id);
        if (el) el.addEventListener("change", function(){
          if (id === "setPrimaryTest") {
            currentPrimaryTest = el.value || "welch";
            setFrameworkButtons(primaryFramework);
          }
          // Update tooltip when post-hoc or correction changes
          if (id === "setPosthocMethod" || id === "setPosthocCorrection") {
            updatePosthocOptions();
          }
          notifySettingsChanged();
        });
      });
      document.querySelectorAll('input[name="h1Orientation"]').forEach(function(el){ el.addEventListener("change", notifySettingsChanged); });
      var rp = document.getElementById("fwParametric");
      var rn = document.getElementById("fwNonparametric");
      if (rp) rp.addEventListener("change", function(){ if (rp.checked) { setFrameworkButtons("parametric"); notifySettingsChanged(); } });
      if (rn) rn.addEventListener("change", function(){ if (rn.checked) { setFrameworkButtons("nonparametric"); notifySettingsChanged(); } });
      
      // Histogram bins slider handler
      const histogramBinsSlider = document.getElementById("histogramBins");
      const histogramBinsValue = document.getElementById("histogramBinsValue");
      if (histogramBinsSlider && histogramBinsValue) {
        histogramBinsSlider.addEventListener("input", function() {
          histogramBinsValue.textContent = this.value;
          renderDescHistogram();
        });
      }
      
      setFrameworkButtons(primaryFramework);
      refreshSettingsVisibility();
      
      // Scroll to correlation matrix on load
      setTimeout(() => {
        const corrMatrix = document.getElementById('correlationMatrixContainer');
        if (corrMatrix) {
          corrMatrix.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      }, 1500);
      
      Office.onReady(function(){
        // Load saved model preference
        loadModelPreference();
        
        // Close modal when clicking outside
        document.addEventListener('click', function(event) {
          const modal = document.getElementById('normality-modal');
          if (event.target === modal) {
            closeNormalityModal();
          }
        });
        
        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
          if (event.key === 'Escape') {
            closeNormalityModal();
          }
        });
        
        Office.context.ui.addHandlerAsync(Office.EventType.DialogParentMessageReceived, function(arg){
          const msg = JSON.parse(arg.message||"{}");
          if(msg.type==="DEPENDENT_BUNDLE"){
            // Store raw data for descriptive stats
            if (msg.rawData) {
              window.dependentRangeData = msg.rawData;
            }
            populateBundle(msg.payload||{});
          }
        });
        if(Office&&Office.context&&Office.context.ui&&Office.context.ui.messageParent) {
          Office.context.ui.messageParent(JSON.stringify({action:"ready"}));
          setTimeout(()=>Office.context.ui.messageParent(JSON.stringify({action:"ready"})),500);
        }
      });
    });
    
    // === Profile View Switcher ===
    let currentProfileView = 'trajectory';
    let cachedOmnibusData = null;
    
    function switchProfileView(view) {
      currentProfileView = view;
      
      // Update button states
      document.querySelectorAll('.profile-view-btn').forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = 'transparent';
      });
      
      if (view === 'trajectory') {
        const btn = document.getElementById('btnTrajectory');
        btn.classList.add('active');
        btn.style.background = '#ff9800';
        
        // Regenerate trajectory plot
        if (cachedOmnibusData) {
          populateProfilePlot(null, cachedOmnibusData);
        }
      } else if (view === 'sd') {
        const btn = document.getElementById('btnSD');
        btn.classList.add('active');
        btn.style.background = '#9c27b0';
        btn.style.color = 'white';
        
        // Generate SD chart in the same container
        if (cachedOmnibusData) {
          populateSDChart(cachedOmnibusData);
        }
      }
    }
    
    // === SD Chart Function (Highcharts) - Now renders in profilePlot container ===
    function populateSDChart(omnibus) {
      const container = document.getElementById('profilePlot');
      if (!container || !omnibus) return;
      
      const groupDescriptives = omnibus.groupDescriptives || [];
      if (groupDescriptives.length === 0) return;
      
      const labels = groupDescriptives.map(g => g.name);
      const sdData = groupDescriptives.map(g => g.sd);
      const meanData = groupDescriptives.map(g => g.mean);
      
      // Calculate coefficient of variation (CV) for each timepoint
      const cvData = groupDescriptives.map(g => (g.sd / g.mean * 100).toFixed(1));
      
      // Update UI text
      document.getElementById('profilePlotTitle').textContent = 'Variability (SD) by Timepoint';
      document.getElementById('profilePurpose').textContent = 'Shows the spread (Standard Deviation) of values at each timepoint. Higher SD indicates more variability among subjects.';
      document.getElementById('profileNote').innerHTML = '<i class="fa-solid fa-info-circle"></i> <strong>Note:</strong> Each bar shows the Standard Deviation at that timepoint. The coefficient of variation (CV) is shown in the tooltip.';
      document.getElementById('profileNote').style.background = 'rgba(156,39,176,0.12)';
      document.getElementById('profileNote').style.borderColor = '#9c27b0';
      document.getElementById('profileNote').style.color = '#ce93d8';
      
      Highcharts.chart(container, {
        chart: {
          type: 'column',
          backgroundColor: '#1a2332',
          height: 400,
          style: {
            fontFamily: 'Segoe UI, Tahoma, sans-serif',
            color: '#e0e0e0'
          }
        },
        title: {
          text: null
        },
        credits: {
          enabled: false
        },
        xAxis: {
          categories: labels,
          labels: {
            style: {
              color: '#e0e0e0',
              fontSize: '11px',
              fontWeight: '600'
            }
          },
          lineColor: '#555',
          tickColor: '#555'
        },
        yAxis: {
          title: {
            text: 'Standard Deviation',
            style: { color: '#a0a0a0' }
          },
          labels: {
            style: { color: '#e0e0e0' }
          },
          gridLineColor: '#333',
          min: 0
        },
        legend: {
          enabled: false
        },
        tooltip: {
          shared: false,
          backgroundColor: 'rgba(30,30,30,0.9)',
          borderColor: '#555',
          style: {
            color: '#ffffff'
          },
          formatter: function() {
            const idx = this.point.index;
            return `<b>${this.x}</b><br/>` +
                   `SD: <b>${this.y.toFixed(2)}</b><br/>` +
                   `Mean: <b>${meanData[idx].toFixed(2)}</b><br/>` +
                   `CV: <b>${cvData[idx]}%</b>`;
          }
        },
        plotOptions: {
          column: {
            animation: {
              duration: 600
            },
            dataLabels: {
              enabled: true,
              format: '{y:.2f}',
              style: {
                color: '#fff',
                fontSize: '11px',
                fontWeight: '600',
                textOutline: 'none'
              }
            },
            color: {
              linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },
              stops: [
                [0, '#9c27b0'],
                [1, '#6a1b9a']
              ]
            },
            borderRadius: 3
          }
        },
        series: [{
          name: 'Standard Deviation',
          data: sdData,
          color: {
            linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },
            stops: [
              [0, '#9c27b0'],
              [1, '#6a1b9a']
            ]
          }
        }]
      });
    }
    
    // === Profile Plot Function (Highcharts) ===
    function populateProfilePlot(e, ob) {
      const container = document.getElementById("profilePlot");
      if (!container || !ob) return;
      
      // Cache omnibus data for view switching
      cachedOmnibusData = ob;
      
      // Reset UI text for trajectory view
      document.getElementById('profilePlotTitle').textContent = 'Profile Plot';
      document.getElementById('profilePurpose').textContent = 'Visualize the group mean trajectory with a shaded envelope showing the full range of individual values (Min-Max). This reveals patterns of change and where variability is highest across timepoints.';
      document.getElementById('profileNote').innerHTML = '<i class="fa-solid fa-info-circle"></i> <strong>Note:</strong> The blue shaded area represents the full range of individual values (Min-Max), showing the complete spread at each timepoint. Wider areas indicate higher variability.';
      document.getElementById('profileNote').style.background = 'rgba(79,195,247,0.12)';
      document.getElementById('profileNote').style.borderColor = '#4fc3f7';
      document.getElementById('profileNote').style.color = '#81d4fa';
      
      // Get timepoint means and raw data
      const groupDescriptives = ob.groupDescriptives || [];
      if (groupDescriptives.length === 0) return;
      
      const k = groupDescriptives.length;
      const means = groupDescriptives.map(g => g.mean);
      const labels = groupDescriptives.map(g => g.name);
      
      // Calculate Min-Max range from individual subject data
      let minMaxData = [];
      
      if (window.dependentRangeData && lastBundle.setup && lastBundle.setup.selectedColumns) {
        const headers = window.dependentRangeData[0] || [];
        const dataRows = window.dependentRangeData.slice(1);
        const selectedCols = lastBundle.setup.selectedColumns;
        
        // For each timepoint, find min and max across all subjects
        selectedCols.forEach((col, tpIdx) => {
          const colIdx = headers.indexOf(col);
          const values = [];
          
          dataRows.forEach(row => {
            const val = parseFloat(row[colIdx]);
            if (isFinite(val)) {
              values.push(val);
            }
          });
          
          if (values.length > 0) {
            minMaxData.push([Math.min(...values), Math.max(...values)]);
          } else {
            // Fallback to mean Â± SD if no raw data
            minMaxData.push([means[tpIdx] - groupDescriptives[tpIdx].sd, means[tpIdx] + groupDescriptives[tpIdx].sd]);
          }
        });
      } else {
        // Fallback: use mean Â± SD
        minMaxData = means.map((mean, i) => [mean - groupDescriptives[i].sd, mean + groupDescriptives[i].sd]);
      }
      
      console.log(`ðŸ“Š Plotting mean trajectory with Min-Max envelope`);
      
      // Prepare series data
      const series = [];
      
      // Add area range (Min-Max)
      series.push({
        name: 'Min-Max Range',
        data: minMaxData,
        type: 'arearange',
        lineWidth: 0,
        color: 'rgba(79, 195, 247, 0.5)',  // Increased from 0.3 to 0.5 for more prominence
        fillOpacity: 0.5,  // Increased from 0.3 to 0.5
        zIndex: 0,
        marker: {
          enabled: false
        },
        enableMouseTracking: true,
        tooltip: {
          pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.low:.2f} - {point.high:.2f}</b><br/>'
        }
      });
      
      // Add group mean line
      series.push({
        name: 'Group Mean',
        data: means,
        type: 'line',
        color: '#ff9800',
        lineWidth: 4,
        marker: {
          enabled: true,
          radius: 6,
          fillColor: '#ff9800',
          lineColor: '#1a2332',
          lineWidth: 2
        },
        zIndex: 10,
        showInLegend: true
      });
      
      // Create Highcharts chart
      Highcharts.chart('profilePlot', {
        chart: {
          backgroundColor: '#1a2332',
          borderRadius: 4,
          style: {
            fontFamily: 'Segoe UI, Tahoma, sans-serif'
          }
        },
        title: {
          text: null
        },
        credits: {
          enabled: false
        },
        xAxis: {
          categories: labels,
          labels: {
            style: {
              color: '#b0b0b0',
              fontSize: '11px',
              fontWeight: '600'
            }
          },
          gridLineColor: '#2d3748',
          gridLineWidth: 1,
          lineColor: '#4a5568',
          tickColor: '#4a5568'
        },
        yAxis: {
          title: {
            text: 'Value',
            style: {
              color: '#b0b0b0',
              fontSize: '12px',
              fontWeight: '700'
            }
          },
          labels: {
            style: {
              color: '#b0b0b0',
              fontSize: '11px'
            }
          },
          gridLineColor: '#2d3748',
          gridLineWidth: 1
        },
        tooltip: {
          shared: false,
          backgroundColor: 'rgba(0, 0, 0, 0.85)',
          borderColor: '#4fc3f7',
          borderRadius: 8,
          style: {
            color: '#fff',
            fontSize: '12px'
          },
          formatter: function() {
            const isGroupMean = this.series.name === 'Group Mean';
            return `<b>${this.series.name}</b><br/>
                    <b>${this.x}:</b> ${this.y.toFixed(2)}${isGroupMean ? '<br/><span style="color:#ff9800">â—</span> Group average' : ''}`;
          }
        },
        legend: {
          enabled: true,
          align: 'center',
          verticalAlign: 'bottom',
          itemStyle: {
            color: '#b0b0b0',
            fontSize: '11px',
            fontWeight: '600'
          },
          itemHoverStyle: {
            color: '#fff'
          },
          symbolRadius: 0,
          symbolHeight: 3,
          symbolWidth: 24,
          margin: 15
        },
        plotOptions: {
          line: {
            animation: {
              duration: 800
            }
          },
          series: {
            lineWidth: 1,
            states: {
              inactive: {
                opacity: 0.15
              }
            }
          }
        },
        series: series
      });
    }
    
    // === Correlation Matrix Function ===
    function populateCorrelationMatrix(e) {
      console.log("ðŸ” populateCorrelationMatrix called with explore:", e);
      const corrMatrix = e.correlationMatrix;
      if (!corrMatrix) {
        console.warn("âš ï¸ No correlation matrix data found in explore object");
        return;
      }
      
      console.log("ðŸ“Š Correlation matrix data:", corrMatrix);
      
      const tbody = document.getElementById("corrTableBody");
      const heatmapContainer = document.getElementById("correlationHeatmap");
      if (!tbody && !heatmapContainer) {
        console.error("âŒ Could not find corrTableBody or correlationHeatmap elements");
        return;
      }
      
      // Get timepoint names from setup or omnibus data
      const timepoints = lastBundle?.setup?.selectedColumns || lastBundle?.results?.omnibus?.levels || [];
      console.log("ðŸ“ Timepoints:", timepoints);
      
      if (timepoints.length === 0) {
        console.error("âŒ No timepoint names available");
        return;
      }
      
      const correlations = corrMatrix.correlations || [];
      console.log("ðŸ”— Correlations array:", correlations);
      
      if (correlations.length === 0) {
        console.warn("âš ï¸ No correlations computed");
        return;
      }
      
      // Build correlation matrix (2D array)
      const n = timepoints.length;
      const corrGrid = Array(n).fill(null).map(() => Array(n).fill(null));
      
      // Get sample size from first correlation or omnibus
      const sampleSize = lastBundle?.results?.omnibus?.N || correlations[0]?.n || 0;
      
      // Fill diagonal with 1.0 (marked as diagonal)
      for (let i = 0; i < n; i++) {
        corrGrid[i][i] = {r: 1.0, p: 0, n: sampleSize, isDiagonal: true};
      }
      
      // Fill from correlations array
      correlations.forEach(corr => {
        const i = corr.time1 || 0;
        const j = corr.time2 || 0;
        corrGrid[i][j] = {r: corr.r, p: corr.p || 0, n: sampleSize, isDiagonal: false};
        corrGrid[j][i] = {r: corr.r, p: corr.p || 0, n: sampleSize, isDiagonal: false}; // Symmetric
      });
      
      // Render Heatmap
      if (heatmapContainer) {
        let html = '<div style="display:inline-block;overflow-x:auto;max-width:100%;">';
        html += '<table style="border-collapse:collapse;font-size:11px;margin:0 auto;">';
        
        // Header row
        html += '<tr><th style="padding:8px;min-width:80px;border:1px solid rgba(255,255,255,.1);background:#1e3a5f;color:#fff;font-weight:700;"></th>';
        timepoints.forEach(tp => {
          html += `<th style="padding:8px;min-width:80px;border:1px solid rgba(255,255,255,.1);background:#1e3a5f;color:#fff;font-weight:700;">${tp}</th>`;
        });
        html += '</tr>';
        
        // Data rows
        timepoints.forEach((tp, i) => {
          html += `<tr><th style="padding:8px;border:1px solid rgba(255,255,255,.1);background:#1e3a5f;color:#fff;font-weight:700;text-align:right;">${tp}</th>`;
          timepoints.forEach((_, j) => {
            const cell = corrGrid[i][j];
            if (cell) {
              const isDiag = cell.isDiagonal;
              const absR = Math.abs(cell.r);
              
              // Diagonal gets special styling
              if (isDiag) {
                html += `<td style="padding:8px;border:1px solid rgba(255,255,255,.15);background:#2a3a4a;color:#8899aa;text-align:center;font-weight:600;font-style:italic;">`;
                html += `<div style="font-size:13px;">1.000</div>`;
                html += '</td>';
              } else {
                const intensity = absR * 255;
                const bgColor = cell.r >= 0 
                  ? `rgb(${255-intensity}, ${200 + intensity*0.2}, ${255-intensity*0.7})` // Blue for positive
                  : `rgb(${200 + intensity*0.2}, ${255-intensity*0.8}, ${255-intensity})`;  // Red for negative
                
                const textColor = absR > 0.5 ? '#fff' : '#263238';
                const showPVal = document.getElementById('showCorrPValue')?.checked !== false;
                const showN = document.getElementById('showCorrN')?.checked !== false;
                
                html += `<td style="padding:8px;border:1px solid rgba(255,255,255,.1);background:${bgColor};color:${textColor};text-align:center;font-weight:700;cursor:pointer;text-decoration:underline;" 
                  onclick="openCorrScatterPlot(${i}, ${j}, ${cell.r})" 
                  title="r = ${cell.r.toFixed(3)}, p = ${cell.p.toFixed(4)}, n = ${cell.n}. Click to view scatter plot.">`;
                html += `<div style="font-size:13px;text-decoration:underline;">${cell.r.toFixed(3)}</div>`;
                if (showPVal) html += `<div style="font-size:9px;opacity:0.8;">p = ${cell.p < 0.001 ? '<0.001' : cell.p.toFixed(3)}</div>`;
                if (showN) html += `<div style="font-size:9px;opacity:0.7;">N = ${cell.n}</div>`;
                html += '</td>';
              }
            } else {
              html += '<td style="padding:8px;border:1px solid rgba(255,255,255,.1);background:#333;"></td>';
            }
          });
          html += '</tr>';
        });
        
        html += '</table></div>';
        heatmapContainer.innerHTML = html;
      }
      
      // Also populate table view
      if (tbody) {
        tbody.innerHTML = '';
        
        // Check if we should show p-value and n
        const showPVal = document.getElementById('showCorrPValue')?.checked || false;
        const showN = document.getElementById('showCorrN')?.checked || false;
        
        // Table header
        const tableHeader = document.getElementById('corrTableHeader');
        if (tableHeader) {
          let headerHTML = '<th style="padding:6px 8px;border:1px solid rgba(255,255,255,.18);color:#fff;"></th>';
          timepoints.forEach(tp => {
            headerHTML += `<th style="padding:6px 8px;border:1px solid rgba(255,255,255,.18);color:#fff;">${tp}</th>`;
          });
          tableHeader.innerHTML = headerHTML;
        }
        
        // Table body
        timepoints.forEach((tp, i) => {
          const tr = document.createElement('tr');
          if (i % 2 === 1) tr.style.background = 'rgba(255,255,255,.05)';
          
          // Row header
          const th = document.createElement('th');
          th.textContent = tp;
          th.style.padding = '6px 8px';
          th.style.border = '1px solid rgba(255,255,255,.18)';
          th.style.background = '#1e3a5f';
          th.style.color = '#fff';
          th.style.textAlign = 'right';
          tr.appendChild(th);
          
          // Cells
          timepoints.forEach((_, j) => {
            const td = document.createElement('td');
            const cell = corrGrid[i][j];
            if (cell) {
              const isDiag = cell.isDiagonal;
              
              // Diagonal cells get special styling
              if (isDiag) {
                td.style.background = '#2a3a4a';
                td.style.color = '#8899aa';
                td.style.fontWeight = '600';
                td.style.fontStyle = 'italic';
                const rDiv = document.createElement('div');
                rDiv.textContent = '1.000';
                rDiv.style.fontSize = '13px';
                td.appendChild(rDiv);
              } else {
                // Non-diagonal cells are clickable
                td.style.cursor = 'pointer';
                td.style.textDecoration = 'underline';
                td.setAttribute('title', `r = ${cell.r.toFixed(3)}, p = ${cell.p.toFixed(4)}, n = ${cell.n}. Click to view scatter plot.`);
                td.onclick = () => openCorrScatterPlot(i, j, cell.r);
                
                // Create container div for multi-line content
                const container = document.createElement('div');
                
                // R value (always shown)
                const rDiv = document.createElement('div');
                rDiv.textContent = cell.r.toFixed(3);
                rDiv.style.fontWeight = '700';
                rDiv.style.fontSize = '13px';
                rDiv.style.textDecoration = 'underline';
                rDiv.style.color = cell.r > 0.7 ? '#4caf50' : cell.r > 0.4 ? '#ff9800' : cell.r < -0.3 ? '#f44336' : 'inherit';
                container.appendChild(rDiv);
                
                // P-value (conditional)
                if (showPVal) {
                  const pDiv = document.createElement('div');
                  pDiv.textContent = `p = ${cell.p < 0.001 ? '<0.001' : cell.p.toFixed(3)}`;
                  pDiv.style.fontSize = '9px';
                  pDiv.style.opacity = '0.7';
                  pDiv.style.marginTop = '2px';
                  container.appendChild(pDiv);
                }
                
                // N value (conditional) - skip for diagonal
                if (showN) {
                  const nDiv = document.createElement('div');
                  nDiv.textContent = `N = ${cell.n}`;
                  nDiv.style.fontSize = '9px';
                  nDiv.style.opacity = '0.6';
                  nDiv.style.marginTop = '2px';
                  container.appendChild(nDiv);
                }
                
                td.appendChild(container);
              }
            }
            td.style.padding = '6px 8px';
            td.style.border = '1px solid rgba(255,255,255,.18)';
            td.style.textAlign = 'center';
            tr.appendChild(td);
          });
          
          tbody.appendChild(tr);
        });
      }
      
      // Populate summary statistics
      if (corrMatrix.avgR !== undefined) {
        setText("corrAvgR", corrMatrix.avgR.toFixed(3));
        setText("corrRange", corrMatrix.range.toFixed(3) + " (" + corrMatrix.minR.toFixed(2) + " to " + corrMatrix.maxR.toFixed(2) + ")");
        setText("corrCompound", corrMatrix.compoundSymmetry);
        setText("corrInterpretation", corrMatrix.interpretation);
      }
    }
    
    // === Event Handlers for Correlation Controls ===
    function switchCorrView(view) {
      const heatmap = document.getElementById('correlationHeatmap');
      const table = document.getElementById('correlationTable');
      
      // Update button styles
      document.querySelectorAll('.corr-view-btn').forEach(btn => {
        if (btn.getAttribute('data-view') === view) {
          btn.classList.add('active');
          btn.style.background = '#f57c00';
          btn.style.color = '#fff';
        } else {
          btn.classList.remove('active');
          btn.style.background = 'transparent';
          btn.style.color = '#f57c00';
        }
      });
      
      // Toggle views
      if (view === 'heatmap') {
        if (heatmap) heatmap.style.display = 'block';
        if (table) table.style.display = 'none';
      } else {
        if (heatmap) heatmap.style.display = 'none';
        if (table) table.style.display = 'table';
      }
    }
    
    function updateCorrHighlight(value) {
      const sliderValue = document.getElementById('corrHighlightValue');
      if (sliderValue) {
        sliderValue.textContent = parseFloat(value).toFixed(2);
      }
      // TODO: Implement cell highlighting based on threshold
    }
    
    function toggleCorrColumns() {
      // Re-render the correlation matrix to show/hide columns
      if (lastBundle && lastBundle.explore) {
        populateCorrelationMatrix(lastBundle.explore);
      }
    }
    
    // === Scatter Plot Modal Functions ===
    let scatterState = {
      rawPoints: [],
      rawData: [],  // Store raw data with row info
      xVar: '',
      yVar: '',
      xTransform: 'none',
      yTransform: 'none',
      fitType: 'none',
      activeTransformAxis: 'x',
      chart: null
    };
    
    function openCorrScatterPlot(timeIdx1, timeIdx2, rValue) {
      if (!window.dependentRangeData || !lastBundle?.setup?.selectedColumns) {
        console.warn("No data available for scatter plot");
        return;
      }
      
      const headers = window.dependentRangeData[0] || [];
      const dataRows = window.dependentRangeData.slice(1);
      const selectedCols = lastBundle.setup.selectedColumns;
      
      const col1Name = selectedCols[timeIdx1];
      const col2Name = selectedCols[timeIdx2];
      
      // Extract data points
      const col1Idx = headers.indexOf(col1Name);
      const col2Idx = headers.indexOf(col2Name);
      
      if (col1Idx < 0 || col2Idx < 0) {
        console.error("Column indices not found for scatter plot");
        return;
      }
      
      const points = [];
      const rawData = [];
      dataRows.forEach((row, idx) => {
        const x = parseFloat(row[col1Idx]);
        const y = parseFloat(row[col2Idx]);
        rawData.push({ rowNum: idx + 1, x, y, valid: isFinite(x) && isFinite(y) });
        if (isFinite(x) && isFinite(y)) {
          points.push([x, y]);
        }
      });
      
      if (points.length === 0) {
        console.warn("No valid data points for scatter plot");
        return;
      }
      
      // Update modal content
      const modal = document.getElementById('corrScatterModal');
      const titleEl = document.getElementById('scatterTitle');
      titleEl.textContent = `Scatter Plot: ${col1Name} vs ${col2Name}`;
      
      // Initialize scatter state
      scatterState.rawPoints = points;
      scatterState.rawData = rawData;
      scatterState.xVar = col1Name;
      scatterState.yVar = col2Name;
      scatterState.xTransform = 'none';
      scatterState.yTransform = 'none';
      scatterState.fitType = 'none';
      scatterState.activeTransformAxis = 'x';
      scatterState.chart = null;
      
      // Reset controls
      resetScatterControls();
      
      // Calculate and display statistics and chart
      refreshScatterPlot();
      
      // Populate listwise data table
      populateScatterDataTable();
      
      // Show modal
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
    }
    
    function closeCorrScatterModal() {
      const modal = document.getElementById('corrScatterModal');
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
      if (scatterState.chart) {
        scatterState.chart.destroy();
        scatterState.chart = null;
      }
    }
    
    function resetScatterControls() {
      document.getElementById('fit-none').classList.add('active');
      ['fit-linear','fit-polynomial','fit-exponential','fit-logarithmic','fit-power'].forEach(id => {
        document.getElementById(id).classList.remove('active');
      });
      setScatterTransformAxis('x');
      ['transform-none','transform-ln','transform-inverse','transform-sqrt','transform-square'].forEach(id => {
        document.getElementById(id).classList.remove('active');
      });
      document.getElementById('transform-none').classList.add('active');
    }
    
    function refreshScatterPlot() {
      const points = getTransformedScatterPoints();
      renderScatterChart(points);
      updateScatterStats(points);
      applyScatterFit(scatterState.fitType, points);
    }
    
    function getTransformedScatterPoints() {
      return scatterState.rawPoints
        .map(([x, y]) => [
          transformScatterValue(x, scatterState.xTransform),
          transformScatterValue(y, scatterState.yTransform)
        ])
        .filter(([x, y]) => x !== null && y !== null && isFinite(x) && isFinite(y));
    }
    
    function transformScatterValue(value, type) {
      if (!isFinite(value)) return null;
      switch (type) {
        case 'ln':
          return value > 0 ? Math.log(value) : null;
        case 'inverse':
          return value !== 0 ? 1 / value : null;
        case 'sqrt':
          return value >= 0 ? Math.sqrt(value) : null;
        case 'square':
          return value * value;
        default:
          return value;
      }
    }
    
    function updateScatterStats(points) {
      const n = points.length;
      const xs = points.map(p => p[0]);
      const ys = points.map(p => p[1]);
      const r = calculatePearsonCorr(xs, ys);
      const r2 = r * r;
      const p = calculateCorrPValue(r, n);
      
      document.getElementById('scatterN').textContent = n;
      document.getElementById('scatterR').textContent = isFinite(r) ? r.toFixed(4) : '--';
      document.getElementById('scatterP').textContent = isFinite(p) ? (p < 0.0001 ? '<0.0001' : p.toExponential(3)) : '--';
      document.getElementById('scatterR2').textContent = isFinite(r2) ? r2.toFixed(4) : '--';
    }
    
    function calculatePearsonCorr(x, y) {
      if (x.length < 2) return NaN;
      const n = x.length;
      const meanX = x.reduce((a, b) => a + b, 0) / n;
      const meanY = y.reduce((a, b) => a + b, 0) / n;
      let num = 0, denX = 0, denY = 0;
      for (let i = 0; i < n; i++) {
        const dx = x[i] - meanX;
        const dy = y[i] - meanY;
        num += dx * dy;
        denX += dx * dx;
        denY += dy * dy;
      }
      return denX === 0 || denY === 0 ? NaN : num / Math.sqrt(denX * denY);
    }
    
    function calculateCorrPValue(r, n) {
      if (!isFinite(r) || n < 3) return NaN;
      const t = Math.abs(r) * Math.sqrt((n - 2) / Math.max(1e-10, 1 - r * r));
      return approximateTTestP(t, n - 2);
    }
    
    function renderScatterChart(points) {
      const chartContainer = document.getElementById('scatterChart');
      if (!chartContainer) return;
      
      // Group overlapping points
      const pointGroups = new Map();
      points.forEach(([x, y]) => {
        const key = `${x.toFixed(6)},${y.toFixed(6)}`;
        pointGroups.set(key, (pointGroups.get(key) || 0) + 1);
      });
      
      // Create data with marker sizes based on count
      const chartData = Array.from(pointGroups.entries()).map(([key, count]) => {
        const [x, y] = key.split(',').map(parseFloat);
        return {
          x: x,
          y: y,
          marker: {
            radius: Math.min(4 + count * 1.5, 12),
            fillColor: count > 1 ? 'rgba(255,165,120,0.8)' : 'rgba(120,200,255,0.7)',
            lineColor: '#fff',
            lineWidth: 1
          },
          count: count
        };
      });
      
      const xLabel = scatterState.xTransform !== 'none' 
        ? `${scatterState.xTransform}(${scatterState.xVar})` 
        : scatterState.xVar;
      const yLabel = scatterState.yTransform !== 'none' 
        ? `${scatterState.yTransform}(${scatterState.yVar})` 
        : scatterState.yVar;
      
      if (scatterState.chart) {
        scatterState.chart.destroy();
      }
      
      scatterState.chart = Highcharts.chart(chartContainer, {
        chart: {
          type: 'scatter',
          backgroundColor: 'transparent',
          zoomType: 'xy',
          height: 280
        },
        title: { text: '' },
        xAxis: {
          title: { text: xLabel, style: { color: '#a0a0a0', fontSize: '11px' } },
          gridLineColor: 'rgba(255,255,255,0.08)',
          labels: { style: { color: '#e0e0e0', fontSize: '10px' } },
          lineColor: '#555',
          tickColor: '#555'
        },
        yAxis: {
          title: { text: yLabel, style: { color: '#a0a0a0', fontSize: '11px' } },
          gridLineColor: 'rgba(255,255,255,0.08)',
          labels: { style: { color: '#e0e0e0', fontSize: '10px' } },
          lineColor: '#555',
          tickColor: '#555'
        },
        legend: {
          enabled: false
        },
        credits: { enabled: false },
        tooltip: {
          backgroundColor: 'rgba(30,30,30,0.9)',
          borderColor: '#555',
          style: { color: '#ffffff', fontSize: '11px' },
          formatter: function() {
            let html = `<b>${xLabel}:</b> ${this.x.toFixed(3)}<br/><b>${yLabel}:</b> ${this.y.toFixed(3)}`;
            if (this.point.count > 1) {
              html += `<br/><b>Overlapping points:</b> ${this.point.count}`;
            }
            return html;
          }
        },
        plotOptions: {
          scatter: {
            marker: {
              states: {
                hover: {
                  lineWidthPlus: 2
                }
              }
            }
          }
        },
        series: [{
          name: 'Observations',
          data: chartData,
          color: 'rgba(120,200,255,0.7)'
        }]
      });
    }
    
    function setScatterTransformAxis(axis) {
      scatterState.activeTransformAxis = axis;
      document.getElementById('transform-x-tab').classList.toggle('active', axis === 'x');
      document.getElementById('transform-y-tab').classList.toggle('active', axis === 'y');
      updateScatterTransformButtons();
    }
    
    function applyScatterTransformation(type) {
      if (scatterState.activeTransformAxis === 'x') {
        scatterState.xTransform = type;
      } else {
        scatterState.yTransform = type;
      }
      updateScatterTransformButtons();
      refreshScatterPlot();
      populateScatterDataTable(); // Update data table with transformed values
    }
    
    function updateScatterTransformButtons() {
      const activeType = scatterState.activeTransformAxis === 'x'
        ? scatterState.xTransform
        : scatterState.yTransform;
      ['transform-none','transform-ln','transform-inverse','transform-sqrt','transform-square'].forEach(id => {
        document.getElementById(id).classList.remove('active');
      });
      document.getElementById(`transform-${activeType}`).classList.add('active');
    }
    
    function applyScatterFit(type, pointsOverride = null) {
      scatterState.fitType = type;
      ['fit-none','fit-linear','fit-polynomial','fit-exponential','fit-logarithmic','fit-power'].forEach(id => {
        document.getElementById(id).classList.remove('active');
      });
      document.getElementById(`fit-${type}`).classList.add('active');
      
      if (!scatterState.chart) return;
      
      const points = pointsOverride || getTransformedScatterPoints();
      const fitResult = buildScatterFitSeries(points, type);
      
      // Remove existing fit series
      const existing = scatterState.chart.series.find(s => s.name === 'Fit');
      if (existing) {
        existing.remove(false);
      }
      
      // Add new fit series
      if (fitResult && fitResult.series) {
        scatterState.chart.addSeries(fitResult.series, false);
      }
      
      updateFitEquation(type, fitResult ? fitResult.equation : null);
      scatterState.chart.redraw();
    }
    
    function buildScatterFitSeries(points, type) {
      if (type === 'none' || points.length < 2) {
        return null;
      }
      
      let model = null;
      let equation = '';
      
      try {
        if (type === 'linear') {
          model = simpleLinearRegression(points);
          equation = `y = ${model.slope.toFixed(3)}x + ${model.intercept.toFixed(3)}`;
        } else if (type === 'polynomial') {
          model = polynomialRegression(points, 2);
          if (model) {
            const [a, b, c] = model.coefficients;
            equation = `y = ${a.toFixed(3)}xÂ² + ${b.toFixed(3)}x + ${c.toFixed(3)}`;
          }
        } else if (type === 'exponential') {
          model = exponentialRegression(points);
          if (model) {
            equation = `y = ${model.a.toFixed(3)} Ã— e^(${model.b.toFixed(3)}x)`;
          }
        } else if (type === 'logarithmic') {
          model = logarithmicRegression(points);
          if (model) {
            equation = `y = ${model.a.toFixed(3)} + ${model.b.toFixed(3)} Ã— ln(x)`;
          }
        } else if (type === 'power') {
          model = powerRegression(points);
          if (model) {
            equation = `y = ${model.a.toFixed(3)} Ã— x^${model.b.toFixed(3)}`;
          }
        }
      } catch (e) {
        console.warn('Fit calculation failed:', e);
        return null;
      }
      
      if (!model || !model.predict) return null;
      
      // Generate fit line
      const xs = points.map(p => p[0]);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const steps = 50;
      const line = [];
      
      for (let i = 0; i <= steps; i++) {
        const x = minX + (maxX - minX) * (i / steps);
        const y = model.predict(x);
        if (isFinite(y)) {
          line.push([x, y]);
        }
      }
      
      return {
        series: {
          name: 'Fit',
          type: 'line',
          data: line,
          color: 'rgba(255,165,120,0.9)',
          marker: { enabled: false },
          lineWidth: 2,
          enableMouseTracking: false
        },
        equation: equation
      };
    }
    
    function simpleLinearRegression(points) {
      const n = points.length;
      const xs = points.map(p => p[0]);
      const ys = points.map(p => p[1]);
      const meanX = xs.reduce((a, b) => a + b, 0) / n;
      const meanY = ys.reduce((a, b) => a + b, 0) / n;
      
      let num = 0, den = 0;
      for (let i = 0; i < n; i++) {
        num += (xs[i] - meanX) * (ys[i] - meanY);
        den += (xs[i] - meanX) * (xs[i] - meanX);
      }
      
      const slope = den !== 0 ? num / den : 0;
      const intercept = meanY - slope * meanX;
      
      return {
        slope,
        intercept,
        predict: (x) => slope * x + intercept
      };
    }
    
    function polynomialRegression(points, order) {
      // Simple quadratic regression for order = 2
      if (order !== 2 || points.length < 3) return null;
      
      const n = points.length;
      const xs = points.map(p => p[0]);
      const ys = points.map(p => p[1]);
      
      // Build design matrix for quadratic fit
      let sumX = 0, sumX2 = 0, sumX3 = 0, sumX4 = 0;
      let sumY = 0, sumXY = 0, sumX2Y = 0;
      
      for (let i = 0; i < n; i++) {
        const x = xs[i];
        const y = ys[i];
        sumX += x;
        sumX2 += x * x;
        sumX3 += x * x * x;
        sumX4 += x * x * x * x;
        sumY += y;
        sumXY += x * y;
        sumX2Y += x * x * y;
      }
      
      // Solve using Cramer's rule (simplified for 3x3)
      const det = n * (sumX2 * sumX4 - sumX3 * sumX3) - sumX * (sumX * sumX4 - sumX2 * sumX3) + sumX2 * (sumX * sumX3 - sumX2 * sumX2);
      
      if (Math.abs(det) < 1e-10) return null;
      
      const a = ((sumY * (sumX2 * sumX4 - sumX3 * sumX3) - sumXY * (sumX * sumX4 - sumX2 * sumX3) + sumX2Y * (sumX * sumX3 - sumX2 * sumX2)) / det);
      const b = ((n * (sumXY * sumX4 - sumX2Y * sumX3) - sumY * (sumX * sumX4 - sumX2 * sumX3) + sumX2Y * (sumX * sumX2 - n * sumX3)) / det);
      const c = ((n * (sumX2 * sumX2Y - sumX3 * sumXY) - sumX * (sumX * sumX2Y - sumX2 * sumXY) + sumY * (sumX * sumX3 - sumX2 * sumX2)) / det);
      
      return {
        coefficients: [a, b, c],
        predict: (x) => a * x * x + b * x + c
      };
    }
    
    function exponentialRegression(points) {
      // Transform to linear: ln(y) = ln(a) + b*x
      const validPoints = points.filter(p => p[1] > 0);
      if (validPoints.length < 2) return null;
      
      const lnPoints = validPoints.map(([x, y]) => [x, Math.log(y)]);
      const linear = simpleLinearRegression(lnPoints);
      
      const a = Math.exp(linear.intercept);
      const b = linear.slope;
      
      return {
        a, b,
        predict: (x) => a * Math.exp(b * x)
      };
    }
    
    function logarithmicRegression(points) {
      // y = a + b*ln(x)
      const validPoints = points.filter(p => p[0] > 0);
      if (validPoints.length < 2) return null;
      
      const lnPoints = validPoints.map(([x, y]) => [Math.log(x), y]);
      const linear = simpleLinearRegression(lnPoints);
      
      return {
        a: linear.intercept,
        b: linear.slope,
        predict: (x) => x > 0 ? linear.intercept + linear.slope * Math.log(x) : NaN
      };
    }
    
    function powerRegression(points) {
      // y = a * x^b => ln(y) = ln(a) + b*ln(x)
      const validPoints = points.filter(p => p[0] > 0 && p[1] > 0);
      if (validPoints.length < 2) return null;
      
      const lnPoints = validPoints.map(([x, y]) => [Math.log(x), Math.log(y)]);
      const linear = simpleLinearRegression(lnPoints);
      
      const a = Math.exp(linear.intercept);
      const b = linear.slope;
      
      return {
        a, b,
        predict: (x) => x > 0 ? a * Math.pow(x, b) : NaN
      };
    }
    
    function updateFitEquation(type, equation) {
      const el = document.getElementById('fitEquation');
      if (!el) return;
      if (type === 'none' || !equation) {
        el.textContent = 'Equation: â€”';
      } else {
        el.textContent = `Equation: ${equation}`;
      }
    }
    
    // === Listwise Data Table Functions ===
    function populateScatterDataTable() {
      const tbody = document.getElementById('scatterDataTableBody');
      const colXHeader = document.getElementById('scatterDataColX');
      const colYHeader = document.getElementById('scatterDataColY');
      const dataCount = document.getElementById('scatterDataCount');
      const excludedDiv = document.getElementById('scatterDataExcluded');
      const excludedText = document.getElementById('scatterExcludedText');
      
      if (!tbody) return;
      
      // Update column headers
      const xLabel = scatterState.xTransform !== 'none' 
        ? `${scatterState.xTransform}(${scatterState.xVar})` 
        : scatterState.xVar;
      const yLabel = scatterState.yTransform !== 'none' 
        ? `${scatterState.yTransform}(${scatterState.yVar})` 
        : scatterState.yVar;
      
      colXHeader.textContent = xLabel;
      colYHeader.textContent = yLabel;
      
      // Count valid and excluded
      const validData = scatterState.rawData.filter(d => d.valid);
      const excludedCount = scatterState.rawData.length - validData.length;
      
      // Update count
      dataCount.textContent = `(n=${validData.length})`;
      
      // Show/hide excluded message
      if (excludedCount > 0) {
        excludedDiv.style.display = 'flex';
        excludedText.textContent = `Excluded: ${excludedCount} row${excludedCount > 1 ? 's' : ''} with missing data`;
      } else {
        excludedDiv.style.display = 'none';
      }
      
      // Populate table
      tbody.innerHTML = '';
      validData.forEach(item => {
        const tr = document.createElement('tr');
        
        // Row number
        const tdNum = document.createElement('td');
        tdNum.textContent = item.rowNum;
        tr.appendChild(tdNum);
        
        // X value (transformed if applicable)
        const tdX = document.createElement('td');
        const xTransformed = transformScatterValue(item.x, scatterState.xTransform);
        tdX.textContent = xTransformed !== null && isFinite(xTransformed) ? xTransformed.toFixed(4) : 'â€”';
        tr.appendChild(tdX);
        
        // Y value (transformed if applicable)
        const tdY = document.createElement('td');
        const yTransformed = transformScatterValue(item.y, scatterState.yTransform);
        tdY.textContent = yTransformed !== null && isFinite(yTransformed) ? yTransformed.toFixed(4) : 'â€”';
        tr.appendChild(tdY);
        
        tbody.appendChild(tr);
      });
    }
    
    function toggleScatterData() {
      const content = document.getElementById('scatterDataContent');
      const toggle = document.getElementById('scatterDataToggle');
      
      if (content.style.display === 'none') {
        content.style.display = 'block';
        toggle.classList.add('expanded');
      } else {
        content.style.display = 'none';
        toggle.classList.remove('expanded');
      }
    }
    
    function copyScatterData(event) {
      event.stopPropagation(); // Prevent toggling when clicking copy
      
      const validData = scatterState.rawData.filter(d => d.valid);
      
      const xLabel = scatterState.xTransform !== 'none' 
        ? `${scatterState.xTransform}(${scatterState.xVar})` 
        : scatterState.xVar;
      const yLabel = scatterState.yTransform !== 'none' 
        ? `${scatterState.yTransform}(${scatterState.yVar})` 
        : scatterState.yVar;
      
      // Create tab-separated values
      let text = `Row\t${xLabel}\t${yLabel}\n`;
      validData.forEach(item => {
        const xTransformed = transformScatterValue(item.x, scatterState.xTransform);
        const yTransformed = transformScatterValue(item.y, scatterState.yTransform);
        const xVal = xTransformed !== null && isFinite(xTransformed) ? xTransformed.toFixed(4) : '';
        const yVal = yTransformed !== null && isFinite(yTransformed) ? yTransformed.toFixed(4) : '';
        text += `${item.rowNum}\t${xVal}\t${yVal}\n`;
      });
      
      // Copy to clipboard
      navigator.clipboard.writeText(text).then(() => {
        const btn = event.currentTarget;
        const icon = btn.querySelector('i');
        const originalHTML = btn.innerHTML;
        
        // Show success feedback
        btn.innerHTML = '<i class="fa-solid fa-check"></i> Copied!';
        btn.style.background = 'rgba(76,175,80,0.3)';
        btn.style.borderColor = '#4caf50';
        btn.style.color = '#4caf50';
        
        setTimeout(() => {
          btn.innerHTML = originalHTML;
          btn.style.background = '';
          btn.style.borderColor = '';
          btn.style.color = '';
        }, 1500);
      }).catch(err => {
        console.error('Failed to copy:', err);
        alert('Failed to copy data to clipboard');
      });
    }
    
    function switchCorrType(type) {
      // Update button styles
      document.querySelectorAll('.corr-type-btn').forEach(btn => {
        if (btn.getAttribute('data-type') === type) {
          btn.classList.add('active');
          btn.style.background = '#5c6bc0';
          btn.style.color = '#fff';
        } else {
          btn.classList.remove('active');
          btn.style.background = 'transparent';
          btn.style.color = '#5c6bc0';
        }
      });
      
      // Recompute correlations with selected type
      console.log('Correlation type changed to:', type);
      
      if (!lastBundle || !window.dependentRangeData) {
        console.warn('Cannot switch correlation type: no data available');
        return;
      }
      
      // Recompute correlations and update display
      const headers = window.dependentRangeData[0] || [];
      const dataRows = window.dependentRangeData.slice(1);
      const selectedCols = lastBundle.setup?.selectedColumns || [];
      
      if (selectedCols.length < 2) {
        console.warn('Need at least 2 variables for correlation');
        return;
      }
      
      // Extract complete cases
      const completeCases = [];
      dataRows.forEach(row => {
        const values = selectedCols.map(col => {
          const idx = headers.indexOf(col);
          return idx >= 0 ? parseFloat(row[idx]) : NaN;
        });
        if (values.every(v => isFinite(v))) {
          completeCases.push(values);
        }
      });
      
      // Compute new correlation matrix
      const newCorrMatrix = computeCorrelationMatrix(selectedCols, completeCases, type);
      
      // Update explore object with new correlations
      if (lastBundle.explore) {
        lastBundle.explore.correlationMatrix = newCorrMatrix;
      }
      
      // Re-render the correlation display
      populateCorrelationMatrix(lastBundle.explore);
    }
    
    // === Correlation Computation Functions ===
    
    // Pearson correlation
    function pearsonCorrelation(x, y) {
      const n = x.length;
      if (n !== y.length || n < 2) return { r: NaN, p: NaN };
      
      const meanX = x.reduce((a, b) => a + b, 0) / n;
      const meanY = y.reduce((a, b) => a + b, 0) / n;
      
      let numerator = 0;
      let sumXSq = 0;
      let sumYSq = 0;
      
      for (let i = 0; i < n; i++) {
        const dx = x[i] - meanX;
        const dy = y[i] - meanY;
        numerator += dx * dy;
        sumXSq += dx * dx;
        sumYSq += dy * dy;
      }
      
      const denominator = Math.sqrt(sumXSq * sumYSq);
      const r = denominator > 0 ? numerator / denominator : 0;
      
      // Compute p-value using t-distribution approximation
      const t = Math.abs(r) * Math.sqrt((n - 2) / Math.max(1e-10, 1 - r * r));
      const p = approximateTTestP(t, n - 2);
      
      return { r, p };
    }
    
    // Spearman rank correlation
    function spearmanCorrelation(x, y) {
      const n = x.length;
      if (n !== y.length || n < 2) return { r: NaN, p: NaN };
      
      // Convert to ranks
      const xRanks = getRanks(x);
      const yRanks = getRanks(y);
      
      // Compute Pearson on ranks
      return pearsonCorrelation(xRanks, yRanks);
    }
    
    // Kendall tau correlation
    function kendallCorrelation(x, y) {
      const n = x.length;
      if (n !== y.length || n < 2) return { r: NaN, p: NaN };
      
      let concordant = 0;
      let discordant = 0;
      
      for (let i = 0; i < n - 1; i++) {
        for (let j = i + 1; j < n; j++) {
          const signX = Math.sign(x[j] - x[i]);
          const signY = Math.sign(y[j] - y[i]);
          
          if (signX * signY > 0) {
            concordant++;
          } else if (signX * signY < 0) {
            discordant++;
          }
        }
      }
      
      const tau = (concordant - discordant) / (0.5 * n * (n - 1));
      
      // Approximate p-value for Kendall's tau
      const z = Math.abs(tau) * Math.sqrt((9 * n * (n - 1)) / (2 * (2 * n + 5)));
      const p = 2 * (1 - normalCDF(z));
      
      return { r: tau, p };
    }
    
    // Helper: Convert values to ranks
    function getRanks(arr) {
      const indexed = arr.map((val, idx) => ({ val, idx }));
      indexed.sort((a, b) => a.val - b.val);
      
      const ranks = new Array(arr.length);
      for (let i = 0; i < indexed.length; i++) {
        ranks[indexed[i].idx] = i + 1;
      }
      return ranks;
    }
    
    // Helper: Normal CDF approximation
    function normalCDF(z) {
      const t = 1 / (1 + 0.2316419 * Math.abs(z));
      const d = 0.3989423 * Math.exp(-z * z / 2);
      const p = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
      return z > 0 ? 1 - p : p;
    }
    
    // Helper: Approximate t-test p-value using better t-distribution approximation
    function approximateTTestP(t, df) {
      const absT = Math.abs(t);
      
      // Handle edge cases
      if (!isFinite(absT) || df < 1) return 1;
      if (absT === 0) return 1;
      
      // For large df (>30), t-distribution approximates normal distribution
      if (df > 30) {
        return 2 * (1 - normalCDF(absT));
      }
      
      // Use Hill's approximation for t-distribution CDF
      // This is reasonably accurate for most practical purposes
      const x = df / (df + absT * absT);
      const a = df / 2;
      const b = 0.5;
      
      // Incomplete beta function approximation using continued fraction
      let beta = incompleteBeta(x, a, b);
      
      return beta; // Two-tailed p-value
    }
    
    // Incomplete beta function approximation
    function incompleteBeta(x, a, b) {
      if (x === 0) return 0;
      if (x === 1) return 1;
      
      // Use series expansion for small x
      const lbeta = logGamma(a) + logGamma(b) - logGamma(a + b);
      const front = Math.exp(Math.log(x) * a + Math.log(1 - x) * b - lbeta) / a;
      
      let f = 1, c = 1, d = 0;
      let result = front;
      
      for (let i = 0; i <= 200; i++) {
        const m = i / 2;
        let numerator, denominator;
        
        if (i === 0) {
          numerator = 1;
        } else if (i % 2 === 0) {
          numerator = (m * (b - m) * x) / ((a + 2 * m - 1) * (a + 2 * m));
        } else {
          numerator = -((a + m) * (a + b + m) * x) / ((a + 2 * m) * (a + 2 * m + 1));
        }
        
        d = 1 + numerator * d;
        if (Math.abs(d) < 1e-30) d = 1e-30;
        d = 1 / d;
        
        c = 1 + numerator / c;
        if (Math.abs(c) < 1e-30) c = 1e-30;
        
        const cd = c * d;
        f *= cd;
        
        if (Math.abs(cd - 1) < 1e-8) break;
      }
      
      return result * f / a;
    }
    
    // Log gamma function (Lanczos approximation)
    function logGamma(z) {
      const g = 7;
      const C = [
        0.99999999999980993,
        676.5203681218851,
        -1259.1392167224028,
        771.32342877765313,
        -176.61502916214059,
        12.507343278686905,
        -0.13857109526572012,
        9.9843695780195716e-6,
        1.5056327351493116e-7
      ];
      
      if (z < 0.5) {
        return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - logGamma(1 - z);
      }
      
      z -= 1;
      let x = C[0];
      for (let i = 1; i < g + 2; i++) {
        x += C[i] / (z + i);
      }
      
      const t = z + g + 0.5;
      return 0.5 * Math.log(2 * Math.PI) + (z + 0.5) * Math.log(t) - t + Math.log(x);
    }
    
    // Compute full correlation matrix
    function computeCorrelationMatrix(variables, completeCases, type = 'pearson') {
      const n = variables.length;
      const correlations = [];
      
      for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
          const xi = completeCases.map(row => row[i]);
          const xj = completeCases.map(row => row[j]);
          
          let result;
          if (type === 'spearman') {
            result = spearmanCorrelation(xi, xj);
          } else if (type === 'kendall') {
            result = kendallCorrelation(xi, xj);
          } else {
            result = pearsonCorrelation(xi, xj);
          }
          
          correlations.push({
            time1: i,
            time2: j,
            r: result.r,
            p: result.p,
            n: completeCases.length,
            label: `${variables[i]} - ${variables[j]}`
          });
        }
      }
      
      // Compute summary statistics
      const rValues = correlations.map(c => c.r).filter(r => isFinite(r));
      const avgR = rValues.length > 0 ? rValues.reduce((a, b) => a + b, 0) / rValues.length : 0;
      const minR = rValues.length > 0 ? Math.min(...rValues) : 0;
      const maxR = rValues.length > 0 ? Math.max(...rValues) : 0;
      const range = maxR - minR;
      
      const compoundSymmetry = range < 0.2 ? "Good" : range < 0.4 ? "Moderate" : "Poor";
      const interpretation = avgR > 0.7 ? "Strong within-subject consistency" :
                            avgR > 0.4 ? "Moderate within-subject consistency" :
                            "Weak within-subject consistency (high individual variability)";
      
      return {
        correlations,
        avgR,
        minR,
        maxR,
        range,
        compoundSymmetry,
        interpretation,
        type // Store the correlation type
      };
    }
    
    // ===== AI INTERPRETATION FUNCTIONS =====
    
    function saveApiKey() {
      const input = document.getElementById('groqApiKeyInput');
      const key = input.value.trim();
      
      if (!key) {
        alert('Please enter an API key');
        return;
      }
      
      localStorage.setItem('GROQ_API_KEY', key);
      window.AI_API_KEY = key;
      input.value = '';
      input.type = 'password';
      
      alert('API key saved successfully!');
      console.log('ðŸ”‘ API key saved');
    }
    
    function saveModelPreference() {
      const modelSelect = document.getElementById('aiModelSelect');
      const selectedModel = modelSelect.value;
      localStorage.setItem('AI_MODEL_PREFERENCE', selectedModel);
      console.log('ðŸ¤– Model preference saved:', selectedModel);
    }
    
    function loadModelPreference() {
      const savedModel = localStorage.getItem('AI_MODEL_PREFERENCE') || 'mixtral-8x7b-32768';
      const modelSelect = document.getElementById('aiModelSelect');
      if (modelSelect) {
        modelSelect.value = savedModel;
      }
      return savedModel;
    }
    
    function clearApiKey() {
      if (confirm('Are you sure you want to clear the API key?')) {
        localStorage.removeItem('GROQ_API_KEY');
        window.AI_API_KEY = '';
        document.getElementById('groqApiKeyInput').value = '';
        alert('API key cleared');
        console.log('ðŸ”‘ API key cleared');
      }
    }
    
    function toggleAIDataPreview() {
      const preview = document.getElementById('aiDataPreview');
      const chevron = document.getElementById('aiDataChevron');
      if (preview.style.display === 'none') {
        preview.style.display = 'block';
        chevron.className = 'fa-solid fa-chevron-up';
        updateAIDataPreview();
      } else {
        preview.style.display = 'none';
        chevron.className = 'fa-solid fa-chevron-down';
      }
    }
    
    function updateAIDataPreview() {
      const previewContent = document.getElementById('aiDataPreviewContent');
      if (!lastBundle) {
        previewContent.textContent = 'No data available';
        return;
      }
      
      const dataPackage = prepareAIDataPackage();
      previewContent.textContent = JSON.stringify(dataPackage, null, 2);
    }
    
    function prepareAIDataPackage() {
      if (!lastBundle) return null;
      
      const setup = lastBundle.setup || {};
      const explore = lastBundle.explore || {};
      const assumptions = lastBundle.assumptions || {};
      const results = lastBundle.results || {};
      const effects = lastBundle.effects || {};
      const power = lastBundle.power || {};
      const omnibus = results.omnibus || {};
      
      // COMPREHENSIVE LOGGING for debugging
      console.log('ðŸ“¦ Full lastBundle structure:', lastBundle);
      console.log('ðŸ“‹ Bundle keys:', Object.keys(lastBundle));
      console.log('ðŸ”¬ Results keys:', Object.keys(results));
      console.log('ðŸ§ª Looking for pairwise data in:', {
        'results.pairwise': results.pairwise,
        'results.pairwiseComparisons': results.pairwiseComparisons,
        'lastBundle.pairwise': lastBundle.pairwise,
        'lastBundle.posthoc': lastBundle.posthoc,
        'lastBundle.pairwiseResults': lastBundle.pairwiseResults
      });
      
      // Extract descriptives with direction hint
      const descriptiveStats = (setup.selectedColumns || []).map((col, idx) => {
        const colStat = (explore.selectedColumnStats || [])[idx] || {};
        return {
          level: col,
          n: colStat.n,
          mean: colStat.mean,
          sd: colStat.sd
        };
      });
      
      // Determine direction hint
      let directionHint = "varied";
      if (descriptiveStats.length >= 2) {
        const means = descriptiveStats.map(d => d.mean);
        const increasing = means.every((m, i) => i === 0 || m >= means[i-1]);
        const decreasing = means.every((m, i) => i === 0 || m <= means[i-1]);
        if (increasing) directionHint = "increasing";
        else if (decreasing) directionHint = "decreasing";
        else if (means.length >= 3) {
          const maxIdx = means.indexOf(Math.max(...means));
          if (maxIdx > 0 && maxIdx < means.length - 1) {
            directionHint = "increase_then_decline";
          }
        }
      }
      
      const descriptives = {
        by_level: descriptiveStats,
        direction_hint: directionHint
      };
      
      // Design info with missing data handling
      const design = {
        type: "within_subjects",
        factor: { 
          name: setup.groupColumn || "Time", 
          levels: setup.selectedColumns || []
        },
        n_subjects: omnibus.n || descriptives.by_level[0]?.n || 0,
        missing: {
          exists: false,
          handling: "listwise_deletion",
          complete_cases_n: omnibus.n || descriptives.by_level[0]?.n || 0,
          excluded_subjects_n: 0,
          notes: ""
        }
      };
      
      // Assumptions with notes
      const assumptionsData = {
        sphericity: {
          test: "Mauchly",
          W: omnibus.mauchlyW,
          p: omnibus.mauchlyP,
          violated: omnibus.mauchlyP < 0.05,
          epsilons: {
            GG: omnibus.ggEpsilon,
            HF: omnibus.hfEpsilon
          },
          correction_applied: omnibus.mauchlyP < 0.05 ? "GG or HF recommended" : "none"
        },
        notes_for_user: [
          "If sphericity is violated, report GG/HF-corrected results.",
          "If missing data exists, consider a mixed model."
        ]
      };
      
      // Primary test with sphericity reporting
      const primaryTest = {
        name: "RM-ANOVA",
        statistic: {
          type: "F",
          df1: omnibus.anovaDf1,
          df2: omnibus.anovaDf2,
          value: omnibus.anovaF,
          p: omnibus.anovaP
        },
        sphericity_reporting: {
          reported_as: omnibus.mauchlyP < 0.05 ? "corrected" : "uncorrected",
          gg_corrected: omnibus.mauchlyP < 0.05 ? omnibus.anovaFGG : null,
          hf_corrected: omnibus.mauchlyP < 0.05 ? omnibus.anovaFHF : null
        }
      };
      
      // Robust alternative
      const robustTest = {
        included: true,
        test: {
          name: "Friedman",
          statistic: {
            type: "chi_square",
            df: omnibus.anovaDf1,
            value: omnibus.friedmanChiSquare || omnibus.kwH,
            p: omnibus.kwP || omnibus.friedmanP
          }
        },
        effect_size: {
          name: "Kendalls_W",
          value: omnibus.kendallW
        }
      };
      
      // Effect sizes with interpretation hints
      const effectSizes = {
        primary: [
          { name: "partial_eta2", value: omnibus.partialEtaSquared },
          { name: "cohens_f", value: omnibus.cohenF }
        ],
        interpretation_hints: {
          partial_eta2: { small: 0.01, medium: 0.06, large: 0.14 },
          cohens_f: { small: 0.10, medium: 0.25, large: 0.40 },
          kendalls_W: { small: 0.10, medium: 0.30, large: 0.50 }
        }
      };
      
      // Post-hoc with detailed rows
      // CORRECTED: Post-hoc data is at results.posthoc, not results.pairwise
      const posthocBundle = results.posthoc || results.postHoc || {};
      const pairwiseData = posthocBundle.rows || posthocBundle.pairwise || 
                          results.pairwise || lastBundle.pairwise || [];
      
      console.log('ðŸ” Post-hoc data check:', {
        'results.posthoc': results.posthoc,
        'posthocBundle.enabled': posthocBundle.enabled,
        'pairwiseData.length': pairwiseData.length,
        'first_comparison_raw': pairwiseData[0],
        'all_field_names': pairwiseData[0] ? Object.keys(pairwiseData[0]) : []
      });
      
      const posthocData = {
        enabled: posthocBundle.enabled !== false && pairwiseData.length > 0,
        family: "paired",
        method: posthocBundle.method || "paired_t_tests",
        p_adjust: posthocBundle.correction || "Holm",
        rows: pairwiseData.slice(0, 6).map(pw => {
          // Map actual field names to schema format
          const rawP = pw.rawP || pw.pRaw || pw.p_raw || pw.pValue || 0;
          const adjP = pw.adjP || pw.p || pw.p_adj || pw.pAdjusted || rawP;
          
          return {
            comparison: pw.comparison || `${pw.group1 || pw.groupA || 'A'} vs ${pw.group2 || pw.groupB || 'B'}`,
            estimate: { 
              type: "mean_difference", 
              value: pw.estimate || pw.meanDiff || pw.diff || 0
            },
            ci95: { 
              low: pw.ciLow || pw.ci_lower || pw.lower || 0, 
              high: pw.ciHigh || pw.ci_upper || pw.upper || 0
            },
            statistic: { 
              type: "t", 
              df: pw.df || 0, 
              value: pw.statistic || pw.tStat || pw.t || 0
            },
            raw_p: rawP,
            adj_p: adjP,
            effect_size: { 
              name: "dz", 
              value: pw.cohenDz || pw.dz || pw.effectSize || 0
            },
            significant: adjP < 0.05
          };
        }),
        display_rules: {
          nonparametric_note: "If posthoc method is Wilcoxon/Conover/Nemenyi, do not report mean-difference CI unless Hodgesâ€“Lehmann CI is provided."
        },
        note: pairwiseData.length === 0 ? 
          "Post-hoc comparisons can be performed using the Pairwise tab in the results dialog." : 
          `${pairwiseData.filter(p => (p.p || p.p_adj || 1) < 0.05).length} of ${pairwiseData.length} comparisons significant after ${pairwiseData[0]?.adjustment || 'Holm'} correction.`
      };
      
      // Power with cautions
      const powerData = {
        type: "prospective_and_observed",
        observed: {
          reported: powerAnalysisData?.observed_power != null,
          power: powerAnalysisData?.observed_power,
          alpha: 0.05,
          effect_size_source: "observed"
        },
        planning: {
          target_power_80: powerAnalysisData?.required_n_80,
          target_power_85: powerAnalysisData?.required_n_85,
          target_power_90: powerAnalysisData?.required_n_90,
          assumptions: { 
            alpha: 0.05, 
            effect_size_basis: "cohens_f" 
          }
        },
        cautions: [
          "Observed power is descriptive; planning power is recommended for study design.",
          "If effect size is estimated from the same dataset, required_n may be optimistic."
        ]
      };
      
      return {
        schema_version: "statistico.ai.unified_narrative.v1",
        analysis: {
          id: "RM-" + new Date().toISOString().split('T')[0],
          module: "RepeatedMeasures_3plus",
          locale: "en",
          reporting: {
            style: "APA",
            alpha: 0.05,
            decimals: globalDecimalPrecision === "auto" ? 2 : parseInt(globalDecimalPrecision, 10),
            tone: "professional",
            length_words_max: 350
          }
        },
        design,
        descriptives,
        assumptions: assumptionsData,
        model_and_results: {
          primary_framework: "parametric",
          primary_test: primaryTest,
          robust_or_alternative: robustTest,
          omnibus_conclusion: {
            significant: primaryTest.statistic.p < 0.05,
            plain_language: primaryTest.statistic.p < 0.05 ? 
              "At least one timepoint differs significantly." : 
              "No significant differences were detected among timepoints."
          }
        },
        posthoc: posthocData,
        effect_sizes: effectSizes,
        power: powerData
      };
    }
    
    async function generateAIInterpretation() {
      const content = document.getElementById('aiInterpretationContent');
      const spinner = document.getElementById('aiInterpretationSpinner');
      const icon = document.getElementById('aiGenIcon');
      
      // Show spinner
      content.style.display = 'none';
      spinner.style.display = 'block';
      if (icon) icon.classList.add('fa-spin');
      
      try {
        const dataPackage = prepareAIDataPackage();
        
        if (!dataPackage) {
          throw new Error('No analysis data available. Please run an analysis first.');
        }
        
        // Check for API key
        if (!window.AI_API_KEY || window.AI_API_KEY === '') {
          throw new Error('Please configure your Groq API key using the configuration panel above.');
        }
        
        // Get selected model
        const selectedModel = document.getElementById('aiModelSelect')?.value || 'mixtral-8x7b-32768';
        console.log('ðŸ¤– Using model:', selectedModel);
        
        // Map model identifiers to Groq API model names
        const modelMapping = {
          'mixtral-8x7b-32768': 'mixtral-8x7b-32768',
          'gpt-oss-20b': 'openai/gpt-oss-20b'  // Groq's actual model name format
        };
        const apiModelName = modelMapping[selectedModel] || selectedModel;
        
        // Call Groq API
        const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${window.AI_API_KEY}`
          },
          body: JSON.stringify({
            model: apiModelName,
            messages: [
              {
                role: 'system',
                content: `You are a statistical consultant writing professional APA-style interpretations for academic publications.

FORMATTING RULES:
- Write in clear paragraphs, NOT bullet points or sections with ** markers
- Use proper paragraph breaks (double line breaks) between major sections
- Integrate all components into a flowing narrative
- DO NOT use markdown formatting (no **, no headers, no bullets)
- Write as a single cohesive text suitable for a Results section

STRUCTURE (integrate naturally, don't use section headers):
1. Design & Sample: Briefly describe the repeated measures design, sample size, and timepoints
2. Assumptions: State sphericity test result and any corrections applied
3. Omnibus Test: Report primary RM-ANOVA with F-statistic, df, p-value, and nonparametric confirmation
4. Effect Size: Interpret the practical significance using partial Î·Â² or Cohen's f with benchmarks
5. Post-hoc: Check posthoc.enabled and posthoc.rows carefully:
   - If enabled=false OR rows is empty: Say "Further pairwise comparisons using paired t-tests with [p_adjust] correction could explore specific differences between timepoints"
   - If enabled=true AND rows exist: Count how many have significant=true, then report ONLY those significant comparisons with their statistics
   - For each significant comparison, report: comparison name, adjusted p-value (adj_p), mean difference (estimate.value), 95% CI, and effect size
   - IMPORTANT: Use adj_p field for significance, NOT raw_p
   - If no rows have significant=true, say "Pairwise comparisons were conducted but none reached significance after [p_adjust] correction"
6. Power: State observed power and sample size recommendation for future studies with cautions
7. Conclusion: One clear sentence summarizing the finding

STATISTICAL REPORTING:
- Use proper formatting: F(df1, df2) = value, p = .xxx or p < .001
- For p < .001, write "p < .001" not "p = .0001"
- Report exact df values
- Include effect sizes with interpretation using provided benchmarks (e.g., "partial Î·Â² = 0.86, a large effect exceeding the .14 benchmark")
- Be precise with numbers but explain their meaning
- If post-hoc rows are empty, do NOT say tests were performed - instead say they "were not conducted" or "could be explored"

TONE: Professional, precise, but accessible to researchers in applied fields.`
              },
              {
                role: 'user',
                content: `Generate a comprehensive APA-style interpretation for this repeated measures analysis. Write it as a flowing narrative suitable for a Results section in an academic paper. Do not use markdown formatting or section headers - integrate everything naturally:\n\n${JSON.stringify(dataPackage, null, 2)}`
              }
            ],
            temperature: 0.6,
            max_tokens: 1000
          })
        });
        
        console.log('ðŸŒ API Response Status:', response.status, response.statusText);
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({ error: { message: `HTTP ${response.status}` } }));
          console.error('âŒ API Error Response:', errorData);
          throw new Error(errorData.error?.message || `API returned ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();
        let interpretation = result.choices[0]?.message?.content || 'No interpretation generated';
        
        // Clean up any remaining markdown artifacts
        interpretation = interpretation
          .replace(/\*\*([^*]+)\*\*/g, '$1')  // Remove bold markers
          .replace(/^\s*#+\s+/gm, '')          // Remove headers
          .replace(/^\s*[-*]\s+/gm, '')        // Remove bullet points
          .trim();
        
        // Display the interpretation
        content.innerHTML = `
          <div style="background:#1e1b4b;padding:20px;border-radius:6px;border-left:4px solid #7c3aed;">
            <div style="font-size:12px;color:#a78bfa;margin-bottom:12px;font-weight:600;display:flex;align-items:center;gap:6px;">
              <i class="fa-solid fa-sparkles"></i> AI-Generated Interpretation (${selectedModel === 'gpt-oss-20b' ? 'GPT OSS 20B' : 'Mixtral-8x7b'})
            </div>
            <div style="line-height:1.8;color:#e5e7eb;white-space:pre-wrap;font-size:13.5px;">${interpretation}</div>
          </div>
          <div style="margin-top:12px;padding:10px 12px;background:rgba(124,58,237,0.12);border:1px solid rgba(124,58,237,0.3);border-radius:4px;font-size:11px;color:#c4b5fd;line-height:1.5;">
            <i class="fa-solid fa-info-circle"></i> This interpretation was generated using AI (${selectedModel === 'gpt-oss-20b' ? 'GPT OSS 20B' : 'Mixtral-8x7b'}) and should be reviewed by a qualified researcher before publication. Verify all statistical values against your raw results.
          </div>
        `;
        
      } catch (error) {
        console.error('AI interpretation error:', error);
        content.innerHTML = `
          <div style="background:#7f1d1d;padding:15px;border-radius:6px;border-left:4px solid #dc2626;">
            <div style="font-size:12px;color:#fca5a5;margin-bottom:8px;font-weight:600;">
              <i class="fa-solid fa-triangle-exclamation"></i> Error Generating Interpretation
            </div>
            <div style="color:#fecaca;">${error.message}</div>
          </div>
        `;
      } finally {
        // Hide spinner
        content.style.display = 'block';
        spinner.style.display = 'none';
        if (icon) icon.classList.remove('fa-spin');
      }
    }
    
    // === Complete Listwise Data Modal Functions ===
    function openListwiseDataModal() {
      if (!window.dependentRangeData || !lastBundle?.setup?.selectedColumns) {
        alert("No data available. Please run the analysis first.");
        return;
      }
      
      const modal = document.getElementById('listwiseDataModal');
      populateListwiseDataTable();
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
    }
    
    function closeListwiseDataModal() {
      const modal = document.getElementById('listwiseDataModal');
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
    }
    
    function populateListwiseDataTable() {
      const headers = window.dependentRangeData[0] || [];
      const dataRows = window.dependentRangeData.slice(1);
      const selectedCols = lastBundle.setup.selectedColumns;
      
      // Build table header
      const thead = document.getElementById('listwiseTableHeader');
      thead.innerHTML = '<th>#</th>';
      selectedCols.forEach(col => {
        const th = document.createElement('th');
        th.textContent = col;
        thead.appendChild(th);
      });
      
      // Get column indices
      const colIndices = selectedCols.map(col => headers.indexOf(col));
      
      // Build table body
      const tbody = document.getElementById('listwiseTableBody');
      tbody.innerHTML = '';
      
      let completeCount = 0;
      let missingCount = 0;
      
      dataRows.forEach((row, idx) => {
        const values = colIndices.map(colIdx => parseFloat(row[colIdx]));
        const hasAll = values.every(v => isFinite(v));
        
        if (hasAll) {
          completeCount++;
        } else {
          missingCount++;
        }
        
        const tr = document.createElement('tr');
        if (!hasAll) {
          tr.style.opacity = '0.4';
          tr.style.textDecoration = 'line-through';
        }
        
        // Row number
        const tdNum = document.createElement('td');
        tdNum.textContent = idx + 1;
        tr.appendChild(tdNum);
        
        // Data values
        values.forEach(val => {
          const td = document.createElement('td');
          td.textContent = isFinite(val) ? val.toFixed(4) : 'â€”';
          tr.appendChild(td);
        });
        
        tbody.appendChild(tr);
      });
      
      // Update stats
      document.getElementById('listwiseN').textContent = completeCount;
      document.getElementById('listwiseVars').textContent = selectedCols.length;
      document.getElementById('listwiseMissing').textContent = missingCount;
    }
    
    function copyListwiseData() {
      if (!window.dependentRangeData || !lastBundle?.setup?.selectedColumns) {
        return;
      }
      
      const headers = window.dependentRangeData[0] || [];
      const dataRows = window.dependentRangeData.slice(1);
      const selectedCols = lastBundle.setup.selectedColumns;
      const colIndices = selectedCols.map(col => headers.indexOf(col));
      
      // Create tab-separated values
      let text = 'Row\t' + selectedCols.join('\t') + '\n';
      
      dataRows.forEach((row, idx) => {
        const values = colIndices.map(colIdx => {
          const val = parseFloat(row[colIdx]);
          return isFinite(val) ? val.toFixed(4) : '';
        });
        text += `${idx + 1}\t${values.join('\t')}\n`;
      });
      
      // Copy to clipboard
      navigator.clipboard.writeText(text).then(() => {
        const btn = event.currentTarget;
        const originalHTML = btn.innerHTML;
        
        // Show success feedback
        btn.innerHTML = '<i class="fa-solid fa-check"></i> Copied!';
        btn.style.background = 'rgba(76,175,80,0.3)';
        btn.style.borderColor = '#4caf50';
        btn.style.color = '#4caf50';
        
        setTimeout(() => {
          btn.innerHTML = originalHTML;
          btn.style.background = '';
          btn.style.borderColor = '';
          btn.style.color = '';
        }, 1500);
      }).catch(err => {
        console.error('Failed to copy:', err);
        alert('Failed to copy data to clipboard');
      });
    }
    
  </script>
  
  <!-- Scatter Plot Modal -->
  <div id="corrScatterModal" class="scatter-modal" role="dialog" aria-hidden="true">
    <div class="scatter-modal-content">
      <div class="scatter-modal-header">
        <span id="scatterTitle">Scatter Plot</span>
        <span class="scatter-close" onclick="closeCorrScatterModal()">&times;</span>
      </div>
      <div class="scatter-modal-body">
        <div class="scatter-stats">
          <div class="scatter-stat">
            <div class="scatter-stat-value" id="scatterN">--</div>
            <div class="scatter-stat-label">N</div>
          </div>
          <div class="scatter-stat">
            <div class="scatter-stat-value" id="scatterR">--</div>
            <div class="scatter-stat-label">R</div>
          </div>
          <div class="scatter-stat">
            <div class="scatter-stat-value" id="scatterP">--</div>
            <div class="scatter-stat-label">p-value</div>
          </div>
          <div class="scatter-stat">
            <div class="scatter-stat-value" id="scatterR2">--</div>
            <div class="scatter-stat-label">RÂ²</div>
          </div>
        </div>
        <div id="scatterChart" class="scatter-chart"></div>
        <div class="scatter-controls">
          <div class="scatter-panel">
            <div class="scatter-panel-title"><i class="fa-solid fa-chart-line"></i> Curve Fitting</div>
            <div class="scatter-buttons">
              <button class="scatter-btn active" id="fit-none" onclick="applyScatterFit('none')">None</button>
              <button class="scatter-btn" id="fit-linear" onclick="applyScatterFit('linear')">Linear</button>
              <button class="scatter-btn" id="fit-polynomial" onclick="applyScatterFit('polynomial')">Poly</button>
              <button class="scatter-btn" id="fit-exponential" onclick="applyScatterFit('exponential')">Exp</button>
              <button class="scatter-btn" id="fit-logarithmic" onclick="applyScatterFit('logarithmic')">Log</button>
              <button class="scatter-btn" id="fit-power" onclick="applyScatterFit('power')">Power</button>
            </div>
            <div class="fit-equation" id="fitEquation">Equation: â€”</div>
          </div>
          <div class="scatter-panel">
            <div class="scatter-panel-title"><i class="fa-solid fa-arrows-alt"></i> Axis Transform</div>
            <div class="scatter-axis-toggle">
              <button class="scatter-btn active" id="transform-x-tab" onclick="setScatterTransformAxis('x')">X</button>
              <button class="scatter-btn" id="transform-y-tab" onclick="setScatterTransformAxis('y')">Y</button>
            </div>
            <div class="scatter-buttons">
              <button class="scatter-btn active" id="transform-none" onclick="applyScatterTransformation('none')">None</button>
              <button class="scatter-btn" id="transform-ln" onclick="applyScatterTransformation('ln')">ln</button>
              <button class="scatter-btn" id="transform-inverse" onclick="applyScatterTransformation('inverse')">1/x</button>
              <button class="scatter-btn" id="transform-sqrt" onclick="applyScatterTransformation('sqrt')">âˆš</button>
              <button class="scatter-btn" id="transform-square" onclick="applyScatterTransformation('square')">xÂ²</button>
            </div>
          </div>
        </div>
        
        <!-- Listwise Data Section -->
        <div class="scatter-data-section">
          <div class="scatter-data-header" onclick="toggleScatterData()">
            <span><i class="fa-solid fa-chevron-right" id="scatterDataToggle"></i> <strong>Listwise Data</strong> <span id="scatterDataCount">(n=0)</span></span>
            <button class="scatter-copy-btn" onclick="copyScatterData(event)" title="Copy to clipboard">
              <i class="fa-solid fa-copy"></i> Copy
            </button>
          </div>
          <div id="scatterDataContent" class="scatter-data-content" style="display:none;">
            <div id="scatterDataExcluded" class="scatter-data-excluded" style="display:none;">
              <i class="fa-solid fa-info-circle"></i> <span id="scatterExcludedText"></span>
            </div>
            <div class="scatter-data-table-container">
              <table id="scatterDataTable" class="scatter-data-table">
                <thead>
                  <tr>
                    <th>#</th>
                    <th id="scatterDataColX">X</th>
                    <th id="scatterDataColY">Y</th>
                  </tr>
                </thead>
                <tbody id="scatterDataTableBody">
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Listwise Data Modal -->
  <div id="listwiseDataModal" class="scatter-modal" role="dialog" aria-hidden="true">
    <div class="scatter-modal-content" style="max-width: 95%; width: 1200px;">
      <div class="scatter-modal-header">
        <span><i class="fa-solid fa-table"></i> Listwise Data - All Timepoints</span>
        <span class="scatter-close" onclick="closeListwiseDataModal()">&times;</span>
      </div>
      <div class="scatter-modal-body">
        <div class="scatter-stats" style="grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));">
          <div class="scatter-stat">
            <div class="scatter-stat-value" id="listwiseN">--</div>
            <div class="scatter-stat-label">Complete Cases</div>
          </div>
          <div class="scatter-stat">
            <div class="scatter-stat-value" id="listwiseVars">--</div>
            <div class="scatter-stat-label">Timepoints</div>
          </div>
          <div class="scatter-stat">
            <div class="scatter-stat-value" id="listwiseMissing">--</div>
            <div class="scatter-stat-label">Excluded (Missing)</div>
          </div>
          <div class="scatter-stat" style="justify-self: end;">
            <button class="scatter-copy-btn" onclick="copyListwiseData()" style="margin: 0; padding: 6px 12px; font-size: 10px;">
              <i class="fa-solid fa-copy"></i> Copy All Data
            </button>
          </div>
        </div>
        <div class="scatter-data-table-container" style="max-height: 60vh;">
          <table id="listwiseDataTable" class="scatter-data-table">
            <thead>
              <tr id="listwiseTableHeader">
                <th>#</th>
              </tr>
            </thead>
            <tbody id="listwiseTableBody">
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
  
</body>
</html>
