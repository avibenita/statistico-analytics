<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Dependent (Repeated Measures) Results (3+ Timepoints)</title>
  <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <script src="https://code.highcharts.com/highcharts.js"></script>
  <script src="https://code.highcharts.com/highcharts-more.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" rel="stylesheet"/>
  <script>
    // AI API Key configuration (Groq)
    window.AI_API_KEY = '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';
    console.log('üîë AI API Key set:', window.AI_API_KEY && window.AI_API_KEY !== 'YOUR_API_KEY_PLACEHOLDER' ? 'YES (***' + window.AI_API_KEY.slice(-4) + ')' : 'NO - Key not configured');
  </script>
  <style>
    :root{--surface-0:#0c1624;--surface-1:#1a1f2e;--surface-2:#242938;--border:#2d3748;--accent-1:rgb(255,165,120);--accent-2:rgb(120,200,255);--text-primary:#fff;--text-secondary:rgba(255,255,255,.82);--text-muted:rgba(255,255,255,.62);--panel-radius:8px;--panel-shadow:0 2px 10px rgba(0,0,0,.3);}
    html,body{height:100%;margin:0;background:var(--surface-0);color:var(--text-primary);font-family:Segoe UI,Tahoma,sans-serif;}
    .wrap{display:flex;justify-content:center;padding:4px 8px 12px;}
    .card{min-height:680px;border-radius:var(--panel-radius);box-shadow:var(--panel-shadow);border:1px solid var(--border);display:flex;flex-direction:column;}
    .hero-section{background:linear-gradient(180deg,#0a1118,#0c1620);border-bottom:1px solid rgba(255,255,255,.06);padding:10px 14px;border-radius:var(--panel-radius) var(--panel-radius) 0 0;}
    .hero-content{display:flex;justify-content:space-between;align-items:center;gap:8px;}
    .hero-title{display:flex;align-items:center;font-size:1.1rem;font-weight:800;letter-spacing:.3px;text-transform:uppercase;}
    .hero-controls{display:flex;align-items:center;gap:8px;}
    .hero-action-btn{border-radius:6px;border:1px solid rgba(148,163,184,.45);background:linear-gradient(145deg,rgba(148,163,184,.18),rgba(100,116,139,.16));color:#fff;padding:6px 12px;font-size:11px;font-weight:650;cursor:pointer;display:flex;align-items:center;gap:6px;position:relative;}
    .hero-action-btn:hover::after{content:attr(title);position:absolute;bottom:100%;left:50%;transform:translateX(-50%);margin-bottom:6px;padding:6px 10px;background:#283593;color:#fff;font-size:10px;font-weight:600;white-space:nowrap;border-radius:6px;box-shadow:0 3px 10px rgba(0,0,0,0.3);z-index:1000;pointer-events:none;}
    .hero-action-btn:hover::before{content:'';position:absolute;bottom:100%;left:50%;transform:translateX(-50%);margin-bottom:1px;border:5px solid transparent;border-top-color:#283593;z-index:1000;pointer-events:none;}
    .tab-navigation{display:flex;align-items:flex-end;gap:12px;background:transparent;padding:8px 0 0;border-bottom:1px solid rgba(255,255,255,.08);overflow-x:auto;scrollbar-width:none;margin-top:6px;}
    .tab-button{height:30px;padding:0 3px;background:transparent;border:none;color:rgba(255,255,255,.55);font-size:11px;font-weight:600;cursor:pointer;display:flex;align-items:center;gap:5px;position:relative;}
    .tab-button.active{color:#fff;font-weight:700;}
    .tab-button.active::before{content:'';position:absolute;left:0;right:0;bottom:-7px;height:2px;background:linear-gradient(90deg,var(--accent-1),var(--accent-2));}
    .tab-controls-right{margin-left:auto;display:inline-flex;align-items:center;gap:6px;padding-bottom:6px;}
    .tab-decimal-select{height:30px;padding:0 8px;border-radius:6px;border:1px solid rgba(148,163,184,.45);background:rgba(15,23,42,.82);color:#fff;font-size:11px;}
    .view-container{padding:10px 12px;}
    .tab-panel{display:none;} .tab-panel.active{display:block;}
    .stats-container{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:10px;}
    .stat-panel{background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:8px;overflow:hidden;}
    .stat-panel.secondary{opacity:0.7;transform:scale(0.95);border-color:rgba(45,55,72,0.4);}
    .stat-panel.secondary .stat-panel-heading{background:#37474f;font-size:10px;padding:6px 8px;border-bottom:1px solid rgba(255,165,120,.4);}
    .stat-panel.secondary .stat-field{padding:5px 0;}
    .stat-panel.secondary .stat-label{font-size:12px;opacity:0.85;}
    .stat-panel.secondary .stat-value{font-size:12px;padding:4px 6px;min-width:90px;opacity:0.9;}
    .stat-panel-heading{padding:7px 10px;background:#164e8d;color:#fff;font-weight:800;text-transform:uppercase;letter-spacing:.5px;border-bottom:2px solid rgba(255,165,120,.7);font-size:13px;}
    .stat-panel-heading.parametric{background:#2e5f8a;border-bottom-color:#4a90e2;}
    .stat-panel-heading.nonparametric{background:#00695c;border-bottom-color:#26a69a;}
    .stat-panel-body{padding:6px 10px;}
    .stat-field{display:grid;grid-template-columns:1fr auto;align-items:center;gap:10px;padding:6px 0;border-bottom:1px solid rgba(255,255,255,.06);}
    .stat-field:last-child{border-bottom:none;}
    .stat-label{color:var(--text-secondary);font-weight:600;font-size:12px;}
    .stat-value{font-variant-numeric:tabular-nums;color:var(--accent-2);font-weight:700;background:rgba(120,200,255,.12);border:1px solid rgba(120,200,255,.32);padding:5px 8px;border-radius:6px;min-width:90px;text-align:center;font-size:12px;}
    .table-container{margin-top:8px;overflow:auto;max-height:350px;}
    .analysis-table{width:100%;border-collapse:collapse;}
    .analysis-table th{background:#164e8d;color:#fff;padding:6px;border:1px solid rgba(255,255,255,.2);font-size:11px;}
    .analysis-table td{padding:6px;border:1px solid rgba(255,255,255,.14);color:var(--text-secondary);font-size:11px;}
    .section-note{margin-top:8px;padding:7px;border-left:3px solid var(--accent-1);background:rgba(255,165,120,.1);color:var(--text-muted);font-size:11px;}
    .framework-select{height:28px;padding:0 8px;border-radius:6px;border:1px solid rgba(148,163,184,.45);background:rgba(15,23,42,.82);color:#fff;font-size:11px;}
    .agreement-good{color:#4ade80;font-weight:700;}
    .agreement-warn{color:#fbbf24;font-weight:700;}
    .settings-bar{margin-top:6px;background:linear-gradient(135deg, #e8eaf6 0%, #c5cae9 100%);border:2px solid #5c6bc0;border-radius:0;padding:6px 8px;box-shadow:0 2px 6px rgba(92,107,192,0.15);}
    .settings-panel-title{font-size:10px;font-weight:800;text-transform:uppercase;letter-spacing:1px;color:#283593;margin-bottom:6px;padding-bottom:3px;border-bottom:2px solid #5c6bc0;}
    .settings-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:5px;}
    .settings-grid>div{display:flex;flex-direction:column;}
    .settings-grid label{font-size:10px;color:#37474f;margin-bottom:2px;font-weight:700;text-transform:uppercase;}
    .settings-grid select,.settings-grid input{width:100%;height:28px;border-radius:0;border:2px solid #5c6bc0;background:#ffffff;color:#263238;padding:0 6px;font-weight:600;font-size:11px;}
    .posthoc-radio{display:flex;align-items:center;gap:6px;padding:4px 6px;cursor:pointer;font-size:11px;color:var(--text-secondary);font-weight:600;border-radius:4px;transition:background 0.2s;}
    .posthoc-radio:hover{background:rgba(255,255,255,0.1);}
    .posthoc-radio input[type="radio"]{margin:0;width:16px;height:16px;cursor:pointer;accent-color:#4a90e2;}
    .posthoc-radio input[type="radio"]:checked + span{color:var(--accent-2);font-weight:700;}
    #setPosthocWrap,#setCorrectionWrap{min-width:160px;max-width:200px;display:flex;flex-direction:column;align-items:flex-start;gap:3px;}
    #setPosthocWrap label,#setCorrectionWrap label{white-space:nowrap;line-height:1;margin-bottom:0;font-size:10px;}
    .inference-row{display:flex;align-items:center;justify-content:flex-start;gap:10px;flex-wrap:nowrap;min-width:max-content;}
    .inference-card{display:flex;align-items:center;gap:6px;flex-wrap:nowrap;justify-content:flex-start;padding:0;border:0;border-radius:0;background:transparent;min-width:max-content;}
    .inference-card#primaryTestWrap{flex:0 0 auto;min-width:180px;max-width:200px;}
    .inference-title{display:none;}
    
    /* NEW FRAMEWORK SELECTOR */
    .framework-selector{display:grid;grid-template-columns:1fr 1fr;gap:16px;width:100%;}
    .framework-selector input[type="radio"]{display:none;}
    .framework-option{display:flex;flex-direction:column;align-items:center;gap:6px;padding:20px 16px;background:#ffffff;border:3px solid #e0e7ff;border-radius:12px;cursor:pointer;transition:all 0.3s ease;text-align:center;}
    .framework-option:hover{border-color:#5c6bc0;transform:translateY(-2px);box-shadow:0 4px 12px rgba(92,107,192,0.15);}
    .framework-selector input[type="radio"]:checked + .framework-option{border-color:#5c6bc0;background:#f5f7ff;box-shadow:0 6px 20px rgba(92,107,192,0.25);transform:translateY(-3px);}
    .framework-selector input[type="radio"]:checked + .framework-option::before{content:'‚úì';position:absolute;top:8px;right:12px;width:24px;height:24px;background:#5c6bc0;color:#fff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:900;font-size:14px;}
    .framework-option{position:relative;}
    .framework-icon{font-size:32px;margin-bottom:4px;}
    .framework-name{font-size:15px;font-weight:700;color:#263238;text-transform:none;}
    .framework-desc{font-size:11px;color:#607d8b;font-weight:500;}
    
    /* NEW TEST METHOD SELECTOR */
    .test-selector{display:grid;grid-template-columns:1fr 1fr;gap:16px;width:100%;}
    .test-selector input[type="radio"]{display:none;}
    .test-option{display:flex;flex-direction:column;align-items:center;gap:6px;padding:20px 16px;background:#ffffff;border:3px solid #e0e7ff;border-radius:12px;cursor:pointer;transition:all 0.3s ease;text-align:center;position:relative;}
    .test-option:hover{border-color:#4a90e2;transform:translateY(-2px);box-shadow:0 4px 12px rgba(74,144,226,0.15);}
    .test-selector input[type="radio"]:checked + .test-option{border-color:#4a90e2;background:#f0f7ff;box-shadow:0 6px 20px rgba(74,144,226,0.25);transform:translateY(-3px);}
    .test-selector input[type="radio"]:checked + .test-option::before{content:'‚úì';position:absolute;top:8px;right:12px;width:24px;height:24px;background:#4a90e2;color:#fff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:900;font-size:14px;}
    .test-name{font-size:15px;font-weight:700;color:#263238;margin-top:4px;}
    .test-badge{font-size:10px;font-weight:700;color:#fff;background:#4a90e2;padding:3px 10px;border-radius:12px;text-transform:uppercase;letter-spacing:0.5px;margin-top:2px;}
    .test-option.friedman-option .test-badge{background:#26a69a;}
    .test-desc{font-size:11px;color:#607d8b;font-weight:500;margin-top:4px;}
    
    /* Legacy styles (keep for compatibility) */
    .fw-radio-group{display:flex;border:0;border-radius:0;overflow:hidden;min-width:320px;gap:5px;}
    .fw-radio-group input{display:none;}
    .fw-radio{padding:8px 14px;color:#fff;font-size:13px;font-weight:800;cursor:pointer;user-select:none;border:3px solid transparent;box-shadow:0 2px 6px rgba(0,0,0,0.1);text-transform:uppercase;letter-spacing:0.4px;opacity:0.6;flex:1;text-align:center;position:relative;}
    .fw-radio:last-of-type{border-right:3px solid transparent;}
    .fw-radio.active{opacity:1;box-shadow:0 3px 10px rgba(0,0,0,0.3);transform:translateY(-2px);transition:all 0.2s ease;border-color:currentColor;}
    .fw-radio.active::before{content:'‚úì';position:absolute;left:6px;top:50%;transform:translateY(-50%);font-size:16px;font-weight:900;}
    .fw-radio#setFrameworkParam{background:#4a90e2;color:#fff;}
    .fw-radio#setFrameworkParam.active{background:#2e5f8a;border-color:#4a90e2;}
    .fw-radio#setFrameworkNon{background:#26a69a;color:#fff;}
    .fw-radio#setFrameworkNon.active{background:#00695c;border-color:#26a69a;}
    .primary-test-wrap{display:flex;align-items:center;gap:6px;min-width:240px;}
    .test-now{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:6px;border:1px solid rgba(16,185,129,.45);background:rgba(16,185,129,.14);color:#d1fae5;font-size:11px;font-weight:800;}
    .primary-test-wrap label{font-size:10px;color:var(--text-muted);font-weight:800;text-transform:uppercase;}
    .primary-test-wrap select{height:32px;width:100%;border-radius:0;border:3px solid transparent;background:#2e5f8a;color:#ffffff;padding:0 10px;font-weight:700;font-size:13px;box-shadow:0 2px 6px rgba(0,0,0,0.15);text-align:center;text-align-last:center;}
    .primary-test-wrap select.parametric{background:#2e5f8a;border-color:#4a90e2;color:#ffffff;box-shadow:0 3px 10px rgba(46,95,138,0.4);}
    .primary-test-wrap select.nonparametric{background:#00695c;border-color:#26a69a;color:#ffffff;box-shadow:0 3px 10px rgba(0,105,92,0.4);}
    #setPrimaryTest:disabled{appearance:none;-webkit-appearance:none;-moz-appearance:none;background-image:none !important;cursor:default;padding-right:8px !important;}
    select:disabled{appearance:none;-webkit-appearance:none;-moz-appearance:none;}
    .hbox{border:1px solid rgba(148,163,184,.38);border-radius:8px;padding:6px;background:rgba(6,16,30,.55);}
    .hbox-title{font-size:10px;color:var(--text-muted);text-transform:uppercase;font-weight:700;margin-bottom:5px;}
    .hbox-row{display:flex;align-items:center;gap:8px;flex-wrap:nowrap;color:#e5eefc;}
    .h-radio{display:inline-flex;align-items:center;gap:4px;font-size:11px;color:#263238;text-transform:none !important;white-space:nowrap;font-weight:600;}
    .h-radio input{transform:scale(0.85);}
    .hdr-row{display:flex;justify-content:flex-start;align-items:center;gap:8px;flex-wrap:wrap;overflow:visible;padding-bottom:2px;}
    #compareStatsRow{flex-wrap:wrap;overflow:visible;scrollbar-width:auto;}
    .stat-chip{display:inline-flex;align-items:center;justify-content:center;gap:3px;background:#e3f2fd;border:2px solid #1976d2;border-radius:0;padding:3px 6px;font-size:10px;color:#0d47a1;font-weight:700;min-width:190px;box-sizing:border-box;}
    .test-chip{display:inline-flex;align-items:center;background:rgba(16,185,129,.16);border:1px solid rgba(16,185,129,.55);color:#d1fae5;border-radius:6px;padding:6px 10px;font-size:11px;font-weight:700;}
    .hyp-card{border:2px solid #5c6bc0;border-radius:0;padding:6px 8px;background:#ffffff;}
    .hyp-row{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;}

.hyp-main{font-size:13px;font-weight:700;color:#283593;white-space:nowrap;min-width:200px;}
.hyp-block{display:flex;align-items:center;gap:8px;white-space:nowrap;}
.hyp-h1-label{font-size:10px;color:#37474f;font-weight:800;text-transform:uppercase;letter-spacing:.2px;margin-bottom:3px;}
.hyp-options{display:flex;align-items:center;gap:10px;white-space:nowrap;}
.hyp-delta{font-weight:800;color:#93c5fd;}
.alpha-wrap{min-width:240px;max-width:300px;}
.alpha-wrap label{font-size:10px;color:#37474f;font-weight:800;text-transform:uppercase;}
#setAlpha{height:3px;opacity:.78;accent-color:#3949ab;max-width:190px;}
/* Descriptive Stats Tab Styles */
.desc-table-wrap{max-height:240px;overflow:auto;border:1px solid var(--border);border-radius:6px;background:var(--surface-2);margin-bottom:12px;}
#desc-stats-table{width:100%;min-width:820px;border-collapse:collapse;table-layout:auto;}
#desc-stats-table th,#desc-stats-table td{padding:6px 8px;border:1px solid rgba(255,255,255,.18);box-sizing:border-box;text-align:right;font-size:10px;line-height:16px;height:30px;white-space:nowrap;}
#desc-stats-table th:first-child,#desc-stats-table td:first-child{text-align:left;min-width:120px;max-width:180px;overflow:hidden;text-overflow:ellipsis;}
#desc-stats-table thead th{background:#003366cc;color:#fff;z-index:2;cursor:pointer;}
#desc-stats-table tbody tr:nth-child(even) td{background:rgba(255,255,255,.05)}
#desc-stats-table tbody tr:hover td{background:rgba(255,221,87,.18)}
#desc-stats-table tbody tr.selected td{background:rgba(255,165,120,.3)}
#histogram-container-kplus{height:280px;margin-top:0;overflow:hidden;}
.histogram-bar{fill:#74b9ff;stroke:#0984e3;stroke-width:1px;}
.histogram-bar:hover{fill:#0984e3;}
.normal-curve{fill:none;stroke:yellow;stroke-width:2px;stroke-dasharray:5,5;}
.axis text{fill:white;font-size:10px;}
.axis path,.axis line{stroke:#999;}
.grid line{stroke:#555;stroke-opacity:0.7;shape-rendering:crispEdges;}
.grid path{stroke-width:0;}
.desc-summary-stats{display:grid;grid-template-columns:1fr 1fr;gap:6px;padding:10px;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:6px;font-size:11px;}
.desc-summary-stats div{display:flex;justify-content:space-between;padding:3px 0;border-bottom:1px solid rgba(255,255,255,.08);}
.desc-summary-stats div:last-child{border-bottom:none;}
.desc-summary-stats strong{color:var(--text-secondary);}
.desc-summary-stats span{color:var(--accent-2);font-weight:700;}
.modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.7);z-index:1000;backdrop-filter:blur(3px);}
.normality-button:hover{background:linear-gradient(to right,rgb(255,160,160),rgb(255,192,192));transform:translateY(-2px);}

  </style>
</head>
<body>
  <div class="wrap">
    <section class="card">
      <div class="hero-section">
        <div class="hero-content">
          <div class="hero-title"><span>Repeated Measures Module (3+ Timepoints)</span></div>
          <div class="hero-controls">
            <button class="hero-action-btn" onclick="saveCurrentModel()" title="Save model configuration to Excel workbook">
              <i class="fa-solid fa-floppy-disk"></i> Model
            </button>
            </button>
            <button class="hero-action-btn" onclick="exportHtml()" title="Export complete report as standalone HTML file">
              <i class="fa-solid fa-floppy-disk"></i> HTML
            </button>
          </div>
        </div>
        <div class="tab-navigation">
          <button class="tab-button active" data-tab="explore"><i class="fa-solid fa-chart-column"></i> Explore</button>
          <button class="tab-button" data-tab="trajectories"><i class="fa-solid fa-chart-line"></i> Trajectories</button>
          <button class="tab-button" data-tab="assumptions"><i class="fa-solid fa-shield-halved"></i> Assumptions</button>
          <button class="tab-button" data-tab="results"><i class="fa-solid fa-square-poll-vertical"></i> Results</button>
          <button class="tab-button" data-tab="posthoc"><i class="fa-solid fa-table-cells"></i> Post-hoc</button>
          <button class="tab-button" data-tab="effects"><i class="fa-solid fa-wave-square"></i> Effects</button>
          <button class="tab-button" data-tab="power"><i class="fa-solid fa-bolt"></i> Power</button>
          <button class="tab-button" data-tab="report"><i class="fa-solid fa-file-lines"></i> Report</button>
          <div class="tab-controls-right">
            <label for="decimalSelect">Decimals:</label>
            <select id="decimalSelect" class="tab-decimal-select" onchange="setDecimalPrecision()">
              <option value="auto">Auto</option><option value="0">0</option><option value="1">1</option><option value="2" selected>2</option><option value="3">3</option><option value="4">4</option>
            </select>
          </div>
        </div>

        <div class="settings-bar">
  <div class="settings-panel-title">Test Configuration Panel (>2 Timepoints)</div>
  <div class="settings-grid">








    <!-- Comparison chips (no design message) -->
    <div style="grid-column:1/-1;">
      <div class="hdr-row" id="compareStatsRow"></div>
    </div>

    <!-- Inference + Test method (centered, clearly separated) -->
    <div style="grid-column:1/-1;">
      <div style="display:flex;flex-direction:column;gap:20px;align-items:center;padding:16px 0;">
        
        <!-- Framework Selection (Parametric/Non-parametric) -->
        <div style="width:100%;max-width:700px;">
          <div style="text-align:center;font-size:11px;font-weight:700;color:#5c6bc0;text-transform:uppercase;letter-spacing:1px;margin-bottom:10px;">
            Statistical Framework
          </div>
          <div class="framework-selector">
            <input id="fwParametric" type="radio" name="frameworkMode" value="parametric" checked onchange="onFrameworkChange()"/>
            <label for="fwParametric" class="framework-option parametric-option">
              <span class="framework-icon">üìä</span>
              <span class="framework-name">Parametric (Means)</span>
              <span class="framework-desc">Assumes normality</span>
            </label>
            
            <input id="fwNonparametric" type="radio" name="frameworkMode" value="nonparametric" onchange="onFrameworkChange()"/>
            <label for="fwNonparametric" class="framework-option nonparametric-option">
              <span class="framework-icon">üìà</span>
              <span class="framework-name">Non-parametric (Ranks)</span>
              <span class="framework-desc">Distribution-free</span>
            </label>
          </div>
        </div>
        
        <!-- Divider -->
        <div style="width:100%;max-width:700px;height:1px;background:linear-gradient(to right, transparent, rgba(92,107,192,0.3), transparent);"></div>
        
        <!-- Test Method Selection -->
        <div style="width:100%;max-width:700px;">
          <div style="text-align:center;font-size:11px;font-weight:700;color:#5c6bc0;text-transform:uppercase;letter-spacing:1px;margin-bottom:10px;">
            Test Method
          </div>
          <div class="test-selector">
            <input id="testRmAnova" type="radio" name="primaryTest" value="rm-anova" checked onchange="onTestMethodChange()"/>
            <label for="testRmAnova" class="test-option rmanova-option">
              <span class="test-name">Repeated Measures ANOVA</span>
              <span class="test-badge">Recommended</span>
              <span class="test-desc">Standard parametric test</span>
            </label>
            
            <input id="testFriedman" type="radio" name="primaryTest" value="friedman" onchange="onTestMethodChange()"/>
            <label for="testFriedman" class="test-option friedman-option">
              <span class="test-name">Friedman Test</span>
              <span class="test-badge">Rank-based</span>
              <span class="test-desc">Non-parametric alternative</span>
            </label>
          </div>
        </div>
        
      </div>
    </div>

    <!-- (Removed from original position) -->

    <!-- Hypothesis + alpha (compact, less clutter) -->
    <div id="setHypWrap" style="grid-column:1/-1;">
      <div class="hyp-card">
        <div class="hyp-row">

          <div class="hyp-block hyp-main">
            <strong>H0:</strong> <span id="h0Text">All timepoint means equal</span>
          </div>

          <div class="hyp-block">

  <div class="hyp-h1-label">Alternative (H1)</div>

  <div class="hbox-row hyp-options" id="h1Row">
    <label class="h-radio">
      <input type="radio" name="h1Orientation" value="less"/>
      Difference &lt; 0
    </label>

    <label class="h-radio">
      <input type="radio" name="h1Orientation" value="two-sided" checked/>
      Difference ‚â† 0
    </label>

    <label class="h-radio">
      <input type="radio" name="h1Orientation" value="greater"/>
      Difference &gt; 0
    </label>
  </div>

</div>



          <div class="alpha-wrap">
            <label for="setAlpha" style="font-size:10px;opacity:0.75;">
              Significance: <span id="alphaVal">0.050</span>
            </label>
            <input id="setAlpha" type="range" min="0.001" max="0.2" step="0.001" value="0.05" style="height:3px;"/>
          </div>

        </div>
      </div>
    </div>

  </div>
</div>


        
      <div class="view-container">
        <section id="tab-explore" class="tab-panel active">
          <!-- Descriptive Statistics with integrated summary info -->
          <div class="stat-panel">
            <div class="stat-panel-heading">Descriptive Statistics</div>
            <div style="padding:6px 10px;background:rgba(255,165,120,.08);border-bottom:1px solid var(--border);display:flex;flex-wrap:wrap;gap:8px;font-size:11px;align-items:center;">
              <span style="color:var(--text-secondary);"><strong>Variables:</strong> <span id="expVarCount" style="color:var(--accent-2);font-weight:700;">...</span></span>
              <span style="color:var(--text-secondary);"><strong>Total Rows:</strong> <span id="expTotalRows" style="color:var(--accent-2);font-weight:700;">...</span></span>
              <span style="color:var(--text-secondary);"><strong>Complete Cases:</strong> <span id="expTotalN" style="color:var(--accent-2);font-weight:700;">...</span></span>
              <span style="color:var(--text-secondary);"><strong>Overall xÃÑ:</strong> <span id="expOverallMean" style="color:var(--accent-2);font-weight:700;">...</span></span>
              <span style="color:var(--text-secondary);"><strong>Framework:</strong> <span id="expFramework" style="color:var(--accent-2);font-weight:700;">...</span></span>
            </div>
            <div id="missingDataWarning" style="display:none;padding:8px 10px;background:rgba(251,191,36,.12);border-left:3px solid #fbbf24;margin:0 10px 10px;font-size:11px;">
              <strong style="color:#fbbf24;"><i class="fa-solid fa-triangle-exclamation"></i> Missing Data:</strong>
              <span style="color:var(--text-secondary);"> <span id="missingCount" style="font-weight:700;">0</span> rows (<span id="missingPct">0</span>%) excluded due to incomplete timepoint data. RM-ANOVA requires <strong>complete cases</strong> (valid data at all timepoints).</span>
            </div>
            <div class="stat-panel-body">
              <div class="desc-table-wrap">
                <table id="desc-stats-table">
                  <colgroup>
                    <col style="min-width: 140px; max-width: 200px;">
                    <col style="min-width: 70px;">
                    <col style="min-width: 90px;">
                    <col style="min-width: 90px;">
                    <col style="min-width: 90px;">
                    <col style="min-width: 90px;">
                    <col style="min-width: 90px;">
                    <col style="min-width: 80px;">
                    <col style="min-width: 80px;">
                  </colgroup>
                  <thead>
                    <tr>
                      <th data-key="Variable" style="text-align:left">Variable <i class="fa fa-sort"></i></th>
                      <th data-key="N">N <i class="fa fa-sort"></i></th>
                      <th data-key="Mean">Mean <i class="fa fa-sort"></i></th>
                      <th data-key="StdDev">StdDev <i class="fa fa-sort"></i></th>
                      <th data-key="Min">Min <i class="fa fa-sort"></i></th>
                      <th data-key="Median">Median <i class="fa fa-sort"></i></th>
                      <th data-key="Max">Max <i class="fa fa-sort"></i></th>
                      <th data-key="Skew">Skew <i class="fa fa-sort"></i></th>
                      <th data-key="Kurt">Kurt <i class="fa fa-sort"></i></th>
                    </tr>
                  </thead>
                  <tbody id="desc-stats-body"></tbody>
                </table>
              </div>
              
              <div style="display:none;" id="desc-histogram-panel">
                <div style="font-weight:700;margin:16px 0 8px;color:var(--accent-1);display:flex;justify-content:space-between;align-items:center;">
                  <span>Histogram: <span id="desc-histogram-title">Select a variable</span></span>
                  <button class="normality-button" onclick="openNormalityModal()" style="background:linear-gradient(to right, rgb(255,192,192), rgb(255,160,160));color:black;border:none;border-radius:6px;padding:8px 16px;cursor:pointer;font-weight:bold;transition:all 0.3s ease;">
                    Normality Tests
                  </button>
                </div>
                <div style="margin-bottom:12px;display:flex;align-items:center;gap:12px;padding:8px 12px;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:6px;">
                  <label for="histogramBins" style="font-size:11px;color:var(--text-secondary);font-weight:700;white-space:nowrap;">Bins:</label>
                  <input type="range" id="histogramBins" min="5" max="30" value="10" step="1" style="flex:1;height:4px;opacity:0.8;accent-color:#4a90e2;cursor:pointer;">
                  <span id="histogramBinsValue" style="font-size:11px;color:var(--accent-2);font-weight:700;min-width:30px;text-align:center;">10</span>
                </div>
                <div style="display:grid;grid-template-columns:2fr 1fr;gap:16px;">
                  <div id="histogram-container-kplus" style="overflow:hidden;"></div>
                  <div>
                    <div class="desc-summary-stats" id="desc-summary-table"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </section>
        
        <!-- Trajectories Tab (Profile Plot + Correlation Matrix) -->
        <section id="tab-trajectories" class="tab-panel">
          <div class="stat-panel">
            <div class="stat-panel-heading">Trajectory Analysis</div>
            <div class="stat-panel-body" style="padding:12px;">
              
              <!-- Profile Plot (Spaghetti + Mean Line) -->
              <div style="margin-bottom:24px;">
                <div style="font-weight:700;margin-bottom:8px;color:var(--accent-1);font-size:14px;">
                  <i class="fa-solid fa-chart-line"></i> Profile Plot
                </div>
                <p style="margin:0 0 12px 0;color:var(--text-muted);font-size:11px;line-height:1.5;">
                  <strong>Purpose:</strong> Visualize individual subject trajectories (spaghetti lines) and the group mean trajectory. 
                  This reveals patterns of change, individual variability, and potential outliers.
                </p>
                <div style="padding:10px;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:6px;">
                  <svg id="profilePlot" width="100%" height="320" style="background:#1a2332;border-radius:4px;"></svg>
                  <div style="margin-top:10px;display:flex;gap:20px;font-size:11px;color:var(--text-muted);justify-content:center;">
                    <span><span style="width:24px;height:2px;background:#4fc3f7;display:inline-block;vertical-align:middle;"></span> Individual Subjects (n subjects)</span>
                    <span><span style="width:24px;height:3px;background:#ff9800;display:inline-block;vertical-align:middle;"></span> Group Mean Trajectory</span>
                  </div>
                  <div style="margin-top:10px;padding:8px;background:rgba(120,200,255,.08);border-left:3px solid var(--accent-2);border-radius:4px;font-size:11px;">
                    <strong>Interpretation:</strong>
                    <ul style="margin:6px 0 0 0;padding-left:20px;color:var(--text-secondary);">
                      <li><strong>Parallel lines:</strong> Consistent individual trajectories (low variability)</li>
                      <li><strong>Crossing lines:</strong> Individual differences in response patterns</li>
                      <li><strong>Steep slopes:</strong> Large changes across timepoints</li>
                      <li><strong>Flat lines:</strong> Minimal change over time</li>
                    </ul>
                  </div>
                </div>
              </div>
              
              <!-- Correlation Matrix -->
              <div>
                <div style="font-weight:700;margin-bottom:8px;color:var(--accent-1);font-size:14px;">
                  <i class="fa-solid fa-table"></i> Within-Subject Correlation Matrix
                </div>
                <p style="margin:0 0 12px 0;color:var(--text-muted);font-size:11px;line-height:1.5;">
                  <strong>Purpose:</strong> Assess within-subject consistency across timepoints. 
                  High correlations indicate stable individual differences; low correlations suggest high measurement variability or treatment effects.
                </p>
                <div style="padding:10px;background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:6px;">
                  <table id="correlationMatrix" style="width:100%;border-collapse:collapse;font-size:11px;">
                    <thead>
                      <tr id="corrMatrixHeader" style="background:#003366cc;">
                        <th style="padding:6px 8px;border:1px solid rgba(255,255,255,.18);color:#fff;">Pair</th>
                        <th style="padding:6px 8px;border:1px solid rgba(255,255,255,.18);color:#fff;">Pearson r</th>
                        <th style="padding:6px 8px;border:1px solid rgba(255,255,255,.18);color:#fff;">Interpretation</th>
                      </tr>
                    </thead>
                    <tbody id="corrMatrixBody"></tbody>
                  </table>
                  <div id="corrSummary" style="margin-top:12px;padding:8px 10px;background:rgba(120,200,255,.08);border-left:3px solid var(--accent-2);border-radius:4px;font-size:11px;">
                    <div style="color:var(--text-secondary);margin-bottom:6px;"><strong>Summary Statistics:</strong></div>
                    <div style="display:flex;flex-wrap:wrap;gap:12px;margin-bottom:8px;">
                      <span><strong>Avg r:</strong> <span id="corrAvgR" style="color:var(--accent-2);font-weight:700;">...</span></span>
                      <span><strong>Range:</strong> <span id="corrRange" style="color:var(--accent-2);font-weight:700;">...</span></span>
                      <span><strong>Compound Symmetry:</strong> <span id="corrCompound" style="color:var(--accent-2);font-weight:700;">...</span></span>
                    </div>
                    <div style="padding-top:8px;border-top:1px solid rgba(255,255,255,.15);">
                      <strong style="color:var(--text-secondary);">Interpretation:</strong>
                      <div style="margin-top:4px;color:var(--text-muted);font-style:italic;" id="corrInterpretation">...</div>
                    </div>
                  </div>
                  <div style="margin-top:12px;padding:8px;background:rgba(255,193,7,.08);border-left:3px solid #ffc107;border-radius:4px;font-size:11px;">
                    <strong style="color:#ffc107;"><i class="fa-solid fa-circle-info"></i> Note on Compound Symmetry:</strong>
                    <p style="margin:4px 0 0 0;color:var(--text-muted);">
                      Compound symmetry (similar correlations across all pairs) is a stronger assumption than sphericity. 
                      <strong>Good</strong> compound symmetry suggests homogeneous covariance, which increases RM-ANOVA power.
                    </p>
                  </div>
                </div>
              </div>
              
            </div>
          </div>
        </section>
        
        <section id="tab-assumptions" class="tab-panel">
          <div class="stat-panel">
            <div class="stat-panel-heading">Assumption Testing</div>
            <div class="stat-panel-body" style="padding:12px;">
              
              <!-- Design Balance Indicator -->
              <div id="designBalanceInfo" style="margin-bottom:16px;padding:8px 12px;background:rgba(120,200,255,.08);border-left:3px solid var(--accent-2);border-radius:4px;">
                <span style="font-size:12px;color:var(--text-secondary);"><strong>Design:</strong> <span id="balanceText">...</span></span>
              </div>
              
              <!-- Sphericity -->
              <div style="margin-bottom:20px;">
                <h4 style="color:var(--accent-1);margin:0 0 8px 0;font-size:13px;font-weight:700;">1. Sphericity (Mauchly's Test)</h4>
                <p style="margin:0 0 8px 0;color:var(--text-secondary);font-size:12px;line-height:1.5;">
                  <strong>Assumption:</strong> Variances of differences between all pairs of timepoints should be equal.<br/>
                  <strong>H‚ÇÄ:</strong> Sphericity assumption is met &nbsp;|&nbsp; <strong>H‚ÇÅ:</strong> Sphericity is violated
                </p>
                <div style="display:flex;align-items:center;gap:12px;margin-bottom:6px;">
                  <span style="font-size:12px;color:var(--text-muted);">Mauchly's W:</span>
                  <span class="stat-value" id="asMauchlyW" style="min-width:80px;">...</span>
                  <span style="font-size:12px;color:var(--text-muted);">p-value:</span>
                  <span class="stat-value" id="asMauchlyP" style="min-width:80px;">...</span>
                  <span id="asMauchlyVerdict" style="font-size:12px;font-weight:600;"></span>
                </div>
                <div style="margin-top:12px;padding:10px;background:#f8f9fa;border-radius:6px;">
                  <div style="font-size:12px;color:#263238;margin-bottom:4px;"><strong>Corrections (if violated):</strong></div>
                  <div style="display:flex;gap:20px;font-size:12px;">
                    <div>
                      <span style="color:#546e7a;">Greenhouse-Geisser Œµ:</span>
                      <span class="stat-value" id="asEpsilonGG" style="margin-left:6px;background:rgba(74,144,226,0.15);color:#1976d2;">...</span>
                    </div>
                    <div>
                      <span style="color:#546e7a;">Huynh-Feldt Œµ:</span>
                      <span class="stat-value" id="asEpsilonHF" style="margin-left:6px;background:rgba(74,144,226,0.15);color:#1976d2;">...</span>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Design Balance (Optional) -->
              <div style="margin-bottom:20px;">
                <h4 style="color:var(--accent-1);margin:0 0 8px 0;font-size:13px;font-weight:700;">2. Missing Data</h4>
                <p style="margin:0 0 8px 0;color:var(--text-secondary);font-size:12px;line-height:1.5;">
                  Repeated measures ANOVA uses <strong>listwise deletion</strong>. Only subjects with complete data across all timepoints are included.
                </p>
                <div style="display:flex;align-items:center;gap:12px;">
                  <span style="font-size:12px;color:var(--text-muted);">Complete cases:</span>
                  <span class="stat-value" id="asCompleteCases">...</span>
                </div>
              </div>

              <!-- Final Recommendation -->
              <div style="background:rgba(255,165,120,.08);border-left:4px solid var(--accent-1);padding:12px;border-radius:6px;">
                <h4 style="color:var(--accent-1);margin:0 0 8px 0;font-size:13px;font-weight:700;">üìã Recommendation & Conclusion</h4>
                <p id="asRecoText" style="margin:0;color:var(--text-primary);font-size:12px;line-height:1.6;font-weight:600;"></p>
              </div>

            </div>
          </div>
        </section>
        <section id="tab-results" class="tab-panel">
          <div class="stat-panel">
            <div class="stat-panel-heading" id="primaryTestHeading">Repeated Measures ANOVA</div>
            <div class="stat-panel-body" style="padding:10px;">
              <div class="table-container" style="margin:0;max-height:none;">
                <table class="analysis-table" id="primaryTestTable">
                  <thead id="primaryTestTableHead">
                    <tr><th>Source</th><th>SS</th><th>df</th><th>MS</th><th>F</th><th>p-value</th></tr>
                  </thead>
                  <tbody id="anovaSummaryBody">
                    <tr><td>Treatments</td><td id="anova-ss-between">...</td><td id="anova-df1">...</td><td id="anova-ms-between">...</td><td id="anova-f">...</td><td id="anova-p">...</td></tr>
                    <tr><td>Within groups</td><td id="anova-ss-within">...</td><td id="anova-df2">...</td><td id="anova-ms-within">...</td><td></td><td></td></tr>
                    <tr><td>Total</td><td id="anova-ss-total">...</td><td id="anova-df-total">...</td><td></td><td></td><td></td></tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="stats-container" style="margin-top:12px;">
            <div class="stat-panel">
              <div class="stat-panel-heading">
                Timepoint Visualization
                <div style="float:right;display:inline-flex;gap:12px;font-size:11px;font-weight:600;">
                  <label style="display:inline-flex;align-items:center;gap:4px;cursor:pointer;">
                    <input type="radio" name="chartMetric" value="means" checked onchange="updateGroupChart()"> Means
                  </label>
                  <label style="display:inline-flex;align-items:center;gap:4px;cursor:pointer;">
                    <input type="radio" name="chartMetric" value="variances" onchange="updateGroupChart()"> Variances
                  </label>
                </div>
              </div>
              <div class="stat-panel-body" style="padding:8px;">
                <div id="groupChartContainer" style="width:100%;height:280px;"></div>
              </div>
            </div>
            <div class="stat-panel secondary" id="robustnessPanel" style="display:none;">
              <div class="stat-panel-heading">‚ö†Ô∏è Not Applicable for Repeated Measures</div>
              <div class="stat-panel-body">
                <div style="padding:20px;text-align:center;color:var(--text-muted);font-size:12px;">
                  <p style="margin:0 0 10px 0;"><strong>Levene, Brown-Forsythe, and Welch tests</strong> are designed for <strong>independent groups</strong> and test equality of variances <em>between</em> different subjects.</p>
                  <p style="margin:0;"><strong>In repeated measures:</strong> The same subjects are measured across timepoints. Sphericity (Mauchly's test) is the relevant assumption. See the <strong>Assumptions</strong> tab.</p>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- ===== POST-HOC TAB ===== -->
        <section id="tab-posthoc" class="tab-panel">
          <div class="stat-panel">
            <div class="stat-panel-heading parametric" id="posthocHeading">
              Post-hoc Pairwise Comparisons (Paired t-tests)
              <div style="float:right;display:inline-flex;gap:8px;align-items:center;font-size:11px;font-weight:600;text-transform:none;">
                <span style="opacity:0.8;">Filter:</span>
                <label style="display:inline-flex;align-items:center;gap:4px;cursor:pointer;">
                  <input type="radio" name="posthocGrouping" value="all" checked onchange="updatePosthocDisplay()"> All pairs
                </label>
                <label style="display:inline-flex;align-items:center;gap:4px;cursor:pointer;">
                  <input type="radio" name="posthocGrouping" value="ref" onchange="updatePosthocDisplay()"> vs Reference
                </label>
                <select id="posthocRefGroup" style="height:24px;padding:0 6px;border-radius:4px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);color:#fff;font-size:11px;display:none;" onchange="updatePosthocDisplay()">
                  <option value="">Select timepoint...</option>
                </select>
              </div>
            </div>
            <div class="stat-panel-body" style="padding:8px;">
              <!-- Omnibus Warning -->
              <div id="posthocWarning" style="display:none;padding:8px 12px;margin-bottom:12px;background:rgba(251,191,36,.15);border-left:3px solid #fbbf24;border-radius:4px;">
                <span style="font-size:12px;color:#fbbf24;font-weight:600;">‚ö† Omnibus test not significant (p > Œ±). Interpret post-hoc comparisons with caution.</span>
              </div>
              
              <!-- Post-hoc Configuration Controls -->
              <div style="display:flex;gap:16px;margin-bottom:16px;padding:12px;background:rgba(255,255,255,.06);border:1px solid var(--border);border-radius:6px;">
                <!-- Post-hoc Method -->
                <div style="flex:1;min-width:200px;">
                  <label style="font-size:11px;color:var(--text-secondary);margin-bottom:6px;font-weight:700;text-transform:uppercase;display:block;">Post-hoc Method</label>
                  <div id="posthocRadioGroup" style="display:flex;flex-direction:column;gap:4px;padding:8px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.15);border-radius:4px;">
                    <!-- Will be populated dynamically based on framework -->
                  </div>
                </div>
                
                <!-- P-value Correction -->
                <div style="flex:1;min-width:180px;">
                  <label style="font-size:11px;color:var(--text-secondary);margin-bottom:6px;font-weight:700;text-transform:uppercase;display:block;">p-value Correction</label>
                  <div style="display:flex;flex-direction:column;gap:4px;padding:8px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.15);border-radius:4px;">
                    <label class="posthoc-radio">
                      <input type="radio" name="pCorrection" value="holm" checked onchange="onPosthocSettingsChange()">
                      <span>Holm</span>
                    </label>
                    <label class="posthoc-radio">
                      <input type="radio" name="pCorrection" value="bonferroni" onchange="onPosthocSettingsChange()">
                      <span>Bonferroni</span>
                    </label>
                    <label class="posthoc-radio">
                      <input type="radio" name="pCorrection" value="bh" onchange="onPosthocSettingsChange()">
                      <span>FDR (Benjamini-Hochberg)</span>
                    </label>
                    <label class="posthoc-radio">
                      <input type="radio" name="pCorrection" value="none" onchange="onPosthocSettingsChange()">
                      <span>None</span>
                    </label>
                  </div>
                </div>
              </div>
              
              <div class="table-container" style="margin:0;">
                <table class="analysis-table" id="posthocTable">
                  <thead>
                    <tr>
                      <th style="cursor:pointer;" onclick="sortPosthocTable('comparison')">Comparison ‚Üï</th>
                      <th style="cursor:pointer;" onclick="sortPosthocTable('statistic')">Statistic ‚Üï</th>
                      <th style="cursor:pointer;" onclick="sortPosthocTable('rawp')">Raw p ‚Üï</th>
                      <th style="cursor:pointer;" onclick="sortPosthocTable('adjp')">Adj p ‚Üï</th>
                      <th style="cursor:pointer;" onclick="sortPosthocTable('estimate')">Estimate ‚Üï</th>
                      <th style="cursor:pointer;" onclick="sortPosthocTable('ci')">95% CI ‚Üï</th>
                      <th style="text-align:center;">Sig</th>
                    </tr>
                  </thead>
                  <tbody id="posthocBody">
                    <tr><td colspan="7">No post-hoc comparisons available</td></tr>
                  </tbody>
                </table>
              </div>
              
              <div style="margin-top:12px;padding:8px;background:rgba(120,200,255,.08);border-radius:4px;font-size:11px;color:var(--text-secondary);">
                <strong>Note:</strong> <span id="posthocMethodNote">...</span>
              </div>
            </div>
          </div>
        </section>

        <section id="tab-effects" class="tab-panel">
          <div class="stats-container">
            <div class="stat-panel">
              <div class="stat-panel-heading parametric">Parametric Effect Sizes</div>
              <div class="stat-panel-body">
                <div class="stat-field"><span class="stat-label">Partial Œ∑¬≤ (SPSS)</span><span class="stat-value" id="efPartialEta">...</span></div>
                <div class="stat-field"><span class="stat-label">Generalized Œ∑¬≤ (JASP)</span><span class="stat-value" id="efGeneralizedEta">...</span></div>
                <div class="stat-field"><span class="stat-label">Eta squared</span><span class="stat-value" id="efEta">...</span></div>
                <div class="stat-field"><span class="stat-label">Omega squared</span><span class="stat-value" id="efOmega">...</span></div>
                <div class="stat-field"><span class="stat-label">Cohen's f</span><span class="stat-value" id="efCohenF">...</span></div>
              </div>
            </div>
            <div class="stat-panel">
              <div class="stat-panel-heading nonparametric">Non-parametric Effect Sizes</div>
              <div class="stat-panel-body">
                <div class="stat-field"><span class="stat-label">Kendall's W</span><span class="stat-value" id="efKendallW">...</span></div>
                <div class="stat-field"><span class="stat-label">Friedman œá¬≤</span><span class="stat-value" id="efFriedmanChi">...</span></div>
                <div class="stat-field"><span class="stat-label">Epsilon squared</span><span class="stat-value" id="efEpsilonSq">...</span></div>
              </div>
            </div>
          </div>
        </section>
        <section id="tab-power" class="tab-panel">
          <div class="stats-container"><div class="stat-panel"><div class="stat-panel-heading">Power & Sample Size (Python)</div><div class="stat-panel-body">
            <div class="stat-field"><span class="stat-label">Status</span><span class="stat-value" id="powNote">...</span></div>
            <div class="stat-field"><span class="stat-label">Endpoint</span><span class="stat-value" id="powEndpoint">...</span></div>
            <div class="stat-field"><span class="stat-label">Placeholder Power</span><span class="stat-value" id="powVal">...</span></div>
          </div></div></div>
          <div class="section-note">Power is designed to call a Python service endpoint with exact/simulation routines.</div>
        </section>
        <section id="tab-report" class="tab-panel">
          <div class="stat-panel">
            <div class="stat-panel-heading">Parametric vs Nonparametric Summary</div>
            <div class="stat-panel-body" style="padding:0;">
              <div class="table-container" style="margin:0;max-height:none;">
                <table class="analysis-table">
                  <thead><tr><th>Parametric</th><th>Nonparametric</th></tr></thead>
                  <tbody id="methodComparisonBodyReport">
                    <tr><td>RM-ANOVA F: ...</td><td>Friedman œá¬≤: ...</td></tr>
                    <tr><td>Means: ...</td><td>Mean ranks: ...</td></tr>
                    <tr><td>Partial Œ∑¬≤ / œâ¬≤: ... / ...</td><td>Kendall W / Œµ¬≤: ... / ...</td></tr>
                    <tr><td>Post-hoc: Paired t-tests + Holm</td><td>Post-hoc: Wilcoxon signed-rank + Holm</td></tr>
                    <tr><td>Sphericity: Mauchly test</td><td>Assumption-free (rank-based)</td></tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="stat-panel" style="margin-top:12px;">
            <div class="stat-panel-heading">APA-ready Report</div>
            <div class="stat-panel-body">
              <div id="repAnova"></div><br/><div id="repKw"></div><br/><div id="repCons"></div>
            </div>
          </div>
        </section>
      </div>
    </section>
  </div>
  
  <!-- Normality Tests Modal -->
  <div class="modal-overlay" id="normality-modal" style="display:none;">
    <div class="modal-content" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:90%;max-width:900px;max-height:90vh;background-color:var(--surface-1);border-radius:10px;box-shadow:0 4px 20px rgba(0,0,0,.4);border:1px solid var(--border);overflow-y:auto;">
      <div class="modal-header" style="background-color:var(--surface-0);padding:15px 20px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;">
        <div class="modal-title" style="color:var(--accent-1);font-size:1.2rem;font-weight:600;">
          Normality Tests - <span id="modal-variable-name">Variable</span> <span id="modal-sample-size">(n=‚Äî)</span>
        </div>
        <button class="close-btn" onclick="closeNormalityModal()" style="background:none;border:none;color:var(--text-secondary);font-size:1.5rem;cursor:pointer;padding:0;width:30px;height:30px;display:flex;align-items:center;justify-content:center;">&times;</button>
      </div>
      <div class="modal-body" style="padding:20px;">
        <div style="text-align:center;padding:10px;font-size:14px;font-weight:bold;">
          Normality testing placeholder (can be wired to Python service if needed)
        </div>
        <div style="padding:20px;background:rgba(255,165,120,.1);border-left:3px solid var(--accent-1);margin-top:10px;">
          <strong>Selected Variable:</strong> <span id="modal-variable-detail">‚Äî</span><br/>
          <strong>Sample Size:</strong> <span id="modal-n-detail">‚Äî</span><br/>
          <strong>Mean:</strong> <span id="modal-mean-detail">‚Äî</span><br/>
          <strong>StdDev:</strong> <span id="modal-sd-detail">‚Äî</span>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    let globalDecimalPrecision = "auto";
    let lastBundle = null;
    let primaryFramework = "parametric";
    let availableHeaders = [];
    let currentCompareMode = "k-plus";
    let currentHypothesis = "two-sided";
    let currentPrimaryTest = "welch";
    let persistedColumns = { groupA: "", groupB: "", valueColumn: "", groupColumn: "" };
    
    function onFrameworkChange() {
      const fwRadio = document.querySelector('input[name="frameworkMode"]:checked');
      const newFramework = fwRadio ? fwRadio.value : "parametric";
      primaryFramework = newFramework;
      
      // Update test method radio buttons based on framework
      const testRmAnova = document.getElementById("testRmAnova");
      const testFriedman = document.getElementById("testFriedman");
      
      if (newFramework === "parametric") {
        if (testRmAnova) testRmAnova.checked = true;
        currentPrimaryTest = "rm-anova";
      } else {
        if (testFriedman) testFriedman.checked = true;
        currentPrimaryTest = "friedman";
      }
      
      // Update post-hoc options
      updatePosthocOptions();
      refreshHypothesisFrames();
      
      // Trigger recalculation
      notifySettingsChanged();
    }
    
    function onTestMethodChange() {
      const testRadio = document.querySelector('input[name="primaryTest"]:checked');
      currentPrimaryTest = testRadio ? testRadio.value : "rm-anova";
      
      // Update framework based on test selection
      const fwParametric = document.getElementById("fwParametric");
      const fwNonparametric = document.getElementById("fwNonparametric");
      
      if (currentPrimaryTest === "friedman") {
        primaryFramework = "nonparametric";
        if (fwNonparametric) fwNonparametric.checked = true;
      } else {
        primaryFramework = "parametric";
        if (fwParametric) fwParametric.checked = true;
      }
      
      // Update post-hoc options
      updatePosthocOptions();
      refreshHypothesisFrames();
      
      // Trigger recalculation
      notifySettingsChanged();
    }
    
    function parseMaybeNumber(v){ if(v===undefined||v===null) return NaN; const n=Number(String(v).replace(",",".")); return isFinite(n)?n:NaN; }
    function fmt(v){ const n=parseMaybeNumber(v); if(!isFinite(n)) return v==null?"...":String(v); if(globalDecimalPrecision==="auto"){ if(Math.abs(n)<1&&n!==0) return n.toFixed(4); return n.toFixed(2);} return n.toFixed(parseInt(globalDecimalPrecision,10)); }
    function fmtP(v){ const n=parseMaybeNumber(v); if(!isFinite(n)) return v==null?"...":String(v); if(n < 0.001) return "< 0.001"; return globalDecimalPrecision === "auto" ? n.toFixed(4) : n.toFixed(Math.max(3, parseInt(globalDecimalPrecision,10))); }
    function setDecimalPrecision(){ globalDecimalPrecision=(document.getElementById("decimalSelect")||{value:"auto"}).value; if(lastBundle) populateBundle(lastBundle); }
    function setText(id,val){ const el=document.getElementById(id); if(el) el.textContent = (val!==undefined&&val!==null&&val!=="")?val:"..."; }
    let activeTab = "explore";
    function switchTab(tab){
      if (!tab || tab === activeTab) return;
      const prevBtn = document.querySelector('.tab-button[data-tab="' + activeTab + '"]');
      const nextBtn = document.querySelector('.tab-button[data-tab="' + tab + '"]');
      const prevPanel = document.getElementById("tab-" + activeTab);
      const nextPanel = document.getElementById("tab-" + tab);
      if (prevBtn) prevBtn.classList.remove("active");
      if (nextBtn) nextBtn.classList.add("active");
      if (prevPanel) prevPanel.classList.remove("active");
      if (nextPanel) nextPanel.classList.add("active");
      activeTab = tab;
    }
    function sendToHost(cmd,data){ if(Office&&Office.context&&Office.context.ui&&Office.context.ui.messageParent) Office.context.ui.messageParent(JSON.stringify({action:"HOST_EVENT",cmd:cmd,data:data||{}})); }
    function fillSelect(id, options, selected){
      const el = document.getElementById(id);
      if (!el) return;
      el.innerHTML = (options || []).map(function(v){ return '<option value="' + v + '">' + v + '</option>'; }).join("");
      if (selected !== undefined && selected !== null && String(selected) !== "") el.value = String(selected);
    }
    function currentSettingsSpec(){
      var hChecked = document.querySelector('input[name="h1Orientation"]:checked');
      var h = hChecked ? hChecked.value : "two-sided";
      currentHypothesis = h;
      var alpha = Number((document.getElementById("setAlpha") || { value: "0.05" }).value || 0.05);
      if (!isFinite(alpha) || alpha <= 0 || alpha >= 1) alpha = 0.05;
      
      // Get post-hoc method and correction from radio buttons
      var posthocMethodChecked = document.querySelector('input[name="posthocMethod"]:checked');
      var pCorrectionChecked = document.querySelector('input[name="pCorrection"]:checked');
      
      // Get test method from radio buttons
      var testMethodChecked = document.querySelector('input[name="primaryTest"]:checked');
      var primaryTest = testMethodChecked ? testMethodChecked.value : "rm-anova";
      
      return {
        compareMode: currentCompareMode,
        primaryFramework: primaryFramework,
        hypothesis: h,
        confidence: 1 - alpha,
        groupA: persistedColumns.groupA || "",
        groupB: persistedColumns.groupB || "",
        valueColumn: persistedColumns.valueColumn || "",
        groupColumn: persistedColumns.groupColumn || "",
        primaryTest: primaryTest,
        posthocMethod: posthocMethodChecked ? posthocMethodChecked.value : "paired",
        posthocCorrection: pCorrectionChecked ? pCorrectionChecked.value : "holm"
      };
    }
    function refreshHypothesisFrames(){
      var h0 = document.getElementById("h0Text");
      var h1Row = document.getElementById("h1Row");
      if (!h0 || !h1Row) return;
      h0.textContent = "All timepoint means equal";
      h1Row.innerHTML = '<span style="color:#1f2937;font-weight:800;">At least one timepoint differs.</span>';
    }
    function refreshSettingsVisibility(){
      const setDisplay = (id, show) => { const el = document.getElementById(id); if (el) el.style.display = show ? "flex" : "none"; };
      setDisplay("setPosthocWrap", true); setDisplay("setCorrectionWrap", true);
      setDisplay("setHypWrap", true);
      refreshHypothesisFrames();
    }
    function updatePosthocOptions(){
      const radioGroup = document.getElementById("posthocRadioGroup");
      if (!radioGroup) return;
      
      const isNonParam = primaryFramework === "nonparametric" || currentPrimaryTest === "friedman";
      
      // Get current selection
      const currentSelected = document.querySelector('input[name="posthocMethod"]:checked');
      const currentValue = currentSelected ? currentSelected.value : "";
      
      // Smart context-aware options based on framework
      if (!isNonParam) {
        // PARAMETRIC (RM-ANOVA): Paired t-tests
        radioGroup.innerHTML = `
          <label class="posthoc-radio">
            <input type="radio" name="posthocMethod" value="paired" ${currentValue === "paired" || !currentValue ? "checked" : ""} onchange="onPosthocSettingsChange()">
            <span>Paired t-tests (all pairs)</span>
          </label>
          <label class="posthoc-radio">
            <input type="radio" name="posthocMethod" value="paired-baseline" ${currentValue === "paired-baseline" ? "checked" : ""} onchange="onPosthocSettingsChange()">
            <span>Paired t-tests vs Baseline</span>
          </label>
          <label class="posthoc-radio">
            <input type="radio" name="posthocMethod" value="none" ${currentValue === "none" ? "checked" : ""} onchange="onPosthocSettingsChange()">
            <span>None</span>
          </label>
        `;
      } else {
        // NONPARAMETRIC (Friedman): Wilcoxon, Conover, Nemenyi
        radioGroup.innerHTML = `
          <label class="posthoc-radio">
            <input type="radio" name="posthocMethod" value="wilcoxon" ${currentValue === "wilcoxon" || (!currentValue && isNonParam) ? "checked" : ""} onchange="onPosthocSettingsChange()">
            <span>Wilcoxon Signed-Rank</span>
          </label>
          <label class="posthoc-radio">
            <input type="radio" name="posthocMethod" value="conover" ${currentValue === "conover" ? "checked" : ""} onchange="onPosthocSettingsChange()">
            <span>Conover</span>
          </label>
          <label class="posthoc-radio">
            <input type="radio" name="posthocMethod" value="nemenyi" ${currentValue === "nemenyi" ? "checked" : ""} onchange="onPosthocSettingsChange()">
            <span>Nemenyi</span>
          </label>
          <label class="posthoc-radio">
            <input type="radio" name="posthocMethod" value="none" ${currentValue === "none" ? "checked" : ""} onchange="onPosthocSettingsChange()">
            <span>None</span>
          </label>
        `;
      }
    }
    
    function onPosthocSettingsChange() {
      // When user changes post-hoc method or correction, trigger recalculation
      console.log("Post-hoc settings changed - triggering recalculation");
      const spec = currentSettingsSpec();
      
      // Save settings
      notifySettingsChanged();
      
      // Request host to recompute with new settings
      sendToHost("recomputeWithSettings", spec);
    }
    function setFrameworkButtons(mode){
      primaryFramework = mode === "nonparametric" ? "nonparametric" : "parametric";
      
      // Update framework radio buttons
      var rp = document.getElementById("fwParametric");
      var rn = document.getElementById("fwNonparametric");
      if (rp) rp.checked = primaryFramework === "parametric";
      if (rn) rn.checked = primaryFramework === "nonparametric";
      
      // Update test method radio buttons
      var testRmAnova = document.getElementById("testRmAnova");
      var testFriedman = document.getElementById("testFriedman");
      if (primaryFramework === "parametric") {
        if (testRmAnova) testRmAnova.checked = true;
        currentPrimaryTest = "rm-anova";
      } else {
        if (testFriedman) testFriedman.checked = true;
        currentPrimaryTest = "friedman";
      }
      
      // Update panel headings
      document.querySelectorAll(".stat-panel-heading").forEach(function(h){
        h.classList.remove("parametric", "nonparametric");
        h.classList.add(primaryFramework);
      });
      
      updatePosthocOptions();
      refreshHypothesisFrames();
    }
    function notifySettingsChanged(){
      const spec = currentSettingsSpec();
      refreshSettingsVisibility();
      var alphaVal = document.getElementById("alphaVal");
      if (alphaVal) alphaVal.textContent = (1 - (spec.confidence || 0.95)).toFixed(3);
      sendToHost("dependentSettingsChanged", spec);
    }
    function renderCompareStatsRow(s, e){
      var host = document.getElementById("compareStatsRow");
      var msgHost = document.getElementById("designMessageRow");
      if (!host) return;
      host.innerHTML = "";
      if (msgHost) { msgHost.textContent = ""; msgHost.style.display = "none"; }
      var ksum = e.kplusSummary || {};
      var ob = (lastBundle && lastBundle.results && lastBundle.results.omnibus) ? lastBundle.results.omnibus : {};
      
      var groupDescriptives = Array.isArray(ob.groupDescriptives) ? ob.groupDescriptives.filter(function(cs){
        return isFinite(parseMaybeNumber(cs && cs.n)) && parseMaybeNumber(cs.n) > 0;
      }).slice(0, 8) : [];
      if (groupDescriptives.length) {
        groupDescriptives.forEach(function(cs){
          var n = parseMaybeNumber(cs.n);
          var m = parseMaybeNumber(cs.mean);
          var chip = document.createElement("span");
          chip.className = "stat-chip";
          chip.textContent = (cs.name || "Variable") + " (n=" + (isFinite(n) ? Math.round(n) : "?") + ", xÃÑ=" + (isFinite(m) ? fmt(m) : "?") + ")";
          chip.style.fontSize = "11px";
          host.appendChild(chip);
        });
      } else {
        var names = Array.isArray(s.selectedColumns) ? s.selectedColumns.slice(0, 8) : [];
        names.forEach(function(nm){
          var nChip = document.createElement("span");
          nChip.className = "stat-chip";
          nChip.textContent = nm;
          nChip.style.fontSize = "11px";
          host.appendChild(nChip);
        });
        if (Array.isArray(s.selectedColumns) && s.selectedColumns.length > 8) {
          var moreChip = document.createElement("span");
          moreChip.className = "stat-chip";
          moreChip.textContent = "+" + (s.selectedColumns.length - 8) + " more";
          moreChip.style.opacity = "0.85";
          host.appendChild(moreChip);
        }
      }
      var design = s.designValidation || {};
      if (msgHost) {
        if (design.message) {
          msgHost.textContent = design.message;
          msgHost.style.display = "block";
        } else {
          msgHost.textContent = "";
          msgHost.style.display = "none";
        }
      }
    }
    function updateResultsPanels(r, fx, s, a){
      setText("resPrimaryFramework", primaryFramework === "nonparametric" ? "Nonparametric (ranks)" : "Parametric (means)");
      const alpha = isFinite(parseMaybeNumber(a)) ? parseMaybeNumber(a) : (1 - (parseMaybeNumber(s && s.confidence) || 0.95));
      if (r && r.omnibus) {
        const ob = r.omnibus;
        const paramPrimary = primaryFramework !== "nonparametric";
        if (paramPrimary) {
          setText("resPrimaryTest", "Repeated Measures ANOVA");
          setText("resPrimaryStat", "F(" + Math.round(ob.anovaDf1) + ", " + Math.round(ob.anovaDf2) + ") = " + fmt(ob.anovaF));
          setText("resPrimaryP", fmtP(ob.anovaP));
          setText("resPrimaryEstimate", "Omnibus effect across " + fmt(ob.levels ? ob.levels.length : 0) + " timepoints");
          setText("resSecondaryTest", "Friedman test");
          setText("resSecondaryStat", "œá¬≤(" + Math.round(ob.kwDf) + ") = " + fmt(ob.kwH));
          setText("resSecondaryP", fmtP(ob.kwP));
        } else {
          setText("resPrimaryTest", "Friedman test");
          setText("resPrimaryStat", "œá¬≤(" + Math.round(ob.kwDf) + ") = " + fmt(ob.kwH));
          setText("resPrimaryP", fmtP(ob.kwP));
          setText("resPrimaryEstimate", "Rank-based comparison across " + fmt(ob.levels ? ob.levels.length : 0) + " timepoints");
          setText("resSecondaryTest", "Repeated Measures ANOVA");
          setText("resSecondaryStat", "F(" + Math.round(ob.anovaDf1) + ", " + Math.round(ob.anovaDf2) + ") = " + fmt(ob.anovaF));
          setText("resSecondaryP", fmtP(ob.anovaP));
        }
        const agreeElK = document.getElementById("resAgreement");
        const aSig = parseMaybeNumber(ob.anovaP) < alpha;
        const kSig = parseMaybeNumber(ob.kwP) < alpha;
        if (aSig === kSig) {
          setText("resAgreement", "Agree at alpha");
          if (agreeElK) agreeElK.className = "stat-value agreement-good";
          setText("resHint", "Omnibus conclusions are consistent across frameworks.");
        } else {
          setText("resAgreement", "Disagree at alpha");
          if (agreeElK) agreeElK.className = "stat-value agreement-warn";
          setText("resHint", "Consider non-normality/heteroscedasticity and run post-hoc with correction.");
        }

        // ANOVA summary block
        const anovaBody = document.getElementById("anovaSummaryBody");
        const primaryTestHeading = document.getElementById("primaryTestHeading");
        const primaryTestTableHead = document.getElementById("primaryTestTableHead");
        
        console.log("üîç Populating ANOVA table with omnibus data:", ob);
        console.log("üìä ANOVA Values:", {
          SSBetween: ob.anovaSSBetween,
          SSWithin: ob.anovaSSWithin,
          SSTotal: ob.anovaSSTotal,
          df1: ob.anovaDf1,
          df2: ob.anovaDf2,
          MSBetween: ob.anovaMSBetween,
          MSWithin: ob.anovaMSWithin,
          F: ob.anovaF,
          P: ob.anovaP
        });
        
        // Update table based on framework selection
        const isNonParametric = primaryFramework === "nonparametric";
        
        if (isNonParametric) {
          // Friedman Test (Non-parametric)
          if (primaryTestHeading) primaryTestHeading.textContent = "Friedman Test (Non-parametric)";
          if (primaryTestTableHead) {
            primaryTestTableHead.innerHTML = '<tr><th>Timepoint</th><th>Mean Rank</th><th>œá¬≤</th><th>df</th><th>p-value</th><th>Kendall W</th></tr>';
          }
          if (anovaBody) {
            const meanRanks = ob.friedmanMeanRanks || ob.meanRanks || {};
            const rankKeys = Object.keys(meanRanks);
            const chiSquare = ob.friedmanChiSquare || ob.kwH;
            const df = ob.friedmanDf || ob.kwDf;
            const pValue = ob.friedmanP || ob.kwP;
            const kendallW = ob.kendallW || ob.friedmanW || 0;
            
            let rowsHtml = rankKeys.map(function(key, idx) {
              return '<tr>' 
                + '<td>' + key.replace('Timepoint', 'Time') + '</td>'
                + '<td>' + fmt(meanRanks[key]) + '</td>'
                + '<td>' + (idx === 0 ? '<strong>' + fmt(chiSquare) + '</strong>' : '') + '</td>'
                + '<td>' + (idx === 0 ? Math.round(df) : '') + '</td>'
                + '<td>' + (idx === 0 ? '<strong>' + fmtP(pValue) + '</strong>' : '') + '</td>'
                + '<td>' + (idx === 0 ? fmt(kendallW) + ' <span style="font-size:9px;color:#aaa;">(effect size)</span>' : '') + '</td>'
                + '</tr>';
            }).join('');
            
            if (rankKeys.length === 0) {
              rowsHtml = '<tr><td colspan="6" style="text-align:center;">No rank data available</td></tr>';
            }
            anovaBody.innerHTML = rowsHtml;
            console.log("‚úÖ Friedman test table populated successfully");
          }
        } else {
          // Repeated Measures ANOVA (Parametric)
          if (primaryTestHeading) primaryTestHeading.textContent = "Repeated Measures ANOVA (Parametric)";
          if (primaryTestTableHead) {
            primaryTestTableHead.innerHTML = '<tr><th>Source</th><th>SS</th><th>df</th><th>MS</th><th>F</th><th>p-value</th></tr>';
          }
          if (anovaBody) {
            const dfTime = parseMaybeNumber(ob.anovaDf1);
            const dfError = parseMaybeNumber(ob.anovaDf2);
            const dfSubjects = parseMaybeNumber(ob.anovaDfSubjects);
            const dfTotal = isFinite(dfTime) && isFinite(dfError) && isFinite(dfSubjects) ? dfTime + dfError + dfSubjects : NaN;
            
            // Proper RM-ANOVA table: Time, Subjects, Error
            anovaBody.innerHTML = ''
              + '<tr style="background:rgba(74,144,226,0.15);"><td><strong>Time (Treatment)</strong></td><td>' + fmt(ob.anovaSSTime || ob.anovaSSBetween) + '</td><td>' + (isFinite(dfTime) ? Math.round(dfTime) : '...') + '</td><td>' + fmt(ob.anovaMSTime || ob.anovaMSBetween) + '</td><td>' + fmt(ob.anovaF) + '</td><td><strong>' + fmtP(ob.anovaP) + '</strong></td></tr>'
              + '<tr style="background:rgba(255,255,255,0.03);"><td>Subjects (Between)</td><td>' + fmt(ob.anovaSSSubjects) + '</td><td>' + (isFinite(dfSubjects) ? Math.round(dfSubjects) : '...') + '</td><td>' + fmt(ob.anovaMSSubjects) + '</td><td style="color:#666;">‚Äî</td><td style="color:#666;">‚Äî</td></tr>'
              + '<tr style="background:rgba(255,255,255,0.03);"><td>Error (Time √ó Subject)</td><td>' + fmt(ob.anovaSSError || ob.anovaSSWithin) + '</td><td>' + (isFinite(dfError) ? Math.round(dfError) : '...') + '</td><td>' + fmt(ob.anovaMSError || ob.anovaMSWithin) + '</td><td style="color:#666;">‚Äî</td><td style="color:#666;">‚Äî</td></tr>'
              + '<tr style="border-top:2px solid rgba(255,165,120,0.5);font-weight:700;"><td>Total</td><td>' + fmt(ob.anovaSSTotal) + '</td><td>' + (isFinite(dfTotal) ? Math.round(dfTotal) : '...') + '</td><td style="color:#666;">‚Äî</td><td style="color:#666;">‚Äî</td><td style="color:#666;">‚Äî</td></tr>';
            console.log("‚úÖ RM-ANOVA table populated successfully with proper structure");
          }
        }
        
        if (!anovaBody) {
          console.error("‚ùå ANOVA table body not found!");
        }
        // Update group visualization chart
        updateGroupChart();

        // REMOVED: Levene/Brown-Forsythe/Welch tests - not valid for repeated measures
        // These tests are for independent groups. RM uses sphericity instead.
        // const varBody = document.getElementById("varianceTestBody");
        // const welchBody = document.getElementById("welchAnovaBody");

        const compareBodyReport = document.getElementById("methodComparisonBodyReport");
        if (compareBodyReport) {
          const explore = (lastBundle && lastBundle.explore) ? lastBundle.explore : {};
          const colStats = Array.isArray(explore.selectedColumnStats) ? explore.selectedColumnStats.filter(function(cs){
            return isFinite(parseMaybeNumber(cs && cs.n)) && parseMaybeNumber(cs.n) > 0;
          }) : [];
          const meansSummary = colStats.slice(0, 3).map(function(cs){
            return (cs.name || "Var") + "=" + fmt(cs.mean);
          }).join(" | ") || "...";
          const meanRanks = ob.meanRanks || {};
          const rankKeys = Object.keys(meanRanks || {}).slice(0, 3);
          const meanRankSummary = rankKeys.length
            ? rankKeys.map(function(k){ return k + "=" + fmt(meanRanks[k]); }).join(" | ")
            : "...";
          
          // RM-appropriate summary (not independent ANOVA terminology)
          const mauchlyP = parseMaybeNumber((ob.sphericity || {}).p);
          const sphericityNote = isFinite(mauchlyP) 
            ? (mauchlyP > 0.05 ? "Met (p=" + fmtP(mauchlyP) + ")" : "Violated (p=" + fmtP(mauchlyP) + ")")
            : "...";
          
          compareBodyReport.innerHTML = ''
            + '<tr><td>RM-ANOVA F: ' + fmt(ob.anovaF) + '</td><td>Friedman œá¬≤: ' + fmt(ob.friedmanChiSquare || ob.kwH) + '</td></tr>'
            + '<tr><td>Means: ' + meansSummary + '</td><td>Mean ranks: ' + meanRankSummary + '</td></tr>'
            + '<tr><td>Partial Œ∑¬≤ / œâ¬≤: ' + fmt(ob.partialEtaSquared) + ' / ' + fmt(ob.omegaSquared) + '</td><td>Kendall W / Œµ¬≤: ' + fmt(ob.kendallW) + ' / ' + fmt(ob.epsilonSquared) + '</td></tr>'
            + '<tr><td>Post-hoc: Paired t-tests + Holm</td><td>Post-hoc: Wilcoxon signed-rank + Holm</td></tr>'
            + '<tr><td>Sphericity: ' + sphericityNote + '</td><td>Assumption-free (rank-based)</td></tr>';
        }
      }
    }
    function updateGroupChart() {
      console.log("updateGroupChart called");
      console.log("lastBundle:", lastBundle);
      
      const container = document.getElementById('groupChartContainer');
      if (!container) {
        console.log("Container not found");
        return;
      }
      
      if (!lastBundle) {
        console.log('No lastBundle available for chart');
        container.innerHTML = '<div style="text-align:center;padding:80px 20px;color:var(--text-muted);font-size:12px;">No data available for visualization</div>';
        return;
      }
      
      // Try to get group data from multiple sources
      let groupData = [];
      
      // Source 1: explore.selectedColumnStats
      if (lastBundle.explore && Array.isArray(lastBundle.explore.selectedColumnStats)) {
        console.log("Found explore.selectedColumnStats:", lastBundle.explore.selectedColumnStats);
        groupData = lastBundle.explore.selectedColumnStats.filter(function(cs){
          return cs && isFinite(parseMaybeNumber(cs.n)) && parseMaybeNumber(cs.n) > 0;
        }).map(function(cs) {
          // Calculate variance if not provided (using stdDev or sd)
          let variance = cs.variance;
          if (!isFinite(parseMaybeNumber(variance))) {
            const sd = parseMaybeNumber(cs.stdDev || cs.sd || cs.stdev);
            if (isFinite(sd)) {
              variance = sd * sd; // variance = stdDev¬≤
            }
          }
          return {
            name: cs.name,
            mean: cs.mean,
            variance: variance,
            n: cs.n
          };
        });
      }
      
      // Source 2: If no explore data, try to build from groupDescriptives
      if (groupData.length === 0 && lastBundle.groupDescriptives && Array.isArray(lastBundle.groupDescriptives)) {
        console.log("Using groupDescriptives:", lastBundle.groupDescriptives);
        groupData = lastBundle.groupDescriptives.map(function(gd) {
          return {
            name: gd.name || gd.groupName || 'Group',
            mean: gd.mean,
            variance: gd.variance,
            n: gd.n
          };
        });
      }
      
      // Source 3: Try results.omnibus.levels with means
      if (groupData.length === 0 && lastBundle.results && lastBundle.results.omnibus) {
        console.log("Trying results.omnibus");
        const ob = lastBundle.results.omnibus;
        if (Array.isArray(ob.levels)) {
          console.log("Found levels:", ob.levels);
          groupData = ob.levels.map(function(level) {
            return {
              name: level.name || level.group || 'Group',
              mean: level.mean,
              variance: level.variance || level.var,
              n: level.n
            };
          });
        }
      }
      
      console.log("Final groupData:", groupData);
      
      if (groupData.length === 0) {
        console.log('No group data available for chart');
        container.innerHTML = '<div style="text-align:center;padding:80px 20px;color:var(--text-muted);font-size:12px;">No data available for visualization</div>';
        return;
      }
      
      const metricType = document.querySelector('input[name="chartMetric"]:checked')?.value || 'means';
      console.log("Metric type:", metricType);
      
      const categories = groupData.map(cs => cs.name || 'Group');
      console.log("Categories:", categories);
      
      const data = groupData.map(cs => {
        const val = metricType === 'means' ? parseMaybeNumber(cs.mean) : parseMaybeNumber(cs.variance);
        console.log("Group:", cs.name, "Value:", val, "Mean:", cs.mean, "Variance:", cs.variance);
        return isFinite(val) ? val : 0;
      });
      console.log("Chart data:", data);
      
      // Check if Highcharts is available
      if (typeof Highcharts === 'undefined') {
        console.error("Highcharts is not loaded!");
        container.innerHTML = '<div style="text-align:center;padding:80px 20px;color:#ff5555;font-size:12px;">Highcharts library not loaded</div>';
        return;
      }
      console.log("Highcharts version:", Highcharts.version);
      
      const chartTitle = metricType === 'means' ? 'Timepoint Means' : 'Timepoint Variances';
      const yAxisTitle = metricType === 'means' ? 'Mean' : 'Variance';
      
      console.log("About to create chart...");
      try {
        const isVariance = metricType === 'variances';
        
        // Calculate grand mean and standard errors for error bars
        let grandMean = null;
        const chartData = [];
        const errorData = [];
        
        if (metricType === 'means') {
          // Calculate grand mean (weighted by sample size if available)
          let totalWeighted = 0;
          let totalN = 0;
          groupData.forEach(function(g) {
            if (isFinite(g.mean) && isFinite(g.n)) {
              totalWeighted += g.mean * g.n;
              totalN += g.n;
            }
          });
          grandMean = totalN > 0 ? totalWeighted / totalN : null;
          
          // Prepare data with error bars (95% CI)
          groupData.forEach(function(g, idx) {
            const mean = g.mean;
            const sd = Math.sqrt(g.variance);
            const n = g.n || 1;
            const se = sd / Math.sqrt(n); // Standard error
            const ci95 = 1.96 * se; // Approximate 95% CI
            
            chartData.push({
              y: mean,
              name: g.name,
              n: n,
              sd: sd,
              se: se,
              color: null // Will be set based on significance
            });
            
            errorData.push({
              low: mean - ci95,
              high: mean + ci95
            });
          });
        } else {
          // For variance chart (no error bars)
          groupData.forEach(function(g) {
            chartData.push(g.variance);
          });
        }
        
        Highcharts.chart('groupChartContainer', {
          chart: {
            type: isVariance ? 'column' : 'column',
            backgroundColor: 'transparent',
            style: { fontFamily: 'Segoe UI, Tahoma, sans-serif' }
          },
          title: {
            text: chartTitle,
            style: { color: '#fff', fontSize: '13px', fontWeight: '700' }
          },
          xAxis: {
            categories: categories,
            labels: { style: { color: '#e5eefc', fontSize: '11px' } },
            lineColor: '#2d3748',
            tickColor: '#2d3748'
          },
          yAxis: {
            title: {
              text: yAxisTitle,
              style: { color: '#e5eefc', fontSize: '11px', fontWeight: '600' }
            },
            labels: { style: { color: '#e5eefc', fontSize: '10px' } },
            gridLineColor: '#2d3748',
            plotLines: metricType === 'means' && grandMean !== null ? [{
              value: grandMean,
              color: '#ffb74d',
              width: 2,
              dashStyle: 'Dash',
              zIndex: 5,
              label: {
                text: 'Grand Mean: ' + grandMean.toFixed(2),
                style: { color: '#ffb74d', fontSize: '10px', fontWeight: '600' }
              }
            }] : []
          },
          legend: { enabled: false },
          plotOptions: {
            column: {
              borderWidth: isVariance ? 2 : 0,
              borderColor: isVariance ? '#ffffff' : 'transparent',
              dataLabels: {
                enabled: true,
                format: '{y:.2f}',
                style: { 
                  color: '#fff', 
                  fontSize: '10px', 
                  fontWeight: '600', 
                  textOutline: 'none'
                }
              },
              colorByPoint: !isVariance, // Only use different colors for means
              colors: isVariance 
                ? ['#e57373', '#ba68c8', '#4fc3f7', '#81c784', '#ffb74d', '#f06292', '#7986cb', '#aed581']
                : ['#4a90e2', '#26a69a', '#ff9800', '#e91e63', '#9c27b0', '#3f51b5', '#00bcd4', '#4caf50'],
              opacity: isVariance ? 0.7 : 1,
              groupPadding: isVariance ? 0.15 : 0.2
            },
            errorbar: {
              color: 'rgba(255, 255, 255, 0.4)',
              whiskerLength: '60%',
              stemWidth: 1,
              whiskerWidth: 1.5,
              lineWidth: 1
            }
          },
          tooltip: {
            backgroundColor: '#1a1f2e',
            borderColor: '#2d3748',
            style: { color: '#fff', fontSize: '11px' },
            shared: metricType === 'means',
            formatter: function() {
              if (metricType === 'means' && this.points) {
                const point = this.points[0].point;
                let tooltip = '<b>' + point.name + '</b><br/>';
                tooltip += 'Mean: <b>' + point.y.toFixed(2) + '</b><br/>';
                tooltip += 'n = <b>' + point.n + '</b><br/>';
                tooltip += 'SD = <b>' + point.sd.toFixed(2) + '</b><br/>';
                tooltip += 'SE = <b>' + point.se.toFixed(3) + '</b><br/>';
                tooltip += '95% CI: [' + errorData[point.index].low.toFixed(2) + ', ' + errorData[point.index].high.toFixed(2) + ']';
                return tooltip;
              } else {
                return '<b>' + this.x + '</b><br/>' + yAxisTitle + ': <b>' + this.y.toFixed(2) + '</b>';
              }
            }
          },
          series: metricType === 'means' ? [
            {
              name: yAxisTitle,
              data: chartData,
              type: 'column'
            },
            {
              name: '95% CI',
              data: errorData,
              type: 'errorbar',
              tooltip: {
                pointFormat: '95% CI: {point.low:.2f} - {point.high:.2f}<br/>'
              }
            }
          ] : [{
            name: yAxisTitle,
            data: data,
            type: 'column'
          }],
          credits: { enabled: false }
        });
        console.log("Chart created successfully!");
      } catch (err) {
        console.error("Error creating chart:", err);
        container.innerHTML = '<div style="text-align:center;padding:80px 20px;color:#ff5555;font-size:12px;">Error creating chart: ' + err.message + '</div>';
      }
    }
    
    let posthocData = [];
    let posthocSortColumn = 'adjp';
    let posthocSortAsc = true;
    
    function renderPosthoc(posthoc, compareMode){
      const body = document.getElementById("posthocBody");
      const heading = document.getElementById("posthocHeading");
      const warningEl = document.getElementById("posthocWarning");
      const noteEl = document.getElementById("posthocMethodNote");
      const refSelect = document.getElementById("posthocRefGroup");
      const tableHeader = document.querySelector("#posthocTable thead tr");
      
      if (!body) return;
      
      // Determine if nonparametric
      const isNonParam = primaryFramework === "nonparametric";
      const posthocMethodRadio = document.querySelector('input[name="posthocMethod"]:checked');
      const currentMethod = posthocMethodRadio ? posthocMethodRadio.value : (isNonParam ? "wilcoxon" : "paired");
      
      // Update heading text and color based on framework
      if (heading) {
        heading.className = "stat-panel-heading " + (isNonParam ? "nonparametric" : "parametric");
        
        // Context-aware heading text
        if (isNonParam) {
          if (currentMethod === "wilcoxon") {
            heading.innerHTML = 'Post-hoc Pairwise Comparisons (Wilcoxon Signed-Rank)' + 
              '<div style="float:right;display:inline-flex;gap:8px;align-items:center;font-size:11px;font-weight:600;text-transform:none;">' +
              '<span style="opacity:0.8;">Filter:</span>' +
              '<label style="display:inline-flex;align-items:center;gap:4px;cursor:pointer;">' +
              '<input type="radio" name="posthocGrouping" value="all" checked onchange="updatePosthocDisplay()"> All pairs' +
              '</label>' +
              '<label style="display:inline-flex;align-items:center;gap:4px;cursor:pointer;">' +
              '<input type="radio" name="posthocGrouping" value="ref" onchange="updatePosthocDisplay()"> vs Reference' +
              '</label>' +
              '<select id="posthocRefGroup" style="height:24px;padding:0 6px;border-radius:4px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);color:#fff;font-size:11px;display:none;" onchange="updatePosthocDisplay()">' +
              '<option value="">Select timepoint...</option>' +
              '</select>' +
              '</div>';
          } else if (currentMethod === "conover") {
            heading.textContent = 'Post-hoc Pairwise Comparisons (Conover)';
          } else if (currentMethod === "nemenyi") {
            heading.textContent = 'Post-hoc Pairwise Comparisons (Nemenyi)';
          } else {
            heading.textContent = 'Post-hoc Pairwise Comparisons (Rank-based)';
          }
        } else {
          heading.innerHTML = 'Post-hoc Pairwise Comparisons (Paired t-tests)' +
            '<div style="float:right;display:inline-flex;gap:8px;align-items:center;font-size:11px;font-weight:600;text-transform:none;">' +
            '<span style="opacity:0.8;">Filter:</span>' +
            '<label style="display:inline-flex;align-items:center;gap:4px;cursor:pointer;">' +
            '<input type="radio" name="posthocGrouping" value="all" checked onchange="updatePosthocDisplay()"> All pairs' +
            '</label>' +
            '<label style="display:inline-flex;align-items:center;gap:4px;cursor:pointer;">' +
            '<input type="radio" name="posthocGrouping" value="ref" onchange="updatePosthocDisplay()"> vs Reference' +
            '</label>' +
            '<select id="posthocRefGroup" style="height:24px;padding:0 6px;border-radius:4px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);color:#fff;font-size:11px;display:none;" onchange="updatePosthocDisplay()">' +
            '<option value="">Select timepoint...</option>' +
            '</select>' +
            '</div>';
        }
      }
      
      // Update table header based on framework
      if (tableHeader && isNonParam) {
        tableHeader.innerHTML = `
          <th style="cursor:pointer;" onclick="sortPosthocTable('comparison')">Comparison ‚Üï</th>
          <th style="cursor:pointer;" onclick="sortPosthocTable('statistic')">Z ‚Üï</th>
          <th style="cursor:pointer;" onclick="sortPosthocTable('rawp')">Raw p ‚Üï</th>
          <th style="cursor:pointer;" onclick="sortPosthocTable('adjp')">Adj p ‚Üï</th>
          <th style="cursor:pointer;" onclick="sortPosthocTable('estimate')">Effect size r ‚Üï</th>
          <th style="text-align:center;">Sig</th>
        `;
      } else if (tableHeader && !isNonParam) {
        tableHeader.innerHTML = `
          <th style="cursor:pointer;" onclick="sortPosthocTable('comparison')">Comparison ‚Üï</th>
          <th style="cursor:pointer;" onclick="sortPosthocTable('statistic')">Statistic ‚Üï</th>
          <th style="cursor:pointer;" onclick="sortPosthocTable('rawp')">Raw p ‚Üï</th>
          <th style="cursor:pointer;" onclick="sortPosthocTable('adjp')">Adj p ‚Üï</th>
          <th style="cursor:pointer;" onclick="sortPosthocTable('estimate')">Estimate ‚Üï</th>
          <th style="cursor:pointer;" onclick="sortPosthocTable('ci')">95% CI ‚Üï</th>
          <th style="text-align:center;">Sig</th>
        `;
      }
      
      if (compareMode !== "k-plus" || !posthoc || !posthoc.enabled) {
        body.innerHTML = isNonParam ? '<tr><td colspan="6">No post-hoc comparisons available</td></tr>' : '<tr><td colspan="7">No post-hoc comparisons available</td></tr>';
        return;
      }
      
      // Check omnibus significance and show warning
      if (warningEl && lastBundle && lastBundle.results && lastBundle.results.omnibus) {
        const ob = lastBundle.results.omnibus;
        const anovaP = parseMaybeNumber(ob.anovaP);
        const friedmanP = parseMaybeNumber(ob.kwP);
        const relevantP = isNonParam ? friedmanP : anovaP;
        const alpha = 0.05;
        if (relevantP > alpha) {
          warningEl.style.display = 'block';
        } else {
          warningEl.style.display = 'none';
        }
      }
      
      // Update method note
      const method = posthoc.method || currentMethod || "paired";
      const pCorrectionRadio = document.querySelector('input[name="pCorrection"]:checked');
      const correction = pCorrectionRadio ? pCorrectionRadio.value : "holm";
      const correctionName = correction === "bh" ? "FDR (Benjamini-Hochberg)" : 
                             correction === "bonferroni" ? "Bonferroni" :
                             correction === "none" ? "None" : "Holm";
      if (noteEl) {
        let methodDesc = "";
        if (isNonParam) {
          if (method === "wilcoxon") {
            methodDesc = "Wilcoxon Signed-Rank test (rank-based pairwise comparisons)";
          } else if (method === "conover") {
            methodDesc = "Conover test (post-hoc for Friedman)";
          } else if (method === "nemenyi") {
            methodDesc = "Nemenyi test (post-hoc for Friedman)";
          } else {
            methodDesc = "Rank-based " + method + " test";
          }
        } else {
          if (method === "paired") {
            methodDesc = "Paired t-tests (parametric pairwise comparisons)";
          } else if (method === "paired-baseline") {
            methodDesc = "Paired t-tests vs Baseline";
          } else {
            methodDesc = "Paired " + method + " test";
          }
        }
        noteEl.textContent = methodDesc + " | p-value correction: " + correctionName;
      }
      
      const rows = posthoc.rows || [];
      if (!rows.length) {
        body.innerHTML = isNonParam ? '<tr><td colspan="6">No post-hoc comparisons available</td></tr>' : '<tr><td colspan="7">No post-hoc comparisons available</td></tr>';
        return;
      }
      
      // Store data globally for sorting/filtering
      posthocData = rows.map(function(r) {
        // Calculate CI if not provided (using standard error approximation)
        let ciLower = parseMaybeNumber(r.ciLower);
        let ciUpper = parseMaybeNumber(r.ciUpper);
        if (!isFinite(ciLower) || !isFinite(ciUpper)) {
          // Approximate CI from estimate and t-statistic
          const est = parseMaybeNumber(r.estimate);
          const t = Math.abs(parseMaybeNumber(r.statistic));
          if (isFinite(est) && isFinite(t) && t > 0) {
            const se = Math.abs(est / t);
            const tCrit = 2.0; // Approximate 95% t-critical
            ciLower = est - tCrit * se;
            ciUpper = est + tCrit * se;
          }
        }
        
        return {
          comparison: r.comparison || "",
          statistic: r.statistic,
          rawP: parseMaybeNumber(r.rawP),
          adjP: parseMaybeNumber(r.adjP),
          estimate: parseMaybeNumber(r.estimate),
          ciLower: ciLower,
          ciUpper: ciUpper,
          significant: parseMaybeNumber(r.adjP) < 0.05
        };
      });
      
      // Populate reference group dropdown
      if (refSelect) {
        const groups = [];
        posthocData.forEach(function(r) {
          const parts = r.comparison.split(/\s*vs\.?\s*/i);
          if (parts.length === 2) {
            const g1 = parts[0].trim();
            const g2 = parts[1].trim();
            if (g1 && groups.indexOf(g1) === -1) groups.push(g1);
            if (g2 && groups.indexOf(g2) === -1) groups.push(g2);
          }
        });
        
        if (groups.length > 0) {
          refSelect.innerHTML = '<option value="">All groups</option>' + 
            groups.map(g => '<option value="' + g + '">' + g + '</option>').join('');
          // Auto-select first group for better UX
          if (groups.length > 0) refSelect.value = groups[0];
        } else {
          refSelect.innerHTML = '<option value="">No groups available</option>';
        }
      }
      
      updatePosthocDisplay();
    }
    
    function updatePosthocDisplay() {
      const body = document.getElementById("posthocBody");
      const refSelect = document.getElementById("posthocRefGroup");
      if (!body || !posthocData.length) return;
      
      // Get grouping mode
      const grouping = document.querySelector('input[name="posthocGrouping"]:checked')?.value || 'all';
      const refGroup = refSelect ? refSelect.value : '';
      
      // Show/hide reference dropdown
      if (refSelect) {
        refSelect.style.display = (grouping === 'ref') ? 'inline-block' : 'none';
      }
      
      // Filter data
      let displayData = posthocData;
      if (grouping === 'ref' && refGroup) {
        displayData = posthocData.filter(function(r) {
          // Match if refGroup appears in the comparison
          const parts = r.comparison.split(/\s*vs\.?\s*/i);
          return parts.some(p => p.trim().toLowerCase() === refGroup.toLowerCase());
        });
      }
      
      // Sort data
      displayData.sort(function(a, b) {
        let valA, valB;
        if (posthocSortColumn === 'comparison') {
          return posthocSortAsc ? a.comparison.localeCompare(b.comparison) : b.comparison.localeCompare(a.comparison);
        } else if (posthocSortColumn === 'statistic') {
          valA = a.statistic; valB = b.statistic;
        } else if (posthocSortColumn === 'rawp') {
          valA = a.rawP; valB = b.rawP;
        } else if (posthocSortColumn === 'adjp') {
          valA = a.adjP; valB = b.adjP;
        } else if (posthocSortColumn === 'estimate') {
          valA = Math.abs(a.estimate); valB = Math.abs(b.estimate);
        } else if (posthocSortColumn === 'ci') {
          valA = a.ciUpper - a.ciLower; valB = b.ciUpper - b.ciLower;
        }
        return posthocSortAsc ? (valA - valB) : (valB - valA);
      });
      
      // Render table
      body.innerHTML = "";
      const MAX_RENDER = 200;
      const rowsToRender = displayData.slice(0, MAX_RENDER);
      const isNonParam = primaryFramework === "nonparametric";
      
      rowsToRender.forEach(function(r){
        const tr = document.createElement("tr");
        
        // Comparison
        let td = document.createElement("td");
        td.textContent = r.comparison;
        tr.appendChild(td);
        
        // Statistic (label as Z for nonparametric, t for parametric)
        td = document.createElement("td");
        td.textContent = fmt(r.statistic);
        td.style.fontFamily = "monospace";
        tr.appendChild(td);
        
        // Raw p
        td = document.createElement("td");
        td.textContent = fmtP(r.rawP);
        td.style.fontFamily = "monospace";
        tr.appendChild(td);
        
        // Adj p
        td = document.createElement("td");
        td.textContent = fmtP(r.adjP);
        td.style.fontFamily = "monospace";
        tr.appendChild(td);
        
        // Estimate (effect size r for nonparametric, mean diff for parametric)
        td = document.createElement("td");
        td.textContent = fmt(r.estimate);
        td.style.fontFamily = "monospace";
        tr.appendChild(td);
        
        // 95% CI (only for parametric)
        if (!isNonParam) {
          td = document.createElement("td");
          if (isFinite(r.ciLower) && isFinite(r.ciUpper)) {
            td.textContent = "[" + fmt(r.ciLower) + ", " + fmt(r.ciUpper) + "]";
          } else {
            td.textContent = "‚Äî";
          }
          td.style.fontFamily = "monospace";
          td.style.fontSize = "10px";
          tr.appendChild(td);
        }
        
        // Significance indicator
        td = document.createElement("td");
        td.style.textAlign = "center";
        if (r.significant) {
          td.innerHTML = '<span style="color:#4ade80;font-weight:800;font-size:14px;">‚úî</span>';
        } else {
          td.innerHTML = '<span style="color:#64748b;font-weight:400;font-size:14px;">‚úñ</span>';
        }
        tr.appendChild(td);
        
        body.appendChild(tr);
      });
      
      if (displayData.length > MAX_RENDER) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = isNonParam ? 6 : 7;
        td.textContent = "... " + (displayData.length - MAX_RENDER) + " more rows (table capped at " + MAX_RENDER + ")";
        td.style.textAlign = "center";
        td.style.fontStyle = "italic";
        td.style.color = "var(--text-muted)";
        tr.appendChild(td);
        body.appendChild(tr);
      }
    }
    
    function sortPosthocTable(column) {
      if (posthocSortColumn === column) {
        posthocSortAsc = !posthocSortAsc;
      } else {
        posthocSortColumn = column;
        posthocSortAsc = (column === 'adjp' || column === 'rawp'); // Ascending for p-values
      }
      updatePosthocDisplay();
    }

    
    // === Descriptive Stats Functions ===
    let descSelectedRow = null;
    let descData = [];
    
    function populateDescriptiveStats(headers, rows) {
      if (!Array.isArray(headers) || !Array.isArray(rows)) return;
      
      descData = headers.map(varName => {
        const values = rows
          .map(row => row[varName])
          .map(v => typeof v === 'number' ? v : parseFloat(v))
          .filter(v => isFinite(v));
        
        if (values.length === 0) return null;
        
        const sorted = values.slice().sort((a, b) => a - b);
        const n = values.length;
        const mean = values.reduce((sum, v) => sum + v, 0) / n;
        const median = n % 2 === 0 
          ? (sorted[n/2 - 1] + sorted[n/2]) / 2 
          : sorted[Math.floor(n/2)];
        
        const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / n;
        const stdDev = Math.sqrt(variance);
        const skew = values.reduce((sum, v) => sum + Math.pow((v - mean) / stdDev, 3), 0) / n;
        const kurt = values.reduce((sum, v) => sum + Math.pow((v - mean) / stdDev, 4), 0) / n - 3;
        
        return {
          Variable: varName,
          N: n,
          Mean: mean,
          StdDev: stdDev,
          Min: Math.min(...values),
          Median: median,
          Max: Math.max(...values),
          Skew: skew,
          Kurt: kurt,
          vector: values
        };
      }).filter(stat => stat !== null);
      
      renderDescriptiveTable();
      if (descData.length > 0) {
        selectDescRow(descData[0]);
      }
    }
    
    function renderDescriptiveTable() {
      const tbody = document.getElementById('desc-stats-body');
      if (!tbody) return;
      tbody.innerHTML = '';
      
      descData.forEach(row => {
        const tr = document.createElement('tr');
        if (descSelectedRow && row.Variable === descSelectedRow.Variable) {
          tr.className = 'selected';
        }
        
        const tdVariable = document.createElement('td');
        tdVariable.textContent = row.Variable;
        tdVariable.style.textAlign = 'left';
        tr.appendChild(tdVariable);
        
        ['N', 'Mean', 'StdDev', 'Min', 'Median', 'Max', 'Skew', 'Kurt'].forEach(field => {
          const td = document.createElement('td');
          td.textContent = field === 'N' ? row[field] : fmt(row[field]);
          tr.appendChild(td);
        });
        
        tr.addEventListener('click', () => selectDescRow(row));
        tbody.appendChild(tr);
      });
    }
    
    function selectDescRow(row) {
      descSelectedRow = row;
      renderDescriptiveTable();
      
      document.getElementById('desc-histogram-title').textContent = row.Variable;
      document.getElementById('desc-histogram-panel').style.display = 'block';
      
      renderDescHistogram();
      updateDescSummary();
    }
    
    function updateDescSummary() {
      if (!descSelectedRow) return;
      const summaryTable = document.getElementById('desc-summary-table');
      if (!summaryTable) return;
      
      summaryTable.innerHTML = `
        <div><strong>N:</strong><span>${descSelectedRow.N}</span></div>
        <div><strong>Mean:</strong><span>${fmt(descSelectedRow.Mean)}</span></div>
        <div><strong>StdDev:</strong><span>${fmt(descSelectedRow.StdDev)}</span></div>
        <div><strong>Min:</strong><span>${fmt(descSelectedRow.Min)}</span></div>
        <div><strong>Median:</strong><span>${fmt(descSelectedRow.Median)}</span></div>
        <div><strong>Max:</strong><span>${fmt(descSelectedRow.Max)}</span></div>
        <div><strong>Skew:</strong><span>${fmt(descSelectedRow.Skew)}</span></div>
        <div><strong>Kurt:</strong><span>${fmt(descSelectedRow.Kurt)}</span></div>
      `;
    }
    
    function renderDescHistogram() {
      if (!descSelectedRow || !descSelectedRow.vector) return;
      
      const container = document.getElementById('histogram-container-kplus');
      if (!container) return;
      
      // Get current bin count from slider
      const binsSlider = document.getElementById('histogramBins');
      const numBins = binsSlider ? parseInt(binsSlider.value) : 10;
      
      const width = container.clientWidth || 600;
      const height = 280;
      
      d3.select('#histogram-container-kplus').selectAll('*').remove();
      
      const svg = d3.select('#histogram-container-kplus')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .style('overflow', 'visible');
      
      const margin = { top: 15, right: 25, bottom: 50, left: 40 };
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;
      
      const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
      
      const values = descSelectedRow.vector;
      const min = Math.min(...values);
      const max = Math.max(...values);
      const range = max - min;
      const binWidth = range / numBins;
      
      const histData = Array.from({ length: numBins }, (_, i) => {
        const start = min + i * binWidth;
        const end = min + (i + 1) * binWidth;
        const binLabel = `${start.toFixed(1)}-${end.toFixed(1)}`;
        let count = 0;
        values.forEach(v => {
          if (v >= start && (i === numBins - 1 ? v <= end : v < end)) count++;
        });
        return { bin: binLabel, start, end, count };
      });
      
      const x = d3.scaleBand()
        .domain(histData.map(d => d.bin))
        .range([0, innerWidth])
        .padding(0.1);
      
      const maxCount = d3.max(histData, d => d.count);
      const y = d3.scaleLinear()
        .domain([0, maxCount + (maxCount * 0.1)])
        .range([innerHeight, 0]);
      
      // X-axis with range labels
      const xAxis = g.append('g')
        .attr('class', 'axis')
        .attr('transform', `translate(0,${innerHeight})`)
        .call(d3.axisBottom(x)
          .tickValues(x.domain().filter((d, i) => {
            // Show labels based on number of bins
            if (numBins <= 10) return true; // Show all
            if (numBins <= 15) return i % 2 === 0; // Every other
            if (numBins <= 20) return i % 3 === 0; // Every 3rd
            return i % 4 === 0; // Every 4th
          }))
        );
      
      xAxis.selectAll('text')
        .style('text-anchor', 'end')
        .attr('dx', '-.5em')
        .attr('dy', '.5em')
        .attr('font-size', '9px')
        .attr('transform', 'rotate(-45)');
      
      // Y-axis
      g.append('g')
        .attr('class', 'axis')
        .call(d3.axisLeft(y).ticks(5));
      
      // Grid
      g.append('g')
        .attr('class', 'grid')
        .call(d3.axisLeft(y).ticks(5).tickSize(-innerWidth).tickFormat(''));
      
      // Bars
      g.selectAll('.histogram-bar')
        .data(histData)
        .enter().append('rect')
        .attr('class', 'histogram-bar')
        .attr('x', d => x(d.bin))
        .attr('width', x.bandwidth())
        .attr('y', d => y(d.count))
        .attr('height', d => innerHeight - y(d.count))
        .append('title')
        .text(d => `${d.bin}: ${d.count} values`);
      
      // Add normal curve
      const mean = descSelectedRow.Mean;
      const stdDev = descSelectedRow.StdDev;
      const normalData = [];
      const step = range / 50;
      for (let x_val = min - range * 0.1; x_val <= max + range * 0.1; x_val += step) {
        const exponent = -Math.pow(x_val - mean, 2) / (2 * Math.pow(stdDev, 2));
        const y_val = (1 / (stdDev * Math.sqrt(2 * Math.PI))) * Math.exp(exponent);
        normalData.push({ x: x_val, y: y_val });
      }
      
      const maxNormalY = d3.max(normalData, d => d.y);
      const normalScale = maxCount / maxNormalY * 0.8;
      
      const xScale = d3.scaleLinear()
        .domain([min, max])
        .range([0, innerWidth]);
      
      const line = d3.line()
        .x(d => xScale(d.x))
        .y(d => y(d.y * normalScale));
      
      g.append('path')
        .datum(normalData)
        .attr('class', 'normal-curve')
        .attr('d', line);
    }
    
    function openNormalityModal() {
      if (!descSelectedRow) {
        alert('Please select a variable first');
        return;
      }
      
      document.getElementById('modal-variable-name').textContent = descSelectedRow.Variable;
      document.getElementById('modal-sample-size').textContent = `(n=${descSelectedRow.N})`;
      document.getElementById('modal-variable-detail').textContent = descSelectedRow.Variable;
      document.getElementById('modal-n-detail').textContent = descSelectedRow.N;
      document.getElementById('modal-mean-detail').textContent = fmt(descSelectedRow.Mean);
      document.getElementById('modal-sd-detail').textContent = fmt(descSelectedRow.StdDev);
      
      document.getElementById('normality-modal').style.display = 'block';
      document.body.style.overflow = 'hidden';
    }
    
    function closeNormalityModal() {
      document.getElementById('normality-modal').style.display = 'none';
      document.body.style.overflow = 'auto';
    }
    
    function populateBundle(b){
      console.log("üîÑ populateBundle called with:", b);
      lastBundle = b || {};
      const s=b.setup||{}, e=b.explore||{}, a=b.assumptions||{}, r=b.results||{}, fx=b.effects||{}, p=b.power||{}, rep=b.report||{};
      console.log("üì¶ Bundle sections:", {
        hasSetup: !!b.setup,
        hasExplore: !!b.explore,
        hasAssumptions: !!b.assumptions,
        hasResults: !!b.results,
        hasEffects: !!b.effects,
        hasPower: !!b.power,
        hasReport: !!b.report
      });
      console.log("üî¨ Results object:", r);
      console.log("üìä Results.omnibus:", r.omnibus);
      console.log("üîç Explore object:", e);
      
      // Check if we have the required data for ANOVA
      if (!r.omnibus) {
        console.warn("‚ö†Ô∏è WARNING: No omnibus data in results - ANOVA table will show placeholders");
      } else if (!r.omnibus.anovaF && !r.omnibus.kwH) {
        console.warn("‚ö†Ô∏è WARNING: Omnibus data exists but missing test statistics");
      }
      
      availableHeaders = Array.isArray(s.headers) ? s.headers.slice() : availableHeaders;
      persistedColumns.groupA = s.groupA || persistedColumns.groupA;
      persistedColumns.groupB = s.groupB || persistedColumns.groupB;
      persistedColumns.valueColumn = s.valueColumn || persistedColumns.valueColumn;
      persistedColumns.groupColumn = s.groupColumn || persistedColumns.groupColumn;
      currentCompareMode = "k-plus";
      currentPrimaryTest = s.primaryTest || currentPrimaryTest || "welch";
      
      // Populate descriptive stats with selected columns data
      if (window.dependentRangeData && Array.isArray(s.selectedColumns)) {
        const headers = window.dependentRangeData[0] || [];
        const dataRows = window.dependentRangeData.slice(1);
        
        // Convert array-of-arrays to array-of-objects
        const rowObjects = dataRows.map(row => {
          const obj = {};
          headers.forEach((header, idx) => {
            obj[header] = row[idx];
          });
          return obj;
        });
        
        populateDescriptiveStats(s.selectedColumns, rowObjects);
      }
      
      var testSel = document.getElementById("setPrimaryTest");
      if (testSel) testSel.value = currentPrimaryTest;
      setFrameworkButtons(s.primaryFramework || primaryFramework);
      var alphaEl = document.getElementById("setAlpha");
      if (alphaEl) alphaEl.value = String(1 - (parseMaybeNumber(s.confidence) || 0.95));
      var orientation = s.hypothesis || "two-sided";
      currentHypothesis = orientation;
      var radio = document.querySelector('input[name="h1Orientation"][value="' + orientation + '"]');
      if (radio) radio.checked = true;
      const phm = document.getElementById("setPosthocMethod"); if (phm) phm.value = s.posthocMethod || "games-howell";
      const phc = document.getElementById("setPosthocCorrection"); if (phc) phc.value = s.posthocCorrection || "holm";
      renderCompareStatsRow(s, e);
      refreshSettingsVisibility();
      updatePosthocOptions();
      const ksum = e.kplusSummary || {};
      const ob = r.omnibus || {};
      
      // Check if we have omnibus data
      if (!ob || !ob.anovaF) {
        console.error("‚ùå CRITICAL: No omnibus data found in results!");
        console.log("Full results object:", r);
        console.log("Omnibus object:", ob);
        console.log("This means computeRepeatedMeasuresANOVA() did not run or failed.");
        
        // Display error message in the ANOVA table
        const anovaBody = document.getElementById("anovaSummaryBody");
        if (anovaBody) {
          anovaBody.innerHTML = '<tr><td colspan="6" style="text-align:center;color:#ff6b6b;padding:20px;">‚ö†Ô∏è No ANOVA results computed. Please ensure you have selected 3+ timepoint columns and have valid data.</td></tr>';
        }
      }
      
      const groupCount = isFinite(parseMaybeNumber(ksum.variableCount)) 
        ? parseMaybeNumber(ksum.variableCount) 
        : (Array.isArray(ob.groupDescriptives) ? ob.groupDescriptives.length : (Array.isArray(s.selectedColumns) ? s.selectedColumns.length : "..."));
      setText("expVarCount", Math.round(groupCount));
      
      // Display missing data information
      const totalRows = parseMaybeNumber(e.totalRows) || 0;
      const completeCasesExplore = isFinite(parseMaybeNumber(ksum.totalN)) ? Math.round(parseMaybeNumber(ksum.totalN)) : (isFinite(ob.N) ? Math.round(ob.N) : 0);
      const missingCount = parseMaybeNumber(e.missingCount) || 0;
      const missingPct = parseMaybeNumber(e.missingPct) || 0;
      
      setText("expTotalRows", totalRows);
      setText("expTotalN", completeCasesExplore);
      
      const warningEl = document.getElementById("missingDataWarning");
      if (warningEl && missingCount > 0) {
        warningEl.style.display = "block";
        setText("missingCount", missingCount);
        setText("missingPct", missingPct.toFixed(1));
      } else if (warningEl) {
        warningEl.style.display = "none";
      }
      
      setText("expLevels", isFinite(parseMaybeNumber(ksum.levelsCount)) ? Math.round(parseMaybeNumber(ksum.levelsCount)) : "...");
      setText("expOverallMean", isFinite(parseMaybeNumber(ksum.meanOverall)) ? fmt(ksum.meanOverall) : "...");
      setText("expFramework", primaryFramework === "nonparametric" ? "Nonparametric (ranks)" : "Parametric (means)");
      
      // Populate Profile Plot and Correlation Matrix
      populateProfilePlot(e, ob);
      populateCorrelationMatrix(e);
      
      const alpha = 0.05;
      const leveneP = parseMaybeNumber((ob.levene || {}).p);
      const bfP = parseMaybeNumber((ob.brownForsythe || {}).p);
      const welchP = parseMaybeNumber((ob.welchAnova || {}).p);
      const anovaP = parseMaybeNumber(ob.anovaP);
      
      // Design Balance Indicator (RM: focus on complete cases, not balance)
      const balanceEl = document.getElementById("balanceText");
      if (balanceEl) {
        const completeCasesBalance = parseMaybeNumber(ob.N) || 0;
        const totalRowsBalance = parseMaybeNumber(e.totalRows) || parseMaybeNumber(lastBundle.totalRows) || 0;
        const missingSubjects = totalRowsBalance - completeCasesBalance;
        
        let balanceText = "";
        if (missingSubjects === 0) {
          balanceText = "‚úì Complete data: " + completeCasesBalance + " subjects (no missing values)";
        } else {
          const missingPct = totalRowsBalance > 0 ? ((missingSubjects / totalRowsBalance) * 100).toFixed(1) : 0;
          balanceText = "‚ö† Complete cases: " + completeCasesBalance + " subjects (" + missingSubjects + " excluded due to missing data, " + missingPct + "%)";
        }
        balanceEl.textContent = balanceText;
      }
      
      // Sphericity Test (Mauchly)
      const sphericity = ob.sphericity || {};
      const mauchlyW = parseMaybeNumber(sphericity.W);
      const mauchlyP = parseMaybeNumber(sphericity.p);
      const epsilonGG = parseMaybeNumber(sphericity.epsilonGG);
      const epsilonHF = parseMaybeNumber(sphericity.epsilonHF);
      const sphericityMet = sphericity.sphericityMet !== false;
      
      setText("asMauchlyW", fmt(mauchlyW));
      setText("asMauchlyP", fmtP(mauchlyP));
      setText("asEpsilonGG", fmt(epsilonGG));
      setText("asEpsilonHF", fmt(epsilonHF));
      
      // Complete cases: use ob.N (from omnibus) or fall back to totalN
      const completeCasesAssumptions = parseMaybeNumber(ob.N) || parseMaybeNumber(lastBundle.totalN) || 0;
      setText("asCompleteCases", completeCasesAssumptions);
      
      // Mauchly verdict
      const mauchlyEl = document.getElementById("asMauchlyVerdict");
      if (mauchlyEl) {
        if (sphericityMet) {
          mauchlyEl.textContent = "‚úì Sphericity assumption met (p > 0.05)";
          mauchlyEl.style.color = "#4ade80";
        } else {
          mauchlyEl.textContent = "‚ö† Sphericity violated (p < 0.05) - Corrections applied";
          mauchlyEl.style.color = "#fbbf24";
        }
      }
      
      // Recommendation text for repeated measures
      const recoEl = document.getElementById("asRecoText");
      if (recoEl) {
        let recoText = "";
        const anovaSig = anovaP < alpha;
        const friedmanP = parseMaybeNumber(ob.kwP);
        const friedmanSig = friedmanP < alpha;
        
        // Get current correction method for dynamic recommendation
        var corrMethod = document.getElementById("setPosthocCorrection");
        var corrName = corrMethod && corrMethod.value === "bh" ? "FDR (Benjamini-Hochberg)" : 
                      corrMethod && corrMethod.value === "bonferroni" ? "Bonferroni" :
                      corrMethod && corrMethod.value === "none" ? "no" : "Holm";
        
        // PARAMETRIC MODE (RM-ANOVA)
        if (primaryFramework === "parametric") {
          if (sphericityMet) {
            recoText = "‚úì <strong>Repeated Measures ANOVA is appropriate.</strong> The sphericity assumption is met (Mauchly's W = " + fmt(mauchlyW) + ", p = " + fmtP(mauchlyP) + "). ";
            if (anovaSig) {
              recoText += "The RM-ANOVA shows <strong>significant differences</strong> across timepoints (p " + fmtP(anovaP) + "). Proceed with <strong>paired post-hoc tests</strong> with " + corrName + " correction.";
            } else {
              recoText += "The RM-ANOVA shows <strong>no significant differences</strong> across timepoints (p = " + fmtP(anovaP) + ").";
            }
          } else {
            recoText = "‚ö† <strong>Sphericity assumption violated - Corrections applied.</strong> ";
            recoText += "Greenhouse-Geisser Œµ = " + fmt(epsilonGG) + ", Huynh-Feldt Œµ = " + fmt(epsilonHF) + ". ";
            
            const pValueGG = parseMaybeNumber(ob.anovaPGG);
            const pValueHF = parseMaybeNumber(ob.anovaPHF);
            
            if (pValueGG < alpha) {
              recoText += "Even with correction, differences are <strong>significant</strong> (GG-corrected p " + fmtP(pValueGG) + "). ";
              recoText += "Proceed with <strong>paired post-hoc tests</strong> with " + corrName + " correction.";
            } else {
              recoText += "With correction applied, no significant differences detected (GG-corrected p = " + fmtP(pValueGG) + ").";
            }
          }
          
          // Add Friedman note if parametric assumptions are questionable
          if (friedmanSig === anovaSig) {
            recoText += " <em>Note: Friedman test (nonparametric alternative) confirms the " + (anovaSig ? "significant" : "non-significant") + " result.</em>";
          }
        } 
        // NONPARAMETRIC MODE (Friedman)
        else {
          recoText = "‚úì <strong>Friedman test (nonparametric).</strong> This rank-based test is assumption-free and robust to outliers and non-normality. ";
          
          if (friedmanSig) {
            var posthocMethod = document.getElementById("setPosthocMethod");
            var posthocName = posthocMethod && posthocMethod.value === "conover" ? "Conover" :
                            posthocMethod && posthocMethod.value === "nemenyi" ? "Nemenyi" : "Wilcoxon Signed-Rank";
            recoText += "The Friedman test shows <strong>significant differences</strong> across timepoints (œá¬≤ = " + fmt(ob.kwH) + ", p " + fmtP(friedmanP) + "). ";
            recoText += "Proceed with <strong>" + posthocName + " post-hoc tests</strong> with " + corrName + " correction.";
          } else {
            recoText += "The Friedman test shows <strong>no significant differences</strong> across timepoints (œá¬≤ = " + fmt(ob.kwH) + ", p = " + fmtP(friedmanP) + ").";
          }
          
          // Add RM-ANOVA note for comparison
          if (friedmanSig === anovaSig) {
            recoText += " <em>Note: RM-ANOVA (parametric alternative) confirms the " + (friedmanSig ? "significant" : "non-significant") + " result.</em>";
          }
        }
        
        recoEl.innerHTML = recoText;
      }
      
      // Auto-select post-hoc method based on framework
      const posthocSelect = document.getElementById("setPosthocMethod");
      if (posthocSelect) {
        if (primaryFramework === "parametric") {
          posthocSelect.value = "paired"; // Paired t-tests for RM-ANOVA
        } else {
          posthocSelect.value = "wilcoxon"; // Wilcoxon for Friedman
        }
      }
      updateResultsPanels(r, fx, s, 1 - (parseMaybeNumber(s.confidence) || 0.95));
      renderPosthoc(r.posthoc || {}, "k-plus");
      
      // Effect sizes (RM-appropriate)
      setText("efPartialEta", fmt(ob.partialEtaSquared));
      setText("efGeneralizedEta", fmt(ob.generalizedEtaSquared));
      setText("efEta", fmt(ob.etaSquared));
      setText("efOmega", fmt(ob.omegaSquared));
      setText("efCohenF", fmt(ob.cohenF));
      setText("efKendallW", fmt(ob.kendallW || ob.friedmanW));
      setText("efFriedmanChi", fmt(ob.friedmanChiSquare || ob.kwH));
      setText("efEpsilonSq", fmt(ob.epsilonSquared));
      
      setText("powNote", p.note); setText("powEndpoint", p.suggestedEndpoint); setText("powVal", fmt(p.placeholderPower));
      setText("repAnova", "RM-ANOVA: F(" + Math.round(ob.anovaDf1) + ", " + Math.round(ob.anovaDf2) + ") = " + fmt(ob.anovaF) + ", p " + fmtP(ob.anovaP) + ".");
      setText("repKw", "Friedman: œá¬≤(" + Math.round(ob.friedmanDf || ob.kwDf) + ") = " + fmt(ob.friedmanChiSquare || ob.kwH) + ", p " + fmtP(ob.friedmanP || ob.kwP) + ", Kendall W = " + fmt(ob.kendallW || 0) + ".");
      setText("repCons", rep.consistency);
    }
    function saveCurrentModel(){ sendToHost("savedependentModel", lastBundle||{}); }
    function exportHtml(){
      const blob = new Blob([document.documentElement.outerHTML], {type:"text/html"});
      const a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = "dependent-means-report.html"; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),500);
    }
    document.addEventListener("DOMContentLoaded", function(){
      document.querySelectorAll(".tab-button").forEach(btn=>btn.addEventListener("click",()=>switchTab(btn.getAttribute("data-tab"))));
      ["setAlpha","setPosthocMethod","setPosthocCorrection","setPrimaryTest"].forEach(function(id){
        const el = document.getElementById(id);
        if (el) el.addEventListener("change", function(){
          if (id === "setPrimaryTest") {
            currentPrimaryTest = el.value || "welch";
            setFrameworkButtons(primaryFramework);
          }
          // Update tooltip when post-hoc or correction changes
          if (id === "setPosthocMethod" || id === "setPosthocCorrection") {
            updatePosthocOptions();
          }
          notifySettingsChanged();
        });
      });
      document.querySelectorAll('input[name="h1Orientation"]').forEach(function(el){ el.addEventListener("change", notifySettingsChanged); });
      var rp = document.getElementById("fwParametric");
      var rn = document.getElementById("fwNonparametric");
      if (rp) rp.addEventListener("change", function(){ if (rp.checked) { setFrameworkButtons("parametric"); notifySettingsChanged(); } });
      if (rn) rn.addEventListener("change", function(){ if (rn.checked) { setFrameworkButtons("nonparametric"); notifySettingsChanged(); } });
      
      // Histogram bins slider handler
      const histogramBinsSlider = document.getElementById("histogramBins");
      const histogramBinsValue = document.getElementById("histogramBinsValue");
      if (histogramBinsSlider && histogramBinsValue) {
        histogramBinsSlider.addEventListener("input", function() {
          histogramBinsValue.textContent = this.value;
          renderDescHistogram();
        });
      }
      
      setFrameworkButtons(primaryFramework);
      refreshSettingsVisibility();
      Office.onReady(function(){
        // Close modal when clicking outside
        document.addEventListener('click', function(event) {
          const modal = document.getElementById('normality-modal');
          if (event.target === modal) {
            closeNormalityModal();
          }
        });
        
        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
          if (event.key === 'Escape') {
            closeNormalityModal();
          }
        });
        
        Office.context.ui.addHandlerAsync(Office.EventType.DialogParentMessageReceived, function(arg){
          const msg = JSON.parse(arg.message||"{}");
          if(msg.type==="DEPENDENT_BUNDLE"){
            // Store raw data for descriptive stats
            if (msg.rawData) {
              window.dependentRangeData = msg.rawData;
            }
            populateBundle(msg.payload||{});
          }
        });
        if(Office&&Office.context&&Office.context.ui&&Office.context.ui.messageParent) {
          Office.context.ui.messageParent(JSON.stringify({action:"ready"}));
          setTimeout(()=>Office.context.ui.messageParent(JSON.stringify({action:"ready"})),500);
        }
      });
    });
    
    // === Profile Plot Function ===
    function populateProfilePlot(e, ob) {
      const svg = document.getElementById("profilePlot");
      if (!svg) return;
      
      // Clear existing content
      svg.innerHTML = '';
      
      // Get timepoint means and raw data
      const groupDescriptives = ob.groupDescriptives || [];
      if (groupDescriptives.length === 0) return;
      
      const k = groupDescriptives.length;
      const means = groupDescriptives.map(g => g.mean);
      const labels = groupDescriptives.map(g => g.name);
      
      // SVG dimensions
      const svgWidth = svg.clientWidth || 800;
      const svgHeight = 300;
      const margin = { top: 20, right: 40, bottom: 50, left: 60 };
      const width = svgWidth - margin.left - margin.right;
      const height = svgHeight - margin.top - margin.bottom;
      
      // Get individual subject data from lastBundle if available
      let subjectData = [];
      if (window.dependentRangeData && lastBundle.setup && lastBundle.setup.selectedColumns) {
        const headers = window.dependentRangeData[0] || [];
        const dataRows = window.dependentRangeData.slice(1);
        const selectedCols = lastBundle.setup.selectedColumns;
        
        // Extract complete cases
        dataRows.forEach(row => {
          const values = selectedCols.map(col => {
            const idx = headers.indexOf(col);
            return idx >= 0 ? parseFloat(row[idx]) : NaN;
          });
          if (values.every(v => isFinite(v))) {
            subjectData.push(values);
          }
        });
      }
      
      // Calculate scales
      let allValues = [...means];
      subjectData.forEach(subject => allValues.push(...subject));
      const yMin = Math.min(...allValues);
      const yMax = Math.max(...allValues);
      const yRange = yMax - yMin;
      const yPadding = yRange * 0.1;
      
      const xScale = (i) => margin.left + (i / (k - 1)) * width;
      const yScale = (val) => margin.top + height - ((val - yMin + yPadding) / (yRange + 2 * yPadding)) * height;
      
      // Create group element
      const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
      
      // Draw individual subject lines (spaghetti plot)
      subjectData.forEach((subject, subIdx) => {
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        let d = `M ${xScale(0)} ${yScale(subject[0])}`;
        for (let i = 1; i < k; i++) {
          d += ` L ${xScale(i)} ${yScale(subject[i])}`;
        }
        path.setAttribute("d", d);
        path.setAttribute("stroke", "#4fc3f7");
        path.setAttribute("stroke-width", "1");
        path.setAttribute("fill", "none");
        path.setAttribute("opacity", "0.3");
        g.appendChild(path);
      });
      
      // Draw mean line (bold)
      const meanPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
      let meanD = `M ${xScale(0)} ${yScale(means[0])}`;
      for (let i = 1; i < k; i++) {
        meanD += ` L ${xScale(i)} ${yScale(means[i])}`;
      }
      meanPath.setAttribute("d", meanD);
      meanPath.setAttribute("stroke", "#ff9800");
      meanPath.setAttribute("stroke-width", "3");
      meanPath.setAttribute("fill", "none");
      g.appendChild(meanPath);
      
      // Draw mean points
      means.forEach((mean, i) => {
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", xScale(i));
        circle.setAttribute("cy", yScale(mean));
        circle.setAttribute("r", "5");
        circle.setAttribute("fill", "#ff9800");
        circle.setAttribute("stroke", "#1a2332");
        circle.setAttribute("stroke-width", "2");
        g.appendChild(circle);
      });
      
      // X-axis
      const xAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
      xAxis.setAttribute("x1", margin.left);
      xAxis.setAttribute("y1", margin.top + height);
      xAxis.setAttribute("x2", margin.left + width);
      xAxis.setAttribute("y2", margin.top + height);
      xAxis.setAttribute("stroke", "#666");
      xAxis.setAttribute("stroke-width", "1");
      g.appendChild(xAxis);
      
      // Y-axis
      const yAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
      yAxis.setAttribute("x1", margin.left);
      yAxis.setAttribute("y1", margin.top);
      yAxis.setAttribute("x2", margin.left);
      yAxis.setAttribute("y2", margin.top + height);
      yAxis.setAttribute("stroke", "#666");
      yAxis.setAttribute("stroke-width", "1");
      g.appendChild(yAxis);
      
      // X-axis labels
      labels.forEach((label, i) => {
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", xScale(i));
        text.setAttribute("y", margin.top + height + 20);
        text.setAttribute("text-anchor", "middle");
        text.setAttribute("fill", "#ccc");
        text.setAttribute("font-size", "11");
        text.textContent = label;
        g.appendChild(text);
      });
      
      // Y-axis labels (3 ticks)
      const yTicks = [yMin, (yMin + yMax) / 2, yMax];
      yTicks.forEach(tick => {
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", margin.left - 10);
        text.setAttribute("y", yScale(tick) + 4);
        text.setAttribute("text-anchor", "end");
        text.setAttribute("fill", "#ccc");
        text.setAttribute("font-size", "10");
        text.textContent = tick.toFixed(1);
        g.appendChild(text);
        
        // Grid line
        const gridLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        gridLine.setAttribute("x1", margin.left);
        gridLine.setAttribute("y1", yScale(tick));
        gridLine.setAttribute("x2", margin.left + width);
        gridLine.setAttribute("y2", yScale(tick));
        gridLine.setAttribute("stroke", "#333");
        gridLine.setAttribute("stroke-width", "1");
        gridLine.setAttribute("stroke-dasharray", "3,3");
        gridLine.setAttribute("opacity", "0.5");
        g.appendChild(gridLine);
      });
      
      svg.appendChild(g);
    }
    
    // === Correlation Matrix Function ===
    function populateCorrelationMatrix(e) {
      const corrMatrix = e.correlationMatrix;
      if (!corrMatrix) return;
      
      const tbody = document.getElementById("corrMatrixBody");
      if (!tbody) return;
      tbody.innerHTML = '';
      
      // Populate correlation pairs
      const correlations = corrMatrix.correlations || [];
      correlations.forEach((corr, idx) => {
        const tr = document.createElement('tr');
        if (idx % 2 === 1) tr.style.background = 'rgba(255,255,255,.05)';
        
        // Pair name
        const tdPair = document.createElement('td');
        tdPair.textContent = corr.label || `Time ${corr.time1 + 1} - Time ${corr.time2 + 1}`;
        tdPair.style.padding = '6px 8px';
        tdPair.style.border = '1px solid rgba(255,255,255,.18)';
        tdPair.style.textAlign = 'left';
        tr.appendChild(tdPair);
        
        // Correlation value
        const tdR = document.createElement('td');
        tdR.textContent = corr.r.toFixed(3);
        tdR.style.padding = '6px 8px';
        tdR.style.border = '1px solid rgba(255,255,255,.18)';
        tdR.style.textAlign = 'center';
        tdR.style.fontWeight = '700';
        tdR.style.color = corr.r > 0.7 ? '#4caf50' : corr.r > 0.4 ? '#ff9800' : '#f44336';
        tr.appendChild(tdR);
        
        // Interpretation
        const tdInterp = document.createElement('td');
        const absR = Math.abs(corr.r);
        let interp = '';
        if (absR > 0.7) interp = 'Strong';
        else if (absR > 0.4) interp = 'Moderate';
        else if (absR > 0.2) interp = 'Weak';
        else interp = 'Very weak';
        tdInterp.textContent = interp;
        tdInterp.style.padding = '6px 8px';
        tdInterp.style.border = '1px solid rgba(255,255,255,.18)';
        tdInterp.style.textAlign = 'center';
        tr.appendChild(tdInterp);
        
        tbody.appendChild(tr);
      });
      
      // Populate summary
      setText("corrAvgR", corrMatrix.avgR.toFixed(3));
      setText("corrRange", corrMatrix.range.toFixed(3) + " (" + corrMatrix.minR.toFixed(2) + " to " + corrMatrix.maxR.toFixed(2) + ")");
      setText("corrCompound", corrMatrix.compoundSymmetry);
      setText("corrInterpretation", corrMatrix.interpretation);
    }
    
  </script>
</body>
</html>
